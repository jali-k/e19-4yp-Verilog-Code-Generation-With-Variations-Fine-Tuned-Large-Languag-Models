- code: |
    module T-FF (q, clk, reset) ;  
    output q;  
    input clk, reset;  
    wire d;  
    D-FF dff0 (q, d, clk, reset) ;  
    not nl(d, q) ; // not is a Verilog-provided primitive. case sensitive  endmodule  
  
  prompt: Create a T flip-flop module structurally by instantiating a D flip-flop (`D_FF`) and a `not` gate, feeding the inverted Q output back to the D input.


- code: |
    module fulladd4(sum, c-out, a, b, c-in);  
    //Begin port declarations section  
    output [3 : 01 sum;  
    output c-cout;  
    input [3:0] a, b;  
    input c-in;  
    //End port declarations section  
    ...  
    <module internals>  
    ...  
    endmodul e

  prompt: Write a loop that prints numbers 0 to 4

  
- code: |
    module Top;  
    //Declare connection variables  
    reg [3:O]A,B;  
    reg C-IN;  
    reg [3:01 SUM;  
    wire C-OUT;  
        //Instantiate fulladd4, call it fa0  
        fulladd4 faO(SUM, C-OUT, A, B, C-IN);  
        //Illegal connection because output port sum in module fulladd4  //is connected to a register variable SUM in module Top.  
    endmodule 

  prompt: Create a class with an initializer setting value to 0
- code: |
    module fulladd4 (sum, c-out, a, b, c-in) ;  
    output [3 : 01 sum;  
    output c-cout;  
    input [3:0] a, b;  
    input c-in;  
    ...  
    <module internals>  
    ... 
    endmodule  

- code: |
    // Define a 4-bit full adder  
    module fulladd4(sum, c-out, a, b, c-in);  
    // I/O port declarations  
    output [3:01 sum;  
    output c-out;  
    input [3 : 01 a, b;  
    input c-in;  
    // Internal nets  
    wire cl, c2, c3;  
    ate four l-bit full adders.  
    // Instanti  
    fulladd fa0  
    (sum[Ol, cl, a[Ol, b[Ol, c-in);  
    fulladd fa1  
    (sum[ll, c2, a[ll, b[ll, cl);  
    fulladd fa2  
    (surn[21, c3, a[21, b[21, c2);  
    fulladd fa3  
    (sumt31, c-out, at31, b[31, c3);  
    endmodule  

- code: |
    module ctr_wt(a,clk,N,En); 
    input clk,En; 
    input[3:0]N; 
    output[3:0]a; 
    reg[3:0]a; 
    initial a=4'b1111; 
    always 
    begin 
    wait(En) 
    @(negedge clk) 
    a=(a==N)?4'b0000:a+1'b1; 
    end 
    endmodule

- code: |
    module mux4_1 (out, in0, in1, in2, in3, s0, s1); 
    output out; 
    // out is declared as reg, as default is wire 
    reg out; 
    // out is declared as reg, because we will 
    // do a procedural assignment to it. 
    input in0, in1, in2, in3, s0, s1; 
    // always @(*) is equivalent to 
    // always @( in0, in1, in2, in3, s0, s1 ) 
    always @(*) 
    begin 
    case ({s1,s0}) 
    2'b00: out = in0; 
    2'b01: out = in1; 
    2'b10: out = in2; 
    2'b11: out = in3; 
    default: out = 1'bx; 
    endcase 
    end 
    endmodule
    2. Implementation of a full adder. 
    module full_adder (sum, c_out, in0, in1, c_in); 
    output sum, c_out; 
    reg sum, c_out 
    input in0, in1, c_in; 
    always @(*) 
    {c_out, sum} = in0 + in1 + c_in; 
    endmodule 

- code: |
    module ( count, reset, clk ); 
    output [7:0] count; 
    reg [7:0] count; 
    input reset, clk; 
    // consider reset as active low signal 
    always @( posedge clk, negedge reset) 
    begin 
    if(reset == 1'b0) 
    count <= 8'h00; 
    else 
    count <= count + 8'h01; 
    end 
    endmodule 

- code: |
    module ha_1(s,ca,a,b); 
    input a,b; output s,ca; 
    xor #(1,2) (s,a,b); 
    and #(3,4) (ca,a,b);  
    endmodule 

- code: |
    // Parallel connection 
    module M (out, a, b, c, d); 

    output out; 
    input a, b, c, d; 
    wire e, f; 
    //Specify block with path delay statements  specify 
    (a => out) = 9; 
    (b => out) = 9; 
    (c => out) = 11; 
    (d => out) = 11; 
    module M (out, a, b, c, d); output out; 
    input a, b, c, d; 
    wire e, f; 
    specify 
    (a,b *> out) = 9; 
    (c,d *> out) = 11; 
    endspecify 
    //gate instantiations 
    and a1(e, a, b); 
    and a2(f, c, d); 
    and a3(out, e, f); 
    endmodule 
    //Full Connection
    endspecify 
    and a1(e, a, b); 
    and a2(f, c, d); 
    and a3(out, e, f); 
    endmodule

- code: |
    // The ALU module with its size declared as a parameter. 
    module alu (d, co, a, b, f,cci); 
    parameter msb=3; 
    output [msb:0] d; output co;  
    wire[msb:0]d;  
    input cci;  
    input [msb : 0 ] a, b;  
    input [1 : 0] f;  
    specify 
    (a,b=>d)=(1,2); 
    (a,b,cci*>co)=1;  
    endspecify 
    assign {co,d}= (f==2'b00)?(a+b+cci):((f==2'b01)?(a-b):((f==2'b10)?{1'bz,a^b}:{1'bz,~a})); endmodule

- code: |
    module d_edge_ff_gates(q, qBar, preset, clear, clock, d); 
    inout q, qBar; 
    input clock, d, preset, clear; 
    nand #1 nl (ol, preset, o4, o2), 
    n2 (o2, clear, clock, ol), 
    n3 (o3, clock, o2, o4), 
    n4 (o4, d, o3, clear), 
    n5 (q, preset, o2, qBar), 
    n6 (qBar, q, o3, clear); 
    endmodule 

- code: |
    module counter(q, clock, preset, clear); 
    output [3:0] q; 
    input clock, preset, clear; 
    d_edge_ff_gates dffl(q[0], qBar0, preset, clear, clock, qBar0), 
    dff2(q[l], qBarl, preset, clear, qBar0, qBarl),
    INTRODUCTION TO VERILOG HDL 3 
    dff3(q[2], qBar2, preset, clear, qBarl, qBar2), 
    dff4(q[3], qBar3, preset, clear, qBar2, qBar3); 
    // initial $monitor("Internal counter signals qb0=%d qbl=%d qb2=%d qb3=%d", // qBar0, qBar1, qBar2, qBar3); 
    endmodule 

- code: |
    module counter_behav(q, clock, preset, clear); 
    output [3:0] q; 
    reg [3:0] q; 
    input clock, preset, clear; 
    always @(posedge clock) 
    begin 
    if( (preset = = 1) && (clear = = 1)) 
    q =q + l; 
    else 
    if ((preset = = 0) && (clear = = 1)) 
    q = 4'bllll; 
    else 
    q = 0; 
    end 
    endmodule 

- code: |
    module test_counter;
    reg preset, clear, clock, data;
    wire [3:0] q;
    counter c1(q, clock, preset, clear);
    counter_behav c2(q, clock, preset, clear);
    initial
    begin
    clock = 0;
    forever #50 clock = ~clock;
    end
    initial
    begin
    $monitor("time=%d preset=%d clear=%d clock=%d q[0]=%d q[1]=%d q[2]=%d q[3]=%d",
    $time, preset, clear, clock, q[0], q[1], q[2], q[3]);
    preset = 0;
    clear = 1;
    #200
    preset = 1;
    clear = 1;
    #200;
    #200
    data = 0;
    #1600
    $finish;
    end
    endmodule
  prompt: Create a testbench for the counter module

- code: |
    module factorial(n, fact);
    input [31:0] n;
    output [31:0] fact;
    reg [31:0] fact;
    reg factReady;
    integer i;
    initial begin
    factReady = 0;
    fact = 0;
    $monitor("time=%d number =%d factorial = %d", $time, n, fact);
    end
    always @n
    begin
    factReady = 0;
    fact = 1;
    for(i=1;i<=n;i=i+1)
    fact = fact * i;
    factReady = 1;
    end
    endmodule
  prompt: Implement a factorial calculator module

- code: |
    module test;
    reg [31:0] n;
    wire [31:0] fact;
    integer j;
    reg nReady;
    factorial f (n, fact);
    initial
    begin
    #1 n = 1;
    for(j=1;j<=4;j=j+1)
    begin
    nReady = 0;
    #1 n = j;
    nReady = 1;
    end
    end
    endmodule
  prompt: Create a testbench for the factorial module

- code: |
    module MainMemory(memRead, memWrite, memAddress, memData, memClock, reset);
    input memRead, memWrite, memClock, reset;
    input [`ADDR_SIZE-1:0] memAddress;
    input [`DATA_SIZE-1:0] memData;
    // memory description
    endmodule
  prompt: Define a main memory module interface

- code: |
    module Cache(procRead, procWrite, procAddress, procData, memRead, memWrite, memAddress, memData, reset, clock);
    input procRead, procWrite, reset, clock;
    input [`ADDR_SIZE-1:0] procAddress;
    output memRead, memWrite;
    output [`ADDR_SIZE-1:0] memAddress;
    inout [`DATA_SIZE-1:0] memData, procData;
    wire [`DATA_SIZE-1:0] dataIn, outData, dataOut;
    wire [`TAG_SIZE-1:0] tagOut;
    tagCache tc(procAddress, tagOut, clock, write, procRead, reset);
    validCache vc(procAddress, valid, clock, write, procRead, reset);
    dataCache dc(procAddress, dataIn, dataOut, clock, write, read);
    comparator c(tagOut, procAddress[`ADDR_SIZE-1:`ADDR_SIZE-`TAG_SIZE], match);
    cacheControl cc(procRead, procWrite, match, valid, read, write, memWrite, memRead, dataOutSel, dataInSel, clock, reset);
    dataMux dmIn(procData, memData, dataInSel, dataIn);
    dataMux dmOut(dataOut, memData, dataOutSel, outData);
    endmodule
  prompt: Implement a cache module with processor and memory interfaces

- code: |
    module System();
    wire [`ADDR_SIZE-1:0] memAddress;
    wire [`DATA_SIZE-1:0] memData;
    wire [`ADDR_SIZE-1:0] procAddress;
    wire [`DATA_SIZE-1:0] procData;
    Processor p(procRead, procWrite, procAddress, procData, procClock, reset);
    MainMemory m(memRead, memWrite, memAddress, memData, memClock, reset);
    Cache c(procRead, procWrite, procAddress, procData, memRead, memWrite, memAddress, memData, reset, clock);
    endmodule
  prompt: Create a system module integrating processor, memory, and cache

- code: |
    module wand_test(out, i1, i2);
    input i1, i2;
    output out;
    wand out;
    assign out = i1;
    assign out = i2;
    endmodule
  prompt: Implement a wired-AND test module

- code: |
    module wor_test(i1, i2, out);
    input i1, i2;
    output out;
    wor out;
    assign out = i1;
    assign out = i2;
    endmodule
  prompt: Implement a wired-OR test module

- code: |
    module tri_test(out, select, a, b, c);
    input [1:0] select, a, b, c;
    output out;
    tri out;
    assign out = a;
    assign out = b;
    assign out = c;
    endmodule
  prompt: Implement a tri-state test module with multiple drivers

- code: |
    module tri_test(out, select, a, b, c);
    input [1:0] select, a, b, c;
    output out;
    tri out;
    nand(out, a1, a2);
    nand(out, b1, b2);
    nand(out, c1, c2, c3);
    endmodule
  prompt: Implement a tri-state test module with NAND gate drivers

- code: |
    module fullAdder(cOut, sum, aIn, bIn, cIn);
    input aIn, bIn, cIn;
    output cOut, sum;
    wire aIn, bIn, cIn;
    reg cOut, sum;
    endmodule
  prompt: Define a full adder module interface

- code: |
    module mult_rtl(out, in1, in2, carry, sign);
    input [31:0] in1, in2;
    output [63:0] out;
    output carry;
    output sign;
    assign {carry, out} = in1 * in2;
    assign sign = ({carry, out} < 0) ? 1 : 0;
    endmodule
  prompt: Implement a 32-bit multiplier with carry and sign outputs

- code: |
    module fullAdder_b(cOut, sum, aIn, bIn, cIn);
    output cOut, sum;
    input aIn, bIn, cIn;
    reg [1:0] tmp;
    reg cOut, sum;
    always @(aIn or bIn or cIn)
    begin
    tmp = aIn + bIn + cIn;
    sum = tmp[0];
    cOut = tmp[1];
    end
    endmodule
  prompt: Create a behavioral model of a full adder

- code: |
    module fullAdder_r(cOut, sum, aIn, bIn, cIn);
    output cOut, sum;
    input aIn, bIn, cIn;
    wire x1, x2, x3, x4, x5, x6, x7, x8, x9;
    assign x2 = ~(aIn & bIn);
    assign cOut = ~(x2 & x8);
    assign x9 = ~(x5 ^ x6);
    assign x5 = ~(x1 | x3);
    assign x1 = ~(aIn | bIn);
    assign x8 = (x1 | x7);
    assign sum = ~x9;
    assign x3 = ~x2;
    assign x6 = ~x4;
    assign x4 = ~cIn;
    assign x7 = ~x6;
    endmodule
  prompt: Implement a full adder using RTL description

- code: |
    module check_opcode_jmp(instruction, opcode);
    parameter jmp = 0;
    input [7:0] instruction;
    output opcode;
    assign opcode = (instruction[7:6] == jmp);
    endmodule
  prompt: Create a module to check jump opcode

- code: |
    module check_inst(inst, ok);
    `define ADD=0
    `define SUB=1
    `define MUL=2
    `define DIV=3
    input [7:0] inst;
    output ok;
    assign ok = ((inst == `ADD) | (inst == `SUB) | (inst == `MUL) | (inst == `DIV));
    endmodule
  prompt: Implement an instruction validator module

- code: |
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output sum, cout;
    assign sum = i1 ^ i2 ^ cin;
    assign cout = (i1 & i2) | (cin & (i1 | i2));
    endmodule
  prompt: Implement a full adder with combinational logic

- code: |
    module par(in, parity, all_ones);
    input [7:0] in;
    output parity, all_ones;
    assign parity = ^in;
    assign all_ones = &in;
    endmodule
  prompt: Create a module to compute parity and all-ones check

- code: |
    module div4(dividend, res);
    input [7:0] dividend;
    output [5:0] res;
    assign res = dividend >> 2;
    endmodule
  prompt: Implement a divide-by-4 module using bit shifting

- code: |
    module add_or_subtract(i1, i2, op, result);
    `define ADD = 1'b1
    input [7:0] i1, i2;
    input op;
    output [7:0] result;
    assign result = (op == `ADD) ? i1 + i2 : i1 - i2;
    endmodule
  prompt: Create a module for addition or subtraction based on operation input

- code: |
    module add_or_subtract(a, b, op, s);
    parameter size = 8;
    parameter ADD = 1'b1;
    input op;
    input [size-1:0] a, b;
    output [size-1:0] s;
    assign s = (op == ADD) ? a + b : a - b;
    endmodule
  prompt: Implement a parameterized add/subtract module

- code: |
    module multiplier(in1, in2, product, carry, cc);
    parameter size = 32;
    input [size-1:0] in1, in2;
    output [size-1:0] product;
    output carry;
    output [1:0] cc;
    assign #(2*`clock_period) {carry, product} = in1 * in2;
    assign cc[0] = (product == 0) ? 1 : 0;
    assign cc[1] = (product[size-1]);
    endmodule
  prompt: Create a parameterized multiplier with condition codes

- code: |
    module multiplexor(out, control, in1, in2, in3, in4);
    parameter size = 32;
    input [1:0] control;
    input [size-1:0] in1, in2, in3, in4;
    output [size-1:0] out;
    assign out = (control == 0) ? in1 :
                ((control == 1) ? in2 :
                ((control == 2) ? in3 :
                ((control == 3) ? in4 : 'bx)));
    endmodule
  prompt: Implement a 4-to-1 multiplexer

- code: |
    module bus_control;
    parameter size = 32;
    tri [size-1:0] bus;
    wire [size-1:0] data;
    wire dcontrol;
    assign bus = dcontrol ? data : 128'bz;
    endmodule
  prompt: Create a bus control module with tri-state output

- code: |
    module xdetect(in, xdet);
    parameter size = 32;
    input [size-1:0] in;
    output xdet;
    assign xdet = ((in == in) ? 0 : 1);
    endmodule
  prompt: Implement a module to detect unknown (x) values

- code: |
    module barrel_shifter(func, mode, out, in);
    parameter size = 32;
    output [size-1:0] out;
    input [size-1:0] in;
    input func, mode;
    `define SHIFT 1
    `define ROTATE 0
    `define LEFT 1
    `define RIGHT 0
    `define shift_expr (mode ? (in << 1) : (in >> 1))
    `define rotate_expr (mode ? ({in[size-2:0], in[size-1]}) : ({in[0], in[size-1:1]}))
    assign out = func ? `shift_expr : `rotate_expr;
    endmodule
  prompt: Create a barrel shifter with shift and rotate operations

- code: |
    module fullAdder_s(cOut, sum, aIn, bIn, cIn);
    output cOut, sum;
    input aIn, bIn, cIn;
    wire x2;
    nand (x2, aIn, bIn),
         (cOut, x2, x8);
    xnor (x9, x5, x6);
    nor (x5, x1, x3),
        (x1, aIn, bIn);
    or (x8, x1, x7);
    not (sum, x9),
        (x3, x2),
        (x6, x4),
        (x4, cIn),
        (x7, x6);
    endmodule
  prompt: Implement a structural full adder using gates

- code: |
    module top(i1, i2, i3, i4, o1, o2);
    input i1, i2, i3, i4;
    output o1, o2;
    next_level l0(i1, i2, i3),
               l1(.out(o1), .in(i3), .bus0(i2));
    endmodule
  prompt: Create a top-level module with module instantiations

- code: |
    module multiplexor(control, in1, in2, in3, in4, out);
    input [1:0] control;
    input in1, in2, in3, in4;
    output out;
    assign out = (control == 0) ? in1 :
                ((control == 1) ? in2 :
                ((control == 2) ? in3 :
                ((control == 3) ? in4 : 'bx)));
    endmodule
  prompt: Implement a scalar 4-to-1 multiplexer

- code: |
    module andor;
    reg i1, i2, i3, i4;
    and #2 a1(o1, i1, i2), a2(o2, i3, i4);
    or r1(o3, o1, o2);
    initial
    begin : beh_block
    $monitor("Sim Time=%d i1=%d i2=%d i3=%d i4=%d o1=%d o2=%d o3=%d",
             $time, i1, i2, i3, i4, o1, o2, o3);
    #25 i1 = 1;
    #25 i2 = 0;
    #25 i3 = 1;
    #25 i4 = 1;
    #100 $finish;
    end
    endmodule
  prompt: Create a module with AND and OR gates and testbench

- code: |
    module m;
    wire out;
    reg in1, in2;
    assign #5 out = in1 | in2;
    initial
    begin
    $monitor("Time = %d out = %d in1=%d in2=%d", $time, out, in1, in2);
    $dumpfile("ex4_2.dmp");
    $dumpvars;
    #1
    in1 = 1;
    #2
    in2 = 1;
    #10
    $finish;
    end
    endmodule
  prompt: Implement a simple OR gate with testbench

- code: |
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol ? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    dcontrol = 0;
    #10 data = 15;
    #10 x = 0;
    #10 dcontrol = y;
    #10;
    end
    endmodule
  prompt: Create a mixed-style simulation module with tri-state bus

- code: |
    module clock(clock);
    output clock;
    initial
    clock = 0;
    always
    #100 clock = ~clock;
    endmodule
  prompt: Implement a clock generator module

- code: |
    module evaluates3(out);
    output out;
    reg a, b, c;
    initial
    begin
    a = 0;
    b = 1;
    c = 0;
    end
    always c = #5 ~c;
    always @(posedge c)
    begin: exch_block
    a <= b;
    b <= a;
    end
    initial
    begin
    $monitor("$time=%d a=%d b=%d c=%d", $time, a, b, c);
    #30 $finish;
    end
    endmodule
  prompt: Demonstrate non-blocking assignments in a module

- code: |
    module multiple;
    reg r1;
    reg [2:0] i;
    initial
    begin
    $monitor("time=%d, i=%d r1 = %d", $time, i, r1);
    r1 = 0;
    for (i = 0; i <= 5; i = i + 1)
    r1 = #(i*10) i[0];
    end
    endmodule
  prompt: Show multiple blocking assignments with delays

- code: |
    module m(a, b, c, d, select, mux);
    input a, b, c, d;
    input [1:0] select;
    output mux;
    reg mux;
    always@({a, b, c, d, select})
    case (select)
    2'b00: mux = a;
    2'b01: mux = b;
    2'b10: mux = c;
    2'b11: mux = d;
    default: mux = 'bx;
    endcase
    endmodule
  prompt: Implement a 4-to-1 multiplexer using case statement

- code: |
    module m;
    reg sig;
    always @(sig)
    case (sig)
    1'bx : $display("signal is unknown");
    1'bz : $display("signal is floating");
    default : $display("signal is %b", sig);
    endcase
    initial
    begin
    $monitor("time=%d sig=%b", $time, sig);
    #10 sig = 0;
    #10 sig = 1;
    #10 sig = 'bz;
    #10 sig = 'bx;
    end
    endmodule
  prompt: Create a module to detect signal states

- code: |
    module m;
    reg sig;
    always @(sig)
    casez (sig)
    1'bx : $display("signal is unknown");
    1'bz : $display("signal is floating");
    default : $display("signal is %b", sig);
    endcase
    initial
    begin
    $monitor("time=%d sig=%b", $time, sig);
    #10 sig = 0;
    #10 sig = 1;
    #10 sig = 'bz;
    #10 sig = 'bx;
    end
    endmodule
  prompt: Implement a module with casez for signal state detection

- code: |
    module multiplexor(a, b, c, d, select, e);
    input a, b, c, d;
    input [1:0] select;
    output e;
    assign e = mux(a, b, c, d, select);
    endmodule
  prompt: Create a multiplexer module using a function

- code: |
    module waveShReg;
    wire shiftout;
    reg shiftin;
    reg phase1, phase2;
    parameter d = 100;
    shreg cct(shiftout, shiftin, phase1, phase2);
    initial
    begin : main
    shiftin = 0;
    phase1 = 0;
    phase2 = 0;
    setmon;
    repeat(2)
    clockcct;
    end
    task setmon;
    begin
    $display(" time clks in out wa1-3 wb1-2");
    $monitor($time,,, phase1, phase2,,, shiftin,,, shiftout,,, cct.wa1, cct.wa2, cct.wa3,,, cct.wb1, cct.wb2);
    end
    endtask
    endmodule
  prompt: Implement a shift register testbench with dual-phase clock

- code: |
    module e(out);
    output out;
    reg a, b, c;
    reg d, e, f;
    initial
    begin
    $monitor("time=%d a=%d b=%d c=%d e=%d\n", $time, a, b, c, d, e);
    a = 0; b = 1; c = 0; d = 0; e = 1;
    #30 $finish;
    end
    always c = #5 ~c;
    always @(posedge c)
    begin
    a = b;
    b = a;
    d <= e;
    e <= d;
    end
    endmodule
  prompt: Demonstrate blocking and non-blocking assignments

- code: |
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    #10;
    end
    a = 'bx;
    #10
    b = 'bx;
    end
    endmodule
  prompt: Create a testbench for a carry module

- code: |
    module test_latch;
    reg a, b, c;
    integer i;
    wire q;
    latch l1(q, a, b);
    initial
    begin
    $monitor("time=%d a=%b b=%b---------q=%b", $time, a, b, q);
    for (i = 0; i < 5; i = i + 1)
    begin
    {a, b} = i;
    #10;
    end
    a = 'bx;
    #10
    b = 'bx;
    end
    endmodule
  prompt: Create a testbench for a latch module

- code: |
    module sr_edge_ff(clear, s, r, clock, q, qbar);
    inout q, qbar;
    input clear, s, r, clock;
    sr_edge_prim p1(q, clear, s, r, clock);
    not (qbar, q);
    endmodule
  prompt: Implement an SR edge-triggered flip-flop

- code: |
    module m555(clock);
    output clock;
    reg clock;
    initial
    #5 clock = 1;
    always
    #50 clock = ~clock;
    endmodule
  prompt: Create a clock generator with initial offset

- code: |
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    #50;
    j = 1;
    k = 0;
    #50;
    end
    m555 timer(clock);
    endmodule
  prompt: Create a testbench for a JK edge-triggered flip-flop

- code: |
    primitive latch(q, clock, data);
    output q;
    reg q;
    input clock, data;
    wire clock, data;
    table
    // clock data states output
    0 1 : ? : 1;
    0 0 : ? : 0;
    1 ? : ? : -;
    endtable
    endprimitive
  prompt: Define a latch as a user-defined primitive

- code: |
    primitive mux_udp(out, in1, in2, in3, in4, flag);
    output out;
    input in1, in2, in3, in4;
    input [1:0] flag;
    table
    // in1 in2 in3 in4 flag out
    ? ? ? ? 00 : 0;
    ? ? ? ? 01 : 0;
    ? ? ? ? 10 : 0;
    ? ? ? ? 11 : 0;
    1 ? ? ? 00 : 1;
    ? 1 ? ? 01 : 1;
    ? ? 1 ? 10 : 1;
    ? ? ? 1 11 : 1;
    0 ? ? ? 00 : 0;
    ? 0 ? ? 01 : 0;
    ? ? 0 ? 10 : 0;
    ? ? ? 0 11 : 0;
    x ? ? ? 00 : x;
    ? x ? ? 01 : x;
    ? ? x ? 10 : x;
    ? ? ? x 11 : x;
    endtable
    endprimitive
  prompt: Convert a behavioral multiplexer to a user-defined primitive with reduced pessimism for x values

- code: |
    module test_sredge;
    reg s, r, clear;
    wire q, qbar, clock;
    sr_edge_ff s1(clear, s, r, clock, q, qbar);
    m555 m1(clock);
    initial
    begin
    #10
    clear = 1;
    #200
    clear = 0;
    #200
    s = 1; r = 0;
    #200
    s = 0; r = 1;
    #200
    s = 0; r = 0;
    #200
    $finish;
    end
    always
    #200
    $display("time=%d clear=%d s=%d r=%d clock=%d q=%d qbar=%d",
             $time, clear, s, r, clock, q, qbar);
    endmodule
  prompt: Create a testbench for an SR edge-triggered flip-flop

- code: |
    module system();
    micro mbehav();
    mem mrtl();
    graph masic();
    parity_check pswitch();
    endmodule
  prompt: Define a system module with multiple component instantiations

- code: |
    module adder(in1, in2, cin, out, cout, zero_flag);
    output out, zero_flag, cout;
    reg zero_flag;
    input in1, in2, cin;
    always @out
    if (out == 0)
    zero_flag = 1;
    else
    zero_flag = 0;
    nand (x2, in1, in2),
         (cout, x2, x8);
    xnor (x9, x5, x6);
    nor (x5, x1, x3),
        (x1, in1, in2);
    or (x8, x1, x7);
    not (out, x9),
        (x3, x2),
        (x6, x4),
        (x4, cin),
        (x7, x6);
    endmodule
  prompt: Implement a structural adder with zero flag

- code: |
    module disp;
    reg [0:31] rval, rvall, i;
    initial
    begin
    rval = 101;
    rvall = 2020;
    $display("rval=%h hex =%d decimal", rval, rval);
    $display("rval=%0h hex =%0d decimal", rval, rval);
    $displayh("rval = %d", rval);
    $display("table of hex values");
    $display("rval rvall");
    $displayh(rval[0:7], rvall[0:7]);
    $displayh(rval[8:15], rvall[8:15]);
    $displayh(rval[16:23], rvall[16:23]);
    $displayh(rval[24:31], rvall[24:31]);
    $display("example of displayb follows");
    $displayb(rval);
    $display("example of displayo follows");
    $displayo(rval);
    $display("Simulation time is %t", $time);
    $display("%d", 1'bx);
    $display("%h", 14'bx01010);
    $display("%h %o", 12'b001xxx101x01, 12'b001xxx101x01);
    $display("Current scope is %m");
    end
    endmodule
  prompt: Demonstrate various display formats in Verilog

- code: |
    module test_adder;
    reg [1:0] in1, in2;
    wire [2:0] out;
    adder a(out, in1, in2);
    initial
    begin
    $monitor("time=%d out=%d in1=%d in2=%d", $time, out, in1, in2);
    in1 = 0;
    in2 = 0;
    repeat (4)
    begin
    repeat (4)
    #5
    in2 = in2 + 1;
    in1 = in1 + 1;
    end
    end
    initial
    begin
    #30 $monitoroff;
    #15 $monitoron;
    #30 $finish;
    end
    endmodule
  prompt: Create a testbench for a 2-bit adder

- code: |
    module adder(o, i1, i2);
    output [2:0] o;
    input [1:0] i1, i2;
    assign o = i1 + i2;
    endmodule
  prompt: Implement a simple 2-bit adder

- code: |
    module validCache(address, validOut, clock, write, read, reset);
    input [`ADDR_SIZE-1:0] address;
    input clock, write, read, reset;
    output validOut;
    reg validOut;
    reg [`CACHE_SIZE-1:0] validCacheMem;
    always @reset
    if (reset)
    validCacheMem = `CACHE_SIZE'b0;
    always @write
    @(negedge clock)
    if (!reset)
    validCacheMem[address[`ADDR_SIZE-`TAG_SIZE-1:0]] = 1;
    always @read
    @(posedge clock)
    validOut = validCacheMem[address[`ADDR_SIZE-`TAG_SIZE-1:0]];
    endmodule
  prompt: Implement a valid cache module

- code: |
    module comparator(in1, in2, match);
    input [`TAG_SIZE-1:0] in1, in2;
    output match;
    assign match = (in1 == in2);
    endmodule
  prompt: Create a comparator module for cache tags

- code: |
    module dataMux(data0, data1, dataSel, outData);
    input [`DATA_SIZE-1:0] data0, data1;
    input dataSel;
    output [`DATA_SIZE-1:0] outData;
    assign outData = dataSel ? data0 : data1;
    endmodule
  prompt: Implement a data multiplexer for cache

- code: |
    module m(out, in1, in2);
    output [4:0] out;
    input [3:0] in1, in2;
    assign out = in1 + in2;
    endmodule
  prompt: Create a 4-bit adder module

- code: |
    module mux42(out, data, sel);
    input [3:0] data;
    input [1:0] sel;
    output out;
    reg out;
    always @(data or sel)
    case (sel)
    `DATA0 : out = data[0];
    `DATA1 : out = data[1];
    `DATA2 : out = data[2];
    `DATA3 : out = data[3];
    endcase
    endmodule
  prompt: Implement a 4-to-1 multiplexer with case statement

- code: |
    module TLC(R, G, Y, clock, reset);
    output R, Y, G;
    input clock, reset;
    reg next_state;
    reg R, Y, G;
    always @(posedge clock)
    begin
    case (next_state)
    `GREEN:
    begin
    next_state = `YELLOW;
    G = 1;
    R = 0;
    end
    `YELLOW:
    begin
    next_state = `RED;
    Y = 1;
    G = 0;
    end
    `RED:
    begin
    next_state = `GREEN;
    R = 1;
    Y = 0;
    end
    endcase
    end
    always @(reset)
    next_state = `RED;
    endmodule
  prompt: Implement a traffic light controller

- code: |
    module f_add(add, i1, i2);
    input [3:0] i1, i2;
    output [4:0] add;
    function [4:0] FourBitAdd;
    input [3:0] a, b;
    reg c;
    integer i;
    begin
    c = 0;
    for (i = 0; i <= 3; i = i + 1) begin
    FourBitAdd[i] = a[i] ^ b[i] ^ c;
    c = a[i] & b[i] | a[i] & c | b[i] & c;
    end
    FourBitAdd[4] = c;
    end
    endfunction
    assign add = FourBitAdd(i1, i2);
    endmodule
  prompt: Implement a 4-bit adder using a function

- code: |
    module latch(out, clock, data);
    output out;
    input clock, data;
    always @(clock or data)
    begin
    if (clock)
    out = data;
    end
    endmodule
  prompt: Create a simple latch module

- code: |
    module bcd_decode(b, d);
    input [3:0] b;
    output [9:0] d;
    reg [9:0] d;
    always @(b)
    begin
    case (b)
    4'h0: d = 10'b1;
    4'h1: d = 10'b10;
    4'h2: d = 10'b100;
    4'h3: d = 10'b1000;
    4'h4: d = 10'b10000;
    4'h5: d = 10'b100000;
    4'h6: d = 10'b1000000;
    4'h7: d = 10'b10000000;
    4'h8: d = 10'b100000000;
    4'h9: d = 10'b1000000000;
    endcase
    end
    endmodule
  prompt: Implement a BCD to one-hot decoder

- code: |
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    else
    out = data;
    end
    endmodule
  prompt: Create a D flip-flop with asynchronous reset

- code: |
    module sync_set_reset(clk, reset, set, d1, d2, y, t);
    input clk, reset, set, d1, d2;
    output y, t;
    reg y, t;
    always @(posedge clk)
    begin: synchronous_reset
    if (reset)
    y = 1'b0;
    else
    y = d1;
    end
    always @(posedge clk)
    begin: synchronous_set
    if (set)
    t = 1'b1;
    else
    t = d2;
    end
    endmodule
  prompt: Implement a module with synchronous set/reset

- code: |
    module one_hot_example(reset, set, out, data);
    input reset, set;
    output out;
    reg y, t;
    always @(reset or set)
    begin: direct_set_reset
    if (reset)
    y = 1'b0;
    else if (set)
    y = 1'b1;
    end
    endmodule
  prompt: Create a module with one-hot encoded asynchronous set/reset

- code: |
    module one_cold(reset, set, out, in);
    input reset, set, in;
    output out;
    reg out;
    always @(reset or set)
    begin: direct_set_reset
    if (~reset)
    out = 1'b0;
    else if (~set)
    out = 1'b1;
    end
    endmodule
  prompt: Implement a module with one-cold encoded asynchronous set/reset

- code: |
    module bus_latch(reset, set, control, out, in);
    input reset, set, control;
    input [0:1] in;
    output [0:1] out;
    reg out;
    always @(reset or set or control or in)
    begin
    if (reset)
    out = 0;
    else if (set)
    out = 2;
    else if (control)
    out = in;
    end
    endmodule
  prompt: Create a bus latch module

- code: |
    module mux8tol(DIN, SEL, DOUT);
    input [7:0] DIN;
    input [2:0] SEL;
    output DOUT;
    reg DOUT;
    always @(SEL or DIN)
    begin: mux_blk
    case (SEL)
    3'b000: DOUT <= DIN[0];
    3'b001: DOUT <= DIN[1];
    3'b010: DOUT <= DIN[2];
    3'b011: DOUT <= DIN[3];
    3'b100: DOUT <= DIN[4];
    3'b101: DOUT <= DIN[5];
    3'b110: DOUT <= DIN[6];
    3'b111: DOUT <= DIN[7];
    endcase
    end
    endmodule
  prompt: Implement an 8-to-1 multiplexer

- code: |
    module threestate_noreg_ff(clock, condition, enable, in, out);
    input in, enable, condition, clock;
    output out;
    reg out;
    reg temp;
    always @(posedge clock)
    begin
    if (condition)
    temp = in;
    end
    always @(enable or temp)
    begin
    if (enable)
    out = temp;
    else
    out = 1'bz;
    end
    endmodule
  prompt: Create a three-state buffer with registered enable

- code: |
    module dff_logic(q, data, clock);
    input clock, data;
    output q;
    always @(posedge clock)
    q = data;
    endmodule
  prompt: Implement a basic D flip-flop

- code: |
    module m();
    reg notif_reg;
    wire data, clock;
    specify
    $setup(posedge data, posedge clock, 10, notif_reg);
    endspecify
    always @notif_reg
    $display("Setup violation in %m at time %t", $time);
    endmodule
  prompt: Demonstrate setup time checking in a module

- code: |
    module ALU(o1, i1, i2, opcode);
    input [7:0] i1, i2;
    input [2:1] opcode;
    output [7:0] o1;
    specify
    if (opcode == 2'b00) (i1, i2 *> o1) = (25.0, 25.0);
    if (opcode == 2'b01) (i1 => o1) = (5.6, 8.0);
    if (opcode == 2'b10) (i2 => o1) = (5.6, 8.0);
    (opcode => o1) = (6.1, 6.5);
    endspecify
    endmodule
  prompt: Create an ALU module with state-dependent path delays

- code: |
    module dff_logic(q, data, clk, reset);
    output q;
    reg q;
    input clk, reset, data;
    always @(posedge clk)
    q = data;
    always @reset
    if (reset == 1)
    deassign q;
    else
    assign q = 0;
    endmodule
  prompt: Implement a D flip-flop with reset control

- code: |
    module m2;
    reg [7:0] in, out;
    initial
    begin
    in = 16;
    $monitor($time,, in,, out);
    #100
    $log2(in, out, in);
    end
    endmodule
  prompt: Create a module using a custom $log2 task

- code: |
    module shreg(out, in, phase1, phase2);
    output out;
    input in, phase1, phase2;
    tri wb1, wb2, out;
    pullup (wb1), (wb2), (out);
    trireg (medium) wa1, wa2, wa3;
    supply0 gnd;
    nmos #3 a1(wa1, in, phase1), b1(wb1, gnd, wa1),
             a2(wa2, wb1, phase2), b2(wb2, gnd, wa2),
             a3(wa3, wb2, phase1), gout(out, gnd, wa3);
    endmodule
  prompt: Implement a shift register with NMOS transistors

- code: |
    module NewTestShReg;
    wire shiftout;
    reg shiftin;
    reg phase1, phase2;
    parameter d = 100;
    shreg cct(shiftout, shiftin, phase1, phase2);
    initial
    begin : main
    shiftin = 0;
    phase1 = 0;
    phase2 = 0;
    $monitor("time=%d wa1=%d wb1=%d wa2=%d wb2=%d wa3=%d out=%d\n",
             $time, cct.wa1, cct.wb1, cct.wa2, cct.wb2, cct.wa3, cct.out);
    repeat(2)
    begin
    #d phase1 = 0;
    #d phase1 = 1;
    #d phase1 = 0;
    #d phase2 = 0;
    #d phase2 = 1;
    #d phase2 = 0;
    end
    end
    endmodule
  prompt: Create a testbench for a shift register with dual-phase clock

- code: |
    module transformer(in1, in2, out1, out2);
    analog
    begin
    V(node, outm) <+ leakL * dot(I(node, out1));
    V(out2, node) <+ ratio * V(in2, in1);
    end
    endmodule
  prompt: Implement an analog transformer module

- code: |
    module mixed_signal;
    electrical a1;
    wire w2, w3, w4;
    manalog ma1(a1, w2, w3);
    mdigital md1(a1, w4);
    endmodule
  prompt: Create a mixed-signal module with analog and digital components

- code: |
    module manalog(a1, a2, a3);
    inout a1, a2, a3;
    electrical a1, a2, a3;
    endmodule
  prompt: Define an analog module interface

- code: |
    for (i = 0; i <= 4; i = i + 1)
        $display("Number: %d", i);
  prompt: Write a loop that prints numbers 0 to 4

- code: |
    module example1(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    wire g, k, h;
    not (k, x2);
    and (g, x1, x2);
    and (h, k, x3);
    or (f, g, h);
    endmodule
  prompt: Implement a combinational circuit with inputs x1, x2, x3 and output f = x1x2 + x2'x3

- code: |
    module example2(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    wire z1, z2, z3, z4;
    and (z1, x1, x3);
    and (z2, x2, x4);
    or (g, z1, z2);
    or (z3, x1, x3);
    or (z4, x2, x4);
    and (h, z3, z4);
    or (f, g, h);
    endmodule
  prompt: Implement a combinational circuit with inputs x1, x2, x3, x4 and outputs f, g, h

- code: |
    module example3(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    assign f = (x1 & x2) | (~x2 & x3);
    endmodule
  prompt: Implement a combinational circuit with inputs x1, x2, x3 and output f = x1x2 + x2'x3 using assign statement

- code: |
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    assign f = g | h;
    endmodule
  prompt: Implement a combinational circuit with inputs x1, x2, x3, x4 and outputs f, g, h using assign statements

- code: |
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else
            f = x3;
    endmodule
  prompt: Implement a behavioral model with inputs x1, x2, x3 and output f that selects x1 if x2=1 else x3

- code: |
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
  prompt: Implement a combinational circuit with specific minterms for inputs x1, x2, x3 and output f

- code: |
    module example4_21(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3) | (x1 & x2 & x3);
    endmodule
  prompt: Implement a combinational circuit with specific minterms for inputs x1, x2, x3 and output f

- code: |
    module example4_22(x1, x2, x3, x4, f);
    input x1, x2, x3, x4;
    output f;
    assign f = (~x1 & ~x2 & x3 & ~x4) | (~x1 & ~x2 & x3 & x4) | (x1 & ~x2 & ~x3 & x4) | (x1 & ~x2 & x3 & ~x4) | (x1 & x2 & ~x3 & x4) | (x1 & x2 & x3 & ~x4);
    endmodule
  prompt: Implement a combinational circuit with specific minterms for inputs x1, x2, x3, x4 and output f

- code: |
    module example4_23(x1, x2, x3, x4, x5, x6, x7, f);
    input x1, x2, x3, x4, x5, x6, x7;
    output f;
    assign f = (x1 & x3 & ~x6) | (x1 & x4 & x5 & ~x6) | (x2 & x3 & x7) | (x2 & x4 & x5 & x7);
    endmodule
  prompt: Implement a combinational circuit with specific minterms for inputs x1, x2, x3, x4, x5, x6, x7 and output f

- code: |
    module fulladd(Cin, x, y, s, Cout);
    input Cin, x, y;
    output s, Cout;
    wire z1, z2, z3;
    xor (s, x, y, Cin);
    and (z1, x, y);
    and (z2, x, Cin);
    and (z3, y, Cin);
    or (Cout, z1, z2, z3);
    endmodule
  prompt: Implement a full adder using gate-level primitives

- code: |
    module fulladd(Cin, x, y, s, Cout);
    input Cin, x, y;
    output s, Cout;
    wire z1, z2, z3;
    xor (s, x, y, Cin);
    and (z1, x, y), (z2, x, Cin), (z3, y, Cin);
    or (Cout, z1, z2, z3);
    endmodule
  prompt: Implement a full adder with combined AND gate statements

- code: |
    module fulladd(Cin, x, y, s, Cout);
    input Cin, x, y;
    output s, Cout;
    assign s = x ^ y ^ Cin;
    assign Cout = (x & y) | (x & Cin) | (y & Cin);
    endmodule
  prompt: Implement a full adder using dataflow modeling

- code: |
    module fulladd(Cin, x, y, s, Cout);
    input Cin, x, y;
    output s, Cout;
    assign s = x ^ y ^ Cin, Cout = (x & y) | (x & Cin) | (y & Cin);
    endmodule
  prompt: Implement a full adder with combined assign statements

- code: |
    module adder4(carryin, x3, x2, x1, x0, y3, y2, y1, y0, s3, s2, s1, s0, carryout);
    input carryin, x3, x2, x1, x0, y3, y2, y1, y0;
    output s3, s2, s1, s0, carryout;
    wire c1, c2, c3;
    fulladd stage0 (carryin, x0, y0, s0, c1);
    fulladd stage1 (c1, x1, y1, s1, c2);
    fulladd stage2 (c2, x2, y2, s2, c3);
    fulladd stage3 (c3, x3, y3, s3, carryout);
    endmodule
  prompt: Implement a 4-bit ripple-carry adder using full adder instantiations

- code: |
    module adder4(carryin, X, Y, S, carryout);
    input carryin;
    input [3:0] X, Y;
    output [3:0] S;
    output carryout;
    wire [3:1] C;
    fulladd stage0 (carryin, X[0], Y[0], S[0], C[1]);
    fulladd stage1 (C[1], X[1], Y[1], S[1], C[2]);
    fulladd stage2 (C[2], X[2], Y[2], S[2], C[3]);
    fulladd stage3 (C[3], X[3], Y[3], S[3], carryout);
    endmodule
  prompt: Implement a 4-bit ripple-carry adder with vector inputs

- code: |
    module addern(carryin, X, Y, S, carryout);
    parameter n = 32;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    integer k;
    always @(X or Y or carryin)
    begin
        C[0] = carryin;
        for (k = 0; k < n; k = k + 1)
        begin
            S[k] = X[k] ^ Y[k] ^ C[k];
            C[k+1] = (X[k] & Y[k]) | (X[k] & C[k]) | (Y[k] & C[k]);
        end
        carryout = C[n];
    end
    endmodule
  prompt: Implement a parameterized n-bit ripple-carry adder

- code: |
    module addern(carryin, X, Y, S);
    parameter n = 32;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    reg [n-1:0] S;
    always @(X or Y or carryin)
        S = X + Y + carryin;
    endmodule
  prompt: Implement a parameterized n-bit adder using arithmetic operator

- code: |
    module addern(carryin, X, Y, S, carryout, overflow);
    parameter n = 32;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout, overflow;
    reg [n-1:0] S;
    reg carryout, overflow;
    always @(X or Y or carryin)
    begin
        S = X + Y + carryin;
        carryout = (X[n-1] & Y[n-1]) | (X[n-1] & ~S[n-1]) | (Y[n-1] & ~S[n-1]);
        overflow = carryout ^ X[n-1] ^ Y[n-1] ^ S[n-1];
    end
    endmodule
  prompt: Implement a parameterized n-bit adder with carryout and overflow detection

- code: |
    module addern(carryin, X, Y, S, carryout, overflow);
    parameter n = 32;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout, overflow;
    reg [n-1:0] S;
    reg carryout, overflow;
    reg [n:0] Sum;
    always @(X or Y or carryin)
    begin
        Sum = {1'b0, X} + {1'b0, Y} + carryin;
        S = Sum[n-1:0];
        carryout = Sum[n];
        overflow = carryout ^ X[n-1] ^ Y[n-1] ^ S[n-1];
    end
    endmodule
  prompt: Implement a parameterized n-bit adder with extended precision for overflow

- code: |
    module addern(carryin, X, Y, S, carryout, overflow);
    parameter n = 32;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout, overflow;
    reg [n-1:0] S;
    reg carryout, overflow;
    always @(X or Y or carryin)
    begin
        {carryout, S} = X + Y + carryin;
        overflow = carryout ^ X[n-1] ^ Y[n-1] ^ S[n-1];
    end
    endmodule
  prompt: Implement a parameterized n-bit adder with concatenated output

- code: |
    module fulladd(Cin, x, y, s, Cout);
    input Cin, x, y;
    output s, Cout;
    reg s, Cout;
    always @(x or y or Cin)
        {Cout, s} = x + y + Cin;
    endmodule
  prompt: Implement a full adder using behavioral modeling

- code: |
    module bcdadd(Cin, X, Y, S, Cout);
    input Cin;
    input [3:0] X, Y;
    output [3:0] S;
    output Cout;
    reg [3:0] S;
    reg Cout;
    reg [4:0] Z;
    always @(X or Y or Cin)
    begin
        Z = X + Y + Cin;
        if (Z < 10)
            {Cout, S} = Z;
        else
            {Cout, S} = Z + 6;
    end
    endmodule
  prompt: Implement a BCD adder with correction

- code: |
    module problem5_17(IN, OUT);
    input [3:0] IN;
    output [3:0] OUT;
    reg [3:0] OUT;
    always @(IN)
        case (IN)
            4'b0101: OUT = 4'b0001;
            4'b0110: OUT = 4'b0010;
            4'b0111: OUT = 4'b0011;
            4'b1001: OUT = 4'b0010;
            4'b1010: OUT = 4'b0100;
            4'b1011: OUT = 4'b0110;
            4'b1101: OUT = 4'b0011;
            4'b1110: OUT = 4'b0110;
            4'b1111: OUT = 4'b1001;
            default: OUT = 4'b0000;
        endcase
    endmodule
  prompt: Implement a specific input-output mapping for a 4-bit input

- code: |
    module mux2to1(w0, w1, s, f);
    input w0, w1, s;
    output f;
    assign f = s ? w1 : w0;
    endmodule
  prompt: Implement a 2-to-1 multiplexer using conditional operator

- code: |
    module mux2to1(w0, w1, s, f);
    input w0, w1, s;
    output f;
    reg f;
    always @(w0 or w1 or s)
        f = s ? w1 : w0;
    endmodule
  prompt: Implement a 2-to-1 multiplexer using behavioral modeling

- code: |
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    assign f = S[1] ? (S[0] ? w3 : w2) : (S[0] ? w1 : w0);
    endmodule
  prompt: Implement a 4-to-1 multiplexer using nested conditional operators

- code: |
    module mux2to1(w0, w1, s, f);
    input w0, w1, s;
    output f;
    reg f;
    always @(w0 or w1 or s)
        if (s == 0)
            f = w0;
        else
            f = w1;
    endmodule
  prompt: Implement a 2-to-1 multiplexer using if-else statement

- code: |
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0]àª¸

- code: |
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        if (S == 2'b00)
            f = w0;
        else if (S == 2'b01)
            f = w1;
        else if (S == 2'b10)
            f = w2;
        else if (S == 2'b11)
            f = w3;
    endmodule
  prompt: Implement a 4-to-1 multiplexer using behavioral modeling with if-else statements

- code: |
    module mux4to1(W, S, f);
    input [0:3] W;
    input [1:0] S;
    output f;
    reg f;
    always @(W or S)
        if (S == 0)
            f = W[0];
        else if (S == 1)
            f = W[1];
        else if (S == 2)
            f = W[2];
        else if (S == 3)
            f = W[3];
    endmodule
  prompt: Implement a 4-to-1 multiplexer with vector input using behavioral modeling

- code: |
    module mux16to1(W, S16, f);
    input [0:15] W;
    input [3:0] S16;
    output f;
    wire [0:3] M;
    mux4to1 Mux1 (W[0:3], S16[1:0], M[0]);
    mux4to1 Mux2 (W[4:7], S16[1:0], M[1]);
    mux4to1 Mux3 (W[8:11], S16[1:0], M[2]);
    mux4to1 Mux4 (W[12:15], S16[1:0], M[3]);
    mux4to1 Mux5 (M[0:3], S16[3:2], f);
    endmodule
  prompt: Implement a 16-to-1 multiplexer using 4-to-1 multiplexer instantiations

- code: |
    module mux4to1(W, S, f);
    input [0:3] W;
    input [1:0] S;
    output f;
    reg f;
    always @(W or S)
        case (S)
            0: f = W[0];
            1: f = W[1];
            2: f = W[2];
            3: f = W[3];
        endcase
    endmodule
  prompt: Implement a 4-to-1 multiplexer using case statement

- code: |
    module dec2to4(W, Y, En);
    input [1:0] W;
    input En;
    output [0:3] Y;
    reg [0:3] Y;
    always @(W or En)
        case ({En, W})
            3'b100: Y = 4'b1000;
            3'b101: Y = 4'b0100;
            3'b110: Y = 4'b0010;
            3'b111: Y = 4'b0001;
            default: Y = 4'b0000;
        endcase
    endmodule
  prompt: Implement a 2-to-4 decoder with enable input using case statement

- code: |
    module dec2to4(W, Y, En);
    input [1:0] W;
    input En  output [0:3] Y;
    reg [0:3] Y;
    always @(W or En)
    begin
        if (En == 0)
            Y = 4'b0000;
        else
            case (W)
                0: Y = 4'b1000;
                1: Y = 4'b0100;
                2: Y = 4'b0010;
                3: Y = 4'b0001;
            endcase
    end
    endmodule
  prompt: Implement a 2-to-4 decoder with enable input using if-else and case statements

- code: |
    module dec4to16(W, Y, En);
    input [3:0] W;
    input En;
    output [0:15] Y;
    wire [0:3] M;
    dec2to4 Dec1 (W[3:2], M[0:3], En);
    dec2to4 Dec2 (W[1:0], Y[0:3], M[0]);
    dec2to4 Dec3 (W[1:0], Y[4:7], M[1]);
    dec2to4 Dec4 (W[1:0], Y[8:11], M[2]);
    dec2to4 Dec5 (W[1:0], Y[12:15], M[3]);
    endmodule
  prompt: Implement a 4-to-16 decoder using 2-to-4 decoder instantiations

- code: |
    module seg7(bcd, leds);
    input [3:0] bcd;
    output [1:7] leds;
    reg [1:7] leds;
    always @(bcd)
        case (bcd) // abcdefg
            0: leds = 7'b1111110;
            1: leds = 7'b0110000;
            2: leds = 7'b1101101;
            3: leds = 7'b1111001;
            4: leds = 7'b0110011;
            5: leds = 7'b1011011;
            6: leds = 7'b1011111;
            7: leds = 7'b1110000;
            8: leds = 7'b1111111;
            9: leds = 7'b1111011;
            default: leds = 7'bx;
        endcase
    endmodule
  prompt: Implement a 7-segment display decoder for BCD input

- code: |
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    reg [3:0] F;
    always @(s or A or B)
        case (s)
            0: F = 4'b0000;
            1: F = B - A;
            2: F = A - B;
            3: F = A + B;
            4: F = A ^ B;
            5: F = A | B;
            6: F = A & B;
            7: F = 4'b1111;
        endcase
    endmodule
  prompt: Implement an ALU with various operations based on select input

- code: |
    module priority(W, Y, z);
    input [3:0] W;
    output [1:0] Y;
    output z;
    reg [1:0] Y;
    reg z;
    always @(W)
    begin
        z = 1;
        casex (W)
            4'b1xxx: Y = 3;
            4'b01xx: Y = 2;
            4'b001x: Y = 1;
            4'b0001: Y = 0;
            default: begin
                z = 0;
                Y = 2'bx;
            end
        endcase
    end
    endmodule
  prompt: Implement a priority encoder with valid output

- code: |
    module dec2to4(W, Y, En);
    input [1:0] W;
    input En;
    output [0:3] Y;
    reg [0:3] Y;
    integer k;
    always @(W or En)
        for (k = 0; k <= 3; k = k + 1)
            if ((W == k) && (En == 1))
                Y[k] = 1;
            else
                Y[k] = 0;
    endmodule
  prompt: Implement a 2-to-4 decoder using a for loop

- code: |
    module priority(W, Y, z);
    input [3:0] W;
    output [1:0] Y;
    output z;
    reg [1:0] Y;
    reg z;
    integer k;
    always @(W)
    begin
        Y = 2'bx;
        z = 0;
        for (k = 0; k < 4; k = k + 1)
            if (W[k])
            begin
                Y = k;
                z = 1;
            end
    end
    endmodule
  prompt: Implement a priority encoder using a for loop

- code: |
    module compare(A, B, AeqB, AgtB, AltB);
    input [3:0] A, B;
    output AeqB, AgtB, AltB;
    reg AeqB, AgtB, AltB;
    always @(A or B)
    begin
        AeqB = 0;
        AgtB = 0;
        AltB = 0;
        if (A == B)
            AeqB = 1;
        else if (A > B)
            AgtB = 1;
        else
            AltB = 1;
    end
    endmodule
  prompt: Implement a 4-bit comparator

- code: |
    module addern(carryin, X, Y, S, carryout);
    parameter n = 32;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    wire [n:0] C;
    genvar k;
    assign C[0] = carryin;
    assign carryout = C[n];
    generate
        for (k = 0; k < n; k = k + 1)
        begin: fulladd_stage
            wire z1, z2, z3;
            xor (S[k], X[k], Y[k], C[k]);
            and (z1, X[k], Y[k]);
            and (z2, X[k], C[k]);
            and (z3, Y[k], C[k]);
            or (C[k+1], z1, z2, z3);
        end
    endgenerate
    endmodule
  prompt: Implement a parameterized n-bit adder using generate statement

- code: |
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        if (S == 2'b00)
            f = w0;
        else if (S == 2'b01)
            f = w1;
        else if (S == 2'b10)
            f = w2;
        else if (S == 2'b11)
            f = w3;
    endmodule
  prompt: Implement a 4-to-1 multiplexer using behavioral modeling with if-else statements

- code: |
    module mux4to1(W, S, f);
    input [0:3] W;
    input [1:0] S;
    output f;
    reg f;
    always @(W or S)
        if (S == 0)
            f = W[0];
        else if (S == 1)
            f = W[1];
        else if (S == 2)
            f = W[2];
        else if (S == 3)
            f = W[3];
    endmodule
  prompt: Implement a 4-to-1 multiplexer with vector input using behavioral modeling

- code: |
    module mux16to1(W, S16, f);
    input [0:15] W;
    input [3:0] S16;
    output f;
    wire [0:3] M;
    mux4to1 Mux1 (W[0:3], S16[1:0], M[0]);
    mux4to1 Mux2 (W[4:7], S16[1:0], M[1]);
    mux4to1 Mux3 (W[8:11], S16[1:0], M[2]);
    mux4to1 Mux4 (W[12:15], S16[1:0], M[3]);
    mux4to1 Mux5 (M[0:3], S16[3:2], f);
    endmodule
  prompt: Implement a 16-to-1 multiplexer using 4-to-1 multiplexer instantiations

- code: |
    module mux4to1(W, S, f);
    input [0:3] W;
    input [1:0] S;
    output f;
    reg f;
    always @(W or S)
        case (S)
            0: f = W[0];
            1: f = W[1];
            2: f = W[2];
            3: f = W[3];
        endcase
    endmodule
  prompt: Implement a 4-to-1 multiplexer using case statement

- code: |
    module dec2to4(W, Y, En);
    input [1:0] W;
    input En;
    output [0:3] Y;
    reg [0:3] Y;
    always @(W or En)
        case ({En, W})
            3'b100: Y = 4'b1000;
            3'b101: Y = 4'b0100;
            3'b110: Y = 4'b0010;
            3'b111: Y = 4'b0001;
            default: Y = 4'b0000;
        endcase
    endmodule
  prompt: Implement a 2-to-4 decoder with enable input using case statement

- code: |
    module dec2to4(W, Y, En);
    input [1:0] W;
    input En;
    output [0:3] Y;
    reg [0:3] Y;
    always @(W or En)
    begin
        if (En == 0)
            Y = 4'b0000;
        else
            case (W)
                0: Y = 4'b1000;
                1: Y = 4'b0100;
                2: Y = 4'b0010;
                3: Y = 4'b0001;
            endcase
    end
    endmodule
  prompt: Implement a 2-to-4 decoder with enable input using if-else and case statements

- code: |
    module dec4to16(W, Y, En);
    input [3:0] W;
    input En;
    output [0:15] Y;
    wire [0:3] M;
    dec2to4 Dec1 (W[3:2], M[0:3], En);
    dec2to4 Dec2 (W[1:0], Y[0:3], M[0]);
    dec2to4 Dec3 (W[1:0], Y[4:7], M[1]);
    dec2to4 Dec4 (W[1:0], Y[8:11], M[2]);
    dec2to4 Dec5 (W[1:0], Y[12:15], M[3]);
    endmodule
  prompt: Implement a 4-to-16 decoder using 2-to-4 decoder instantiations

- code: |
    module seg7(bcd, leds);
    input [3:0] bcd;
    output [1:7] leds;
    reg [1:7] leds;
    always @(bcd)
        case (bcd) // abcdefg
            0: leds = 7'b1111110;
            1: leds = 7'b0110000;
            2: leds = 7'b1101101;
            3: leds = 7'b1111001;
            4: leds = 7'b0110011;
            5: leds = 7'b1011011;
            6: leds = 7'b1011111;
            7: leds = 7'b1110000;
            8: leds = 7'b1111111;
            9: leds = 7'b1111011;
            default: leds = 7'bx;
        endcase
    endmodule
  prompt: Implement a 7-segment display decoder for BCD input

- code: |
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    reg [3:0] F;
    always @(s or A or B)
        case (s)
            0: F = 4'b0000;
            1: F = B - A;
            2: F = A - B;
            3: F = A + B;
            4: F = A ^ B;
            5: F = A | B;
            6: F = A & B;
            7: F = 4'b1111;
        endcase
    endmodule
  prompt: Implement an ALU with various operations based on select input

- code: |
    module priority(W, Y, z);
    input [3:0] W;
    output [1:0] Y;
    output z;
    reg [1:0] Y;
    reg z;
    always @(W)
    begin
        z = 1;
        casex (W)
            4'b1xxx: Y = 3;
            4'b01xx: Y = 2;
            4'b001x: Y = 1;
            4'b0001: Y = 0;
            default: begin
                z = 0;
                Y = 2'bx;
            end
        endcase
    end
    endmodule
  prompt: Implement a priority encoder with valid output

- code: |
    module dec2to4(W, Y, En);
    input [1:0] W;
    input En;
    output [0:3] Y;
    reg [0:3] Y;
    integer k;
    always @(W or En)
        for (k = 0; k <= 3; k = k + 1)
            if ((W == k) && (En == 1))
                Y[k] = 1;
            else
                Y[k] = 0;
    endmodule
  prompt: Implement a 2-to-4 decoder using a for loop

- code: |
    module priority(W, Y, z);
    input [3:0] W;
    output [1:0] Y;
    output z;
    reg [1:0] Y;
    reg z;
    integer k;
    always @(W)
    begin
        Y = 2'bx;
        z = 0;
        for (k = 0; k < 4; k = k + 1)
            if (W[k])
            begin
                Y = k;
                z = 1;
            end
    end
    endmodule
  prompt: Implement a priority encoder using a for loop

- code: |
    module compare(A, B, AeqB, AgtB, AltB);
    input [3:0] A, B;
    output AeqB, AgtB, AltB;
    reg AeqB, AgtB, AltB;
    always @(A or B)
    begin
        AeqB = 0;
        AgtB = 0;
        AltB = 0;
        if (A == B)
            AeqB = 1;
        else if (A > B)
            AgtB = 1;
        else
            AltB = 1;
    end
    endmodule
  prompt: Implement a 4-bit comparator

- code: |
    module addern(carryin, X, Y, S, carryout);
    parameter n = 32;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    wire [n:0] C;
    genvar k;
    assign C[0] = carryin;
    assign carryout = C[n];
    generate
        for (k = 0; k < n; k = k + 1)
        begin: fulladd_stage
            wire z1, z2, z3;
            xor (S[k], X[k], Y[k], C[k]);
            and (z1, X[k], Y[k]);
            and (z2, X[k], C[k]);
            and (z3, Y[k], C[k]);
            or (C[k+1], z1, z2, z3);
        end
    endgenerate
    endmodule
  prompt: Implement a parameterized n-bit adder using generate statement

- code: |
    module mux16to1(W, S16, f);
    input [0:15] W;
    input [3:0] S16;
    output f;
    reg f;
    always @(W or S16)
        case (S16[3:2])
            0: mux4to1(W[0:3], S16[1:0], f);
            1: mux4to1(W[4:7], S16[1:0], f);
            2: mux4to1(W[8:11], S16[1:0], f);
            3: mux4to1(W[12:15], S16[1:0], f);
        endcase
    task mux4to1;
        input [0:3] X;
        input [1:0] S4;
        output g;
        reg g;
        case (S4)
            0: g = X[0];
            1: g = X[1];
            2: g = X[2];
            3: g = X[3];
        endcase
    endtask
    endmodule
  prompt: Implement a 16-to-1 multiplexer using a task for 4-to-1 multiplexing

- code: |
    module mux16to1(W, S16, f);
    input [0:15] W;
    input [3:0] S16;
    output f;
    reg f;
    function mux4to1;
        input [0:3] X;
        input [1:0] S4;
        case (S4)
            0: mux4to1 = X[0];
            1: mux4to1 = X[1];
            2: mux4to1 = X[2];
            3: mux4to1 = X[3];
        endcase
    endfunction
    always @(W or S16)
        case (S16[3:2])
            0: f = mux4to1(W[0:3], S16[1:0]);
            1: f = mux4to1(W[4:7], S16[1:0]);
            2: f = mux4to1(W[8:11], S16[1:0]);
            3: f = mux4to1(W[12:15], S16[1:0]);
        endcase
    endmodule
  prompt: Implement a 16-to-1 multiplexer using a function for 4-to-1 multiplexing

- code: |
    module problem6_18(W, En, y0, y1, y2, y3);
    input [1:0] W;
    input En;
    output y0, y1, y2, y3;
    reg y0, y1, y2, y3;
    always @(W or En)
    begin
        y0 = 0;
        y1 = 0;
        y2 = 0;
        y3 = cef = 0;
        if (En)
            if (W == 0) y0 = 1;
            else if (W == 1) y1 = 1;
            else if (W == 2) y2 = 1;
            else y3 = 1;
    end
    endmodule
  prompt: Implement a 2-to-4 decoder with individual outputs using if-else statements

- code: |
    module dec2to4(W, Y, En);
    input [1:0] W;
    input En;
    output [0:3] Y;
    reg [0:3] Y;
    integer k;
    always @(W or En)
        for (k = 0; k <= 3; k = k + 1)
            if (W == k)
                Y[k] = En;
    endmodule
  prompt: Implement a 2-to-4 decoder using a for loop with enable input

- code: |
    module D_latch(D, Clk, Q);
    input D, Clk;
    output Q;
    reg Q;
    always @(D or Clk)
        if (Clk)
            Q = D;
    endmodule
  prompt: Implement a D latch

- code: |
    module flipflop(D, Clock, Q);
    input D, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        Q = D;
    endmodule
  prompt: Implement a positive-edge-triggered D flip-flop

- code: |
    module example7_3(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 = D;
        Q2 = Q1;
    end
    endmodule
  prompt: Implement a module with two D flip-flops in series

- code: |
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
  prompt: Implement a module with two D flip-flops in series using non-blocking assignments

- code: |
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    always @(posedge Clock)
    begin
        f = x1 & x2;
        g = f | x3;
    end
    endmodule
  prompt: Implement a sequential circuit with combinational logic

- code: |
    module example7_6(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    always @(posedge Clock)
    begin
        f <= x1 & x2;
        g <= f | x3;
    end
    endmodule
  prompt: Implement a sequential circuit with combinational logic using non-blocking assignments

- code: |
    module flipflop(D, Clock, Resetn, Q);
    input D, Clock, Resetn;
    output Q;
    reg Q;
    always @(negedge Resetn or posedge Clock)
        if (!Resetn)
            Q <= 0;
        else
            Q <= D;
    endmodule
  prompt: Implement a D flip-flop with asynchronous active-low reset

- code: |
    module flipflop(D, Clock, Resetn, Q);
    input D, Clock, Resetn;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Resetn)
            Q <= 0;
        else
            Q <= D;
    endmodule
  prompt: Implement a D flip-flop with synchronous active-low reset

- code: |
    module shift(Clock, Reset, w, Load, R, Q);
    input Clock, Reset, w, Load;
    input [3:0] R;
    output [3:0] Q;
    lpm_shiftreg shift_right(.data(R), .aclr(Reset), .clock(Clock),
                           .load(Load), .shiftin(w), .q(Q));
    defparam shift_right.lpm_width = 4;
    defparam shift_right.lpm_direction = "RIGHT";
    endmodule
  prompt: Implement a 4-bit right shift register with load and reset

- code: |
    module regn(D, Clock, Resetn, Q);
    parameter n = 16;
    input [n-1:0] D;
    input Clock, Resetn;
    output [n-1:0] Q;
    reg [n-1:0] Q;
    always @(negedge Resetn or posedge Clock)
        if (!Resetn)
            Q <= 0;
        else
            Q <= D;
    endmodule
  prompt: Implement a parameterized n-bit register with reset

- code: |
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel)
            Q <= D0;
        else
            Q <= D1;
    endmodule
  prompt: Implement a D flip-flop with 2-to-1 multiplexer input

- code: |
    module shift4(R, L, w, Clock, Q);
    input [3:0] R;
    input L, w, Clock;
    output [3:0] Q;
    wire [3:0] Q;
    muxdff Stage3(w, R[3], L, Clock, Q[3]);
    muxdff Stage2(Q[3], R[2], L, Clock, Q[2]);
    muxdff Stage1(Q[2], R[1], L, Clock, Q[1]);
    muxdff Stage0(Q[1], R[0], L, Clock, Q[0]);
    endmodule
  prompt: Implement a 4-bit shift register with parallel load using muxdff modules

- code: |
    module shift4(R, L, w, Clock, Q);
    input [3:0] R;
    input L, w, Clock;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock)
        if (L)
            Q <= R;
        else
        begin
            Q[0] <= Q[1];
            Q[1] <= Q[2];
            Q[2] <= Q[3];
            Q[3] <= w;
        end
    endmodule
  prompt: Implement a 4-bit shift register with parallel load using behavioral modeling

- code: |
    module shiftn(R, L, w, Clock, Q);
    parameter n = 16;
    input [n-1:0] R;
    input L, w, Clock;
    output [n-1:0] Q;
    reg [n-1:0] Q;
    integer k;
    always @(posedge Clock)
        if (L)
            Q <= R;
        else
        begin
            for (k = 0; k < n-1; k = k + 1)
                Q[k] <= Q[k+1];
            Q[n-1] <= w;
        end
    endmodule
  prompt: Implement a parameterized n-bit shift register with parallel load

- code: |
    module upcount(Resetn, Clock, E, Q);
    input Resetn, Clock, E;
    output [3:0] Q;
    reg [3:0] Q;
    always @(negedge Resetn or posedge Clock)
        if (!Resetn)
            Q <= 0;
        else if (E)
            Q <= Q + 1;
    endmodule
  prompt: Implement a 4-bit up counter with enable and reset

- code: |
    module upcount(R, Resetn, Clock, E, L, Q);
    input [3:0] R;
    input Resetn, Clock, E, L;
    output [3:0] Q;
    reg [3:0] Q;
    always @(negedge Resetn or posedge Clock)
        if (!Resetn)
            Q <= 0;
        else if (L)
            Q <= R;
        else if (E)
            Q <= Q + 1;
    endmodule
  prompt: Implement a 4-bit up counter with parallel load, enable, and reset

- code: |
    module downcount(R, Clock, E, L, Q);
    parameter n = 8;
    input [n-1:0] R;
    input Clock, L, E;
    output [n-1:0] Q;
    reg [n-1:0] Q;
    always @(posedge Clock)
        if (L)
            Q <= R;
        else if (E)
            Q <= Q - 1;
    endmodule
  prompt: Implement a parameterized n-bit down counter with parallel load and enable

- code: |
    module updowncount(R, Clock, L, E, up_down, Q);
    parameter n = 8;
    input [n-1:0] R;
    input Clock, L, E, up_down;
    output [n-1:0] Q;
    reg [n-1:0] Q;
    integer direction;
    always @(posedge Clock)
    begin
        if (up_down)
            direction = 1;
        else
            direction = -1;
        if (L)
            Q <= R;
        else if (E)
            Q <= Q + direction;
    end
    endmodule
  prompt: Implement a parameterized n-bit up/down counter with parallel load and enable

- code: |
    module regn(R, Rin, Clock, Q);
    parameter n = 8;
    input [n-1:0] R;
    input Rin, Clock;
    output [n-1:0] Q;
    reg [n-1:0] Q;
    always @(posedge Clock)
        if (Rin)
            Q <= R;
    endmodule
  prompt: Implement a parameterized n-bit register with enable

- code: |
    module trin(Y, E, F);
    parameter n = 8;
    input [n-1:0] Y;
    input E;
    output [n-1:0] F;
    wire [n-1:0] F;
    assign F = E ? Y : 'bz;
    endmodule
  prompt: Implement a parameterized n-bit tri-state buffer

- code: |
    module shiftr(Resetn, w, Clock, Q);
    parameter m = 4;
    input Resetn, w, Clock;
    output [1:m] Q;
    reg [1:m] Q;
    integer k;
    always @(negedge Resetn or posedge Clock)
        if (!Resetn)
            Q <= 0;
        else
        begin
            for (k = m; k > 1; k = k - 1)
                Q[k] <= Q[k-1];
            Q[1] <= w;
        end
    endmodule
  prompt: Implement a parameterized m-bit shift register with reset

- code: |
    module swap(Data, Resetn, w, Clock, Extern, RinExt, BusWires);
    input [7:0] Data;
    input Resetn, w, Clock, Extern;
    input [1:3] RinExt;
    output [7:0] BusWires;
    tri [7:0] BusWires;
    wire [1:3] Rin, Rout, Q;
    wire [7:0] R1, R2, R3;
    shiftr control(Resetn, w, Clock, Q);
    defparam control.m = 3;
    assign Rin[1] = RinExt[1] | Q[3];
    assign Rin[2] = RinExt[2] | Q[2];
    assign Rin[3] = RinExt[3] | Q[1];
    assign Rout[1] = Q[2];
    assign Rout[2] = Q[1];
    assign Rout[3] = Q[3];
    regn reg_1(BusWires, Rin[1], Clock, R1);
    regn reg_2(BusWires, Rin[2], Clock, R2);
    regn reg_3(BusWires, Rin[3], Clock, R3);
    trin tri_ext(Data, Extern, BusWires);
    trin tri_1(R1, Rout[1], BusWires);
    trin tri_2(R2, Rout[2], BusWires);
    trin tri_3(R3, Rout[3], BusWires);
    endmodule
  prompt: Implement a data swap circuit with tri-state bus and shift register control

- code: |
    module swapmux(Data, Resetn, w, Clock, RinExt, BusWires);
    input [7:0] Data;
    input Resetn, w, Clock;
    input [1:3] RinExt;
    output [7:0] BusWires;
    reg [7:0] BusWires;
    wire [1:3] Rin, Q;
    wire [7:0] R1, R2, R3;
    reg [1:0] S;
    shiftr control(Resetn, w, Clock, Q);
    defparam control.m = 3;
    assign Rin[1] = RinExt[1] | Q[3];
    assign Rin[2] = RinExt[2] | Q[2];
    assign Rin[3] = RinExt[3] | Q[1];
    regn reg_1(BusWires, Rin[1], Clock, R1);
    regn reg_2(BusWires, Rin[2], Clock, R2);
    regn reg_3(BusWires, Rin[3], Clock, R3);
    always @(Q or Data or R1 or R2 or R3 or S)
    begin
        if (Q == 3'b000) S = 2'b00;
        else if (Q == 3'b100) S = 2'b10;
        else if (Q == 3'b010) S = 2'b01;
        else S = 2'b11;
        if (S == 2'b00) BusWires = Data;
        else if (S == 2'b01) BusWires = R1;
        else if (S == 2'b10) BusWires = R2;
        else BusWires = R3;
    end
    endmodule
  prompt: Implement a data swap circuit using multiplexer selection

- code: |
    module swapmux(Data, Resetn, w, Clock, RinExt, BusWires);
    input [7:0] Data;
    input Resetn, w, Clock;
    input [1:3] RinExt;
    output [7:0] BusWires;
    reg [7:0] BusWires;
    wire [1:3] Rin, Q;
    wire [7:0] R1, R2, R3;
    shiftr control(Resetn, w, Clock, Q);
    defparam control.m = 3;
    assign Rin[1] = RinExt[1] | Q[3];
    assign Rin[2] = RinExt[2] | Q[2];
    assign Rin[3] = RinExt[3] | Q[1];
    regn reg_1(BusWires, Rin[1], Clock, R1);
    regn reg_2(BusWires, Rin[2], Clock, R2);
    regn reg_3(BusWires, Rin[3], Clock, R3);
    always @(Q or Data or R1 or R2 or R3)
    begin
        if (Q == 3'b000) BusWires = Data;
        else if (Q == 3'b100) BusWires = R2;
        else if (Q == 3'b010) BusWires = R1;
        else BusWires = R3;
    end
    endmodule
  prompt: Implement a data swap circuit with simplified multiplexer selection

- code: |
    module upcount(Clear, Clock, Q);
    input Clear, Clock;
    output [1:0] Q;
    reg [1:0] Q;
    always @(posedge Clock)
        if (Clear)
            Q <= 0;
        else
            Q <= Q + 1;
    endmodule
  prompt: Implement a 2-bit up counter with clear input

- code: |
    module BCDcount(Clock, Clear, E, BCD1, BCD0);
    input Clock, Clear, E;
    output [3:0] BCD1, BCD0;
    reg [3:0] BCD1, BCD0;
    always @(posedge Clock)
    begin
        if (Clear)
        begin
            BCD1 <= 0;
            BCD0 <= 0;
        end
        else if (E)
            if (BCD0 == 4'b1001)
            begin
                BCD0 <= 0;
                if (BCD1 == 4'b1001)
                    BCD1 <= 0;
                else
                    BCD1 <= BCD1 + 1;
            end
            else
                BCD0 <= BCD0 + 1;
    end
    endmodule
  prompt: Implement a two-digit BCD counter with enable and clear

- code: |
    module reaction(c9, Reset, w, Pushn, LEDn, Digit1, Digit0);
    input c9, Reset, w, Pushn;
    output LEDn;
    output [1:7] Digit1, Digit0;
    wire LEDn;
    wire [1:7] Digit1, Digit0;
    reg LED;
    wire [3:0] BCD1, BCD0;
    always @(posedge c9)
    begin
        if (Pushn == 0)
            LED <= 0;
        else if (w)
            LED <= 1;
    end
    assign LEDn = LED;
    BCDcount counter(c9, Reset, LED, BCD1, BCD0);
    seg7 seg1(BCD1, Digit1);
    seg7 seg0(BCD0, Digit0);
    endmodule
  prompt: Implement a reaction timer circuit with BCD display

- code: |
    module lfsr(R, L, Clock, Q);
    input [0:2] R;
    input L, Clock;
    output [0:2] Q;
    reg [0:2] Q;
    always @(posedge Clock)
        if (L)
            Q <= R;
        else
            Q <= {Q[2], Q[0] ^ Q[2], Q[1]};
    endmodule
  prompt: Implement a 3-bit linear feedback shift register with load

- code: |
    module lfsr(R, L, Clock, Q);
    input [0:2] R;
    input L, Clock;
    output [0:2] Q;
    reg [0:2] Q;
    always @(posedge Clock)
        if (L)
            Q <= R;
        else
            Q <= {Q[2], Q[0], Q[1] ^ Q[2]};
    endmodule
  prompt: Implement a 3-bit linear feedback shift register with different feedback

- code: |
    module lfsr(R, L, Clock, Q);
    input [0:2] R;
    input L, Clock;
    output [0:2] Q;
    reg [0:2] Q;
    always @(posedge Clock)
        if (L)
            Q <= R;
        else
        begin
            Q[0] = Q[2];
            Q[1] = Q[0] ^ Q[2];
            Q[2] = Q[1];
        end
    endmodule
  prompt: Implement a 3-bit linear feedback shift register with alternative feedback configuration

- code: |
    module lfsr(R, L, Clock, Q);
    input [0:2] R;
    input L, Clock;
    output [0:2] Q;
    reg [0:2] Q;
    always @(posedge Clock)
        if (L)
            Q <= R;
        else
        begin
            Q[0] = Q[2];
            Q[1] = Q[0];
            Q[2] = Q[1] ^ Q[2];
        end
    endmodule
  prompt: Implement a 3-bit linear feedback shift register with another feedback configuration

- code: |
    module simple(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg [2:1] y, Y;
    parameter [2:1] A = 2'b00, B = 2'b01, C = 2'b10;
    always @(w or y)
        case (y)
            A: if (w) Y = B;
            else Y = A;
            B: if (w) Y = C;
            else Y = A;
            C: if (w) Y = C;
            else Y = A;
            default: Y = 2'bxx;
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    assign z = (y == C);
    endmodule
  prompt: Implement a Moore finite state machine with three states

- code: |
    module simple(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg z;
    reg [2:1] y, Y;
    parameter [2:1] A = 2'b00, B = 2'b01, C = 2'b10;
    always @(w or y)
    begin
        case (y)
            A: if (w) Y = B;
            else Y = A;
            B: if (w) Y = C;
            else Y = A;
            C: if (w) Y = C;
            else Y = A;
            default: Y = 2'bxx;
        endcase
        z = (y == C);
    end
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    endmodule
  prompt: Implement a Moore FSM with output defined in combinational block

- code: |
    module simple(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg [2:1] y;
    parameter [2:1] A = 2'b00, B = 2'b01, C = 2'b10;
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else
            case (y)
                A: if (w) y <= B;
                else y <= A;
                B: if (w) y <= C;
                else y <= A;
                C: if (w) y <= C;
                else y <= A;
                default: y <= 2'bxx;
            endcase
    assign z = (y == C);
    endmodule
  prompt: Implement a Moore FSM with state transitions in sequential block

- code: |
    module control(Clock, Resetn, w, R1in, R1out, R2in, R2out, R3in, R3out, Done);
    input Clock, Resetn, w;
    output R1in, R1out, R2in, R2out, R3in, R3out, Done;
    reg [2:1] y, Y;
    parameter [2:1] A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;
    always @(w or y)
        case (y)
            A: if (w) Y = B;
            else Y = A;
            B: Y = C;
            C: Y = D;
            D: Y = A;
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    assign R2out = (y == B);
    assign R3in = (y == B);
    assign R1out = (y == C);
    assign R2in = (y == C);
    assign R3out = (y == D);
    assign R1in = (y == D);
    assign Done = (y == D);
    endmodule
  prompt: Implement a control FSM with multiple outputs

- code: |
    module mealy(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg y, Y, z;
    parameter A = 0, B = 1;
    always @(w or y)
        case (y)
            A: if (w)
                begin
                    z = 0;
                    Y = B;
                end
            else
                begin
                    z = 0;
                    Y = A;
                end
            B: if (w)
                begin
                    z = 1;
                    Y = B;
                end
            else
                begin
                    z = 0;
                    Y = A;
                end
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    endmodule
  prompt: Implement a Mealy FSM with two states

- code: |
    module shiftrne(R, L, E, w, Clock, Q);
    parameter n = 8;
    input [n-1:0] R;
    input L, E, w, Clock;
    output [n-1:0] Q;
    reg [n-1:0] Q;
    integer k;
    always @(posedge Clock)
        if (L)
            Q <= R;
        else if (E)
        begin
            for (k = n-1; k > 0; k = k - 1)
                Q[k-1] <= Q[k];
            Q[n-1] <= w;
        end
    endmodule
  prompt: Implement a parameterized n-bit shift register with load and enable

- code: |
    module serial_adder(A, B, Reset, Clock, Sum);
    input [7:0] A, B;
    input Reset, Clock;
    output [7:0] Sum;
    reg [3:0] Count;
    reg s, y, Y;
    wire [7:0] QA, QB, Sum;
    wire Run;
    parameter G = 0, H = 1;
    shiftrne shift_A (A, Reset, 1, 0, Clock, QA);
    shiftrne shift_B (B, Reset, 1, 0, Clock, QB);
    shiftrne shift_Sum (0, Reset, Run, s, Clock, Sum);
    always @(QA or QB or y)
        case (y)
            G: begin
                s = QA[0] ^ QB[0];
                if (QA[0] & QB[0]) Y = H;
                else Y = G;
            end
            H: begin
                s = QA[0] ^ QB[0];
                if (~QA[0] & ~QB[0]) Y = G;
                else Y = H;
            end
            default: Y = G;
        endcase
    always @(posedge Clock)
        if (Reset) y <= G;
        else y <= Y;
    always @(posedge Clock)
        if (Reset) Count = 8;
        else if (Run) Count = Count - 1;
    assign Run = |Count;
    endmodule
  prompt: Implement a serial adder with FSM control

- code: |
    module arbiter(r, Resetn, Clock, g);
    input [1:3] r;
    input Resetn, Clock;
    output [1:3] g;
    wire [1:3] g;
    reg [2:1] y, Y;
    parameter Idle = 2'b00, gnt1 = 2'b01, gnt2 = 2'b10, gnt3 = 2'b11;
    always @(r or y)
        case (y)
            Idle: case (r)
                3'b000: Y = Idle;
                3'b1xx: Y = gnt1;
                3'b01x: Y = gnt2;
                3'b001: Y = gnt3;
                default: Y = Idle;
            endcase
            gnt1: if (r[1]) Y = gnt1;
            else Y = Idle;
            gnt2: if (r[2]) Y = gnt2;
            else Y = Idle;
            gnt3: if (r[3]) Y = gnt3;
            else Y = Idle;
            default: Y = Idle;
        endcase
    always @(posedge Clock)
        if (Resetn == 0) y <= Idle;
        else y <= Y;
    assign g[1] = (y == gnt1);
    assign g[2] = (y == gnt2);
    assign g[3] = (y == gnt3);
    endmodule
  prompt: Implement an arbiter FSM with three grants

- code: |
    module rege(R, Clock, Resetn, E, Q);
    input R, Clock, Resetn, E;
    output Q;
    reg Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 0;
        else if (E)
            Q <= R;
    endmodule
  prompt: Implement a single-bit register with enable and reset

- code: |
    module regne(R, Clock, Resetn, E, Q);
    parameter n = 8;
    input [n-1:0] R;
    input Clock, Resetn, E;
    output [n-1:0] Q;
    reg [n-1:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 0;
        else if (E)
            Q <= R;
    endmodule
  prompt: Implement a parameterized n-bit register with enable and reset

- code: |
    module shiftlne(R, L, E, w, Clock, Q);
    parameter n = 4;
    input [n-1:0] R;
    input L, E, w, Clock;
    output [n-1:0] Q;
    reg [n-1:0] Q;
    integer k;
    always @(posedge Clock)
    begin
        if (L)
            Q <= R;
        else if (E)
        begin
            Q[0] <= w;
            for (k = 1; k < n; k = k + 1)
                Q[k] <= Q[k-1];
        end
    end
    endmodule
  prompt: Implement a parameterized n-bit left shift register with load and enable

- code: |
    module fulladd(Cin, x, y, s, Cout);
    input Cin, x, y;
    output s, Cout;
    assign s = x ^ y ^ Cin;
    assign Cout = (x & y) | (Cin & x) | (Cin & y);
    endmodule
  prompt: Implement a full adder using dataflow modeling

- code: |
    module IntroTop (output X, Y, Z, input A, B, C, D);
    wire ab, bc, q, qn;
    assign #1 Z = ~qn;
    AndOr InputCombo01 (.X(ab), .Y(bc), .A(A), .B(B), .C(C));
    SR SRLatch01 (.Q(q), .Qn(qn), .S(bc), .R(D));
    XorNor OutputCombo01 (.X(X), .Y(Y), .A(ab), .B(q), .C(qn));
    endmodule
  prompt: Implement a top-level module combining three lower-level modules and an inverter for combinational logic

- code: |
    `timescale 1 ns/100ps
    module TestBench;
    wire Xwatch, Ywatch, Zwatch;
    reg Astim, Bstim, Cstim, Dstim;
    initial
    begin
        #1 Astim = 1'b0;
        #1 Bstim = 1'b0;
        #1 Cstim = 1'b0;
        #50 Dstim = 1'b1;
        #50 Astim = 1'b0;
        #50 Cstim = 1'b0;
        #50 Dstim = 1'b0;
        #50 $finish;
    end
    IntroTop Topper01 (.X(Xwatch), .Y(Ywatch), .Z(Zwatch), .A(Astim), .B(Bstim), .C(Cstim), .D(Dstim));
    endmodule
  prompt: Implement a testbench to simulate the IntroTop module with stimulus inputs

- code: |
    module AndOr (output X, Y, input A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B | C;
    endmodule
  prompt: Implement a combinational logic module with AND and OR operations

- code: |
    module SR (output Q, Qn, input S, R);
    wire q, qn;
    assign #1 Q = q;
    assign #1 Qn = qn;
    assign #10 q = ~(S & qn);
    assign #10 qn = ~(R & q);
    endmodule
  prompt: Implement an SR latch using combinational AND expressions with feedback

- code: |
    module XorNor (output X, Y, input A, B, C);
    wire x;
    assign #1 X = x;
    assign #10 x = A ^ B;
    assign #10 Y = ~(x | C);
    endmodule
  prompt: Implement a combinational logic module with XOR and NOR operations

- code: |
    module And2 (output Z, input A, B);
    reg Zreg;
    assign #1 Z = Zreg;
    initial
    begin
        Zreg = 1'b0;
        #2 Zreg = A && B;
        #5 $finish;
    end
    endmodule
  prompt: Implement a module with procedural assignment for an AND operation

- code: |
    module VFO (output ClockOut, input[1:0] AdjustFreq, input Reset);
    reg PLLClock;
    real VFODelay;
    assign ClockOut = PLLClock;
    always @(PLLClock, Reset)
    if (Reset==1'b1)
    begin
        VFODelay = `VFOBaseDelay;
        PLLClock = 1'b0;
    end
    else begin
        case (AdjustFreq)
            2'b11: VFODelay = VFODelay - `VFODelta;
            2'b00: VFODelay = VFODelay + `VFODelta;
        endcase
        #VFODelay PLLClock <= ~PLLClock;
    end
    endmodule
  prompt: Implement a variable frequency oscillator with adjustable delay

- code: |
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    always @(ClockIn, Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    else begin
        case (HiCount)
            2'b00: Adjr = 2'b11;
            2'b01: Adjr = 2'b01;
            default: Adjr = 2'b00;
        endcase
        HiCount = 2'b0;
    end
    endmodule
  prompt: Implement a comparator for frequency adjustment based on clock inputs

- code: |
    module ParToSerial (output SerOut, SerValidFlag, input SerClock, ParValid, input[31:0] BusIn);
    integer ix;
    reg SerValid, Done, SerBit;
    assign #1 SerValidFlag = SerValid;
    assign #2 SerOut = SerBit;
    always @(posedge SerClock)
    begin
        if (ParValid==1'b1)
            if (SerValid==1'b1)
            begin
                SerBit <= BusIn[ix];
                if (ix==0)
                begin
                    SerValid <= 1'b0;
                    Done <= 1'b1;
                end
                else ix <= ix - 1;
            end
            else begin
                if (Done==1'b0)
                begin
                    SerValid <= 1'b1;
                    ix <= 31;
                end
                SerBit <= 1'b0;
            end
        else
        begin
            SerValid <= 1'b0;
            Done <= 1'b0;
            SerBit <= 1'b0;
        end
    end
    endmodule
  prompt: Implement a parallel-to-serial converter with validation flags

- code: |
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else
        ObusReg <= Storage[Adr];
    endmodule
  prompt: Implement an 8-bit RAM with 16 locations for read and write operations

- code: |
    module TFF (output Q, input Clock, Reset);
    wire QnD;
    DFFC Toggler (.Q(Q), .Qn(QnD), .D(QnD), .Clk(Clock), .Rst(Reset));
    endmodule
  prompt: Implement a T flip-flop using a D flip-flop with clear

- code: |
    module InactiveStratum;
    reg Clk, A, Z, Zin;
    always @(posedge Clk)
    begin
        A = 1'b1;
        #0 A = 1'b0;
    end
    `ifdef Case1
    always @(A) #0 Z = Zin;
    always @(A) Zin = A;
    `else
    always @(A) Z = Zin;
    always @(A) #0 Zin = A;
    `endif
    initial
    begin
        #50 Clk = 1'bz;
        #50 Clk = 1'b0;
        #50 Clk = 1'b1;
        #50 $finish;
    end
    endmodule
  prompt: Implement a module to test signal propagation with conditional compilation

- code: |
    module SchedDelayA;
    reg a, b;
    initial
    begin
        #1 a <= b;
        #1 a = 1'b1;
        #2 a = 1'b0;
        #2 a = 1'b1;
        #1 a = 1'b0;
        #0 b = 1'b1;
        #0 b = 1'b0;
        #0 b <= 1'b1;
        #5 $finish;
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule
  prompt: Implement a module to test scheduling with non-blocking and blocking assignments

- code: |
    module SchedDelayB;
    reg a, b;
    initial
    begin
        #0 b = 1'b1;
        #0 b = 1'b0;
        #0 b <= 1'b1;
        #1 a <= b;
        #1 a = 1'b1;
        #2 a = 1'b0;
        #2 a = 1'b1;
        #1 a = 1'b0;
        #5 $finish;
    end
    always @(a) b <= a;
    always @(b) a = b;
    endmodule
  prompt: Implement another module to test scheduling with different initial block timing

- code: |
    module SchedDelayC;
    wire a;
    reg b, c, d;
    initial
    begin
        #0 b = 1'b0;
        c = 1'b1;
        d = 1'b1;
        #5 d = 1'b0;
        #10 c = 1'b1;
        #20 $finish;
    end
    assign #(1,3,5) a = c;
    assign #(2,3,4) a = d;
    endmodule
  prompt: Implement a module to test continuous assignments with inertial delays

- code: |
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
    end
    endmodule
  prompt: Implement a module with combinational logic using a named always block

- code: |
    module EventCtlLatch (output xLatch, yLatch, input a, b, c);
    reg xReg, yReg;
    assign xLatch = xReg;
    assign yLatch = yReg;
    always @(a)
    begin: aLatcher
        if (a==1'b1)
            xReg <= b & c;
    end
    always @(b)
    begin: bLatcher
        if (b==1'b1)
            yReg <= (b | c)^a;
    end
    endmodule
  prompt: Implement a module with latch behavior using conditional assignments

- code: |
    module NoNets (output Xout, input Ain, Bin);
    and And01(Xout, Ain, Bin);
    endmodule
  prompt: Implement a simple AND gate module using gate-level instantiation

- code: |
    module NoThing (output Xout, input Ain);
    assign Xout = Ain;
    endmodule
  prompt: Implement a pass-through module with direct assignment

- code: |
    module ANSItop #(parameter A=1, B=3, parameter signed[4:1] List=4'b1010)
    (output[3:0] BusOut, output ClockOut, input[3:0] BusIn, input ClockIn, input[1:0] Select);
    reg ClockOutReg;
    assign #(2,3) ClockOut = ClockOutReg;
    endmodule
  prompt: Implement a module with parameterized ANSI-style header and delayed output assignment

- code: |
    module DistributedDelay (output Z, input A, B);
    wire Node;
    assign #1 Z = Node;
    and #(2,3) (Node, A, B);
    endmodule
  prompt: Implement a module with distributed delay on gate and output

- code: |
    module LumpedDelay (output Z, input A, B);
    wire Node;
    assign #(3,4) Z = Node;
    and (Node, A, B);
    endmodule
  prompt: Implement a module with lumped delay on output

- code: |
    module FourFlopsRTL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    reg[3:0] QReg;
    wire[3:0] Qwire;
    always @(posedge Clk)
        #DClk QReg <= D;
    assign #DBuf Q = (Ena==1'b1)? QReg : 'bz;
    endmodule
  prompt: Implement a 4-bit register with enable and parameterized delays using RTL modeling

- code: |
    module FourFlopsStruct #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    DFF #(.DClk(DClk)) DReg[0:3](.Q(QWire), .D(D), .Clk(Clk));
    assign #DBuf Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
  prompt: Implement a 4-bit register with enable using structural instantiation of D flip-flops

- code: |
    module DFF #(parameter DClk = 2) (output Q, input D, Clk);
    reg QReg;
    always @(posedge Clk) QReg <= D;
    assign #DClk Q = QReg;
    endmodule
  prompt: Implement a D flip-flop with parameterized delay

- code: |
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire), .D(D), .Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
  prompt: Implement a 4-bit register with enable and lumped delay using structural modeling

- code: |
    module DFF (output Q, input D, Clk);
    reg QReg;
    always @(posedge Clk)
        QReg <= D;
    assign Q = QReg;
    endmodule
  prompt: Implement a basic D flip-flop

- code: |
    module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
    endspecify
    endmodule
  prompt: Implement an ALU module with specified timing parameters

- code: |
    module FullPath (output[2:0] QBus, output Z, input A, B, C, Clock);
    specify
        specparam tAll=10, tR=20, tF=21;
        (A,B,C *> QBus) = tAll;
        (Clock *> QBus) = (tR, tF);
    endspecify
    endmodule
  prompt: Implement a module with full-path timing specifications

- code: |
    module ParallelPath (output Z, input A, B, C, Clock);
    specify
        specparam tAll=10, tR=20, tF=21;
        (Clock => Z) = tAll;
        (A => Z) = (tR, tF);
        (B => Z) = tAll;
    endspecify
    endmodule
  prompt: Implement a module with parallel-path timing specifications

- code: |
    module NewInertia #(parameter r_limit = 3, e_limit = 4:5:6)
    (output Z, input A, B, C);
    specify
        specparam PATHPULSE$ = r_limit;
        specparam PATHPULSE$B$Z = (r_limit, e_limit);
    endspecify
    endmodule
  prompt: Implement a module with pulse rejection limits for inertial delay

- code: |
    module MyModule (output[31:0] DataBus, input Clock);
    MyModule WrapperU1 (.OutBus(DataBus), .ClockIn(Clock));
    endmodule
  prompt: Implement a wrapper module to rename ports for compatibility

- code: |
    module SerialRx (output SerClk, SerData, input SerLinkIn, ParClk, Reset);
    assign SerData = SerLinkIn;
    PLLTop PLLRxU1 (.ClockOut(SerClk), .ClockIn(ParClk), .Reset(Reset));
    endmodule
  prompt: Implement a serial receiver module with PLL clock generation

- code: |
    module latch(D, clk, Q);
    input D, clk;
    output Q;
    reg Q;
    always @(D or clk)
        if (clk)
            Q <= D;
    endmodule
  prompt: Implement a D latch with combinational sensitivity to data and clock

- code: |
    module flipflop(D, Clock, Q);
    input D, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        Q <= D;
    endmodule
  prompt: Implement a positive-edge-triggered D flip-flop

- code: |
    module flipflopar(D, Clock, Resetn, Q);
    input D, Clock, Resetn;
    output Q;
    reg Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 0;
        else
            Q <= D;
    endmodule
  prompt: Implement a D flip-flop with asynchronous active-low reset

- code: |
    module flipflopsr(D, Clock, Resetn, Q);
    input D, Clock, Resetn;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (Resetn == 0)
            Q <= 0;
        else
            Q <= D;
    endmodule
  prompt: Implement a D flip-flop with synchronous active-low reset

- code: |
    module dff_inst(D, Clock, Resetn, Q);
    input D, Clock, Resetn;
    output Q;
    lpm_ff flipflop(.data(D), .aclr(Resetn), .clock(Clock), .q(Q));
    defparam flipflop.lpm_width = 1;
    endmodule
  prompt: Implement a D flip-flop using an LPM flip-flop component with asynchronous clear

- code: |
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    endmodule
  prompt: Implement a 4-bit register with asynchronous active-low reset

- code: |
    module regne(D, Clock, Resetn, E, Q);
    parameter n = 4;
    input [n-1:0] D;
    input Clock, Resetn, E;
    output [n-1:0] Q;
    reg [n-1:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 0;
        else if (E)
            Q <= D;
    endmodule
  prompt: Implement a parameterized n-bit register with enable and asynchronous reset

- code: |
    module shift3(w, Clock, Q);
    input w, Clock;
    output [1:3] Q;
    reg [1:3] Q;
    always @(posedge Clock)
    begin
        Q[3] <= w;
        Q[2] <= Q[3];
        Q[1] <= Q[2];
    end
    endmodule
  prompt: Implement a 3-bit shift register with serial input using non-blocking assignments

- code: |
    module shift3(w, Clock, Q);
    input w, Clock;
    output [1:3] Q;
    reg [1:3] Q;
    always @(posedge Clock)
    begin
        Q[3] = w;
        Q[2] = Q[3];
        Q[1] = Q[2];
    end
    endmodule
  prompt: Implement a 3-bit shift register with serial input using blocking assignments

- code: |
    module count4(Clock, Resetn, E, Q);
    input Clock, Resetn, E;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 0;
        else if (E)
            Q <= Q + 1;
    endmodule
  prompt: Implement a 4-bit up counter with enable and asynchronous reset

- code: |
    module accum(X, Y, Clock, Resetn, Result);
    parameter k = 8;
    input [k-1:0] X, Y;
    input Clock, Resetn;
    output [k-1:0] Result;
    wire [k-1:0] Sum;
    wire Cout, Go;
    reg [k-1:0] C;
    ripple u1(.carryin(0), .X(X), .Y(Result), .S(Sum), .carryout(Cout));
    defparam u1.n = k;
    regne u2(.D(Sum), .Clock(Clock), .Resetn(Resetn), .E(Go), .Q(Result));
    defparam u2.n = 8;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            C <= Y;
        else if (Go)
            C <= C - 1;
    assign Go = |C;
    endmodule
  prompt: Implement an accumulator with parameterized width and ripple-carry adder

- code: |
    module moore(Clock, w, Resetn, z);
    input Clock, w, Resetn;
    output z;
    reg [1:0] y, Y;
    parameter A = 2'b00, B = 2'b01, C = 2'b10;
    always @(w or y)
    begin
        case (y)
            A: if (w == 0) Y = A;
               else Y = B;
            B: if (w == 0) Y = A;
               else Y = C;
            C: if (w == 0) Y = A;
               else Y = C;
            default: Y = 2'bxx;
        endcase
    end
    always @(posedge Clock or negedge Resetn)
    begin
        if (Resetn == 0)
            y <= A;
        else
            y <= Y;
    end
    assign z = (y == C);
    endmodule
  prompt: Implement a Moore FSM with three states using separate combinational and sequential blocks

- code: |
    module moore(Clock, w, Resetn, z);
    input Clock, w, Resetn;
    output z;
    reg [1:0] y;
    parameter A = 2'b00, B = 2'b01, C = 2'b10;
    always @(posedge Clock or negedge Resetn)
    begin
        if (Resetn == 0)
            y <= A;
        else
            case (y)
                A: if (w == 0) y <= A;
                   else y <= B;
                B: if (w == 0) y <= A;
                   else y <= C;
                C: if (w == 0) y <= A;
                   else y <= C;
                default: y <= 2'bxx;
            endcase
    end
    assign z = (y == C);
    endmodule
  prompt: Implement a Moore FSM with three states using combined sequential and combinational logic

- code: |
    module example2(x1, x2, x3, x4, x5, x6, x7, f);
    input x1, x2, x3, x4, x5, x6, x7;
    output f;
    assign f = (x1 & x3 & ~x6) | (x1 & x4 & x5 & ~x6) | (x2 & x3 & x7) | (x2 & x4 & x5 & x7);
    endmodule
  prompt: Implement a combinational circuit with specific minterms for seven inputs

- code: |
    module addern(carryin, X, Y, S, carryout);
    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;
    integer k;
    always @(X or Y or carryin)
    begin
        C[0] = carryin;
        for (k = 0; k <= n-1; k = k + 1)
        begin
            S[k] = X[k] ^ Y[k] ^ C[k];
            C[k+1] = (X[k] & Y[k]) | (C[k] & X[k]) | (C[k] & Y[k]);
        end
        carryout = C[n];
    end
    endmodule
  prompt: Implement a parameterized n-bit ripple-carry adder using behavioral modeling

- code: |
    module adderlpm(carryin, X, Y, S, carryout);
    input carryin;
    input [15:0] X, Y;
    output [15:0] S;
    output carryout;
    lpm_add_sub instance(.cin(carryin), .dataa(X), .datab(Y), .result(S), .cout(carryout));
    defparam instance.lpm_width = 16;
    endmodule
  prompt: Implement a 16-bit adder using an LPM add/subtract component

- code: |
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
  prompt: Implement a module that accumulates input data using a 4-bit register

- code: |
    module reg4(D, Clock, Reset, Q);
    input [3:0] D;
    input Clock, Reset;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Reset or posedge Clock)
        if (Reset)
            Q <= 0;
        else
            Q <= D;
    endmodule
  prompt: Implement a 4-bit register with active-high reset

- code: |
    module simple(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg [2:1] y, Y;
    parameter [2:1] A = 2'b00, B = 2'b01, C = 2'b10;
    always @(w or y)
        case (y)
            A: if (w) Y = B;
               else Y = A;
            B: if (w) Y = C;
               else Y = A;
            C: if (w) Y = C;
               else Y = A;
            default: Y = 2'bxx;
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    assign z = (y == C);
    endmodule
  prompt: Implement a Moore FSM with three states and separate combinational and sequential logic

- code: |
    module testbench ();
    generate data;
    process data;
    endmodule
  prompt: Implement a basic testbench structure for generating and processing data

- code: |
    module Chap1CounterTester ();
    reg Clk=0, Reset=0;
    wire [3:0] Count;
    initial begin
        Reset = 0; #5 Reset = 1; #115 Reset = 0;
        #760 $stop;
    end
    always #26.5 Clk = ~Clk;
    Chap1Counter U1 (Clk, Reset, Count);
    endmodule
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count = Count + 1;
    end
    endmodule
  prompt: Implement a 4-bit counter with a testbench to verify its functionality

- code: |
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count = Count + 1;
    end
    endmodule
  prompt: Implement a 4-bit up counter with synchronous reset

- code: |
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    endmodule
  prompt: Define a template for a data component with 8-bit input and output controlled by signals

- code: |
    module ControlUnit (Flags, Opcodes, ExternalControls, ControlSignals);
    input Flags, Opcodes, ExternalControls;
    output ControlSignals;
    endmodule
  prompt: Define a template for a control unit processing flags, opcodes, and external controls

- code: |
    module MultiplexerA (input a, b, s, output w);
    wire a_sel, b_sel, s_bar;
    not U1 (s_bar, s);
    and U2 (a_sel, a, s_bar);
    and U3 (b_sel, b, s);
    or U4 (w, a_sel, b_sel);
    endmodule
  prompt: Implement a 2-to-1 multiplexer using gate primitives

- code: |
    module MultiplexerB (input a, b, s, output w);
    assign w = (a & ~s) | (b & s);
    endmodule
  prompt: Implement a 2-to-1 multiplexer using a continuous assignment

- code: |
    module MultiplexerC (input a, b, s, output w);
    assign w = s ? b : a;
    endmodule
  prompt: Implement a 2-to-1 multiplexer using a conditional operator

- code: |
    module MultiplexerD (input a, b, s, output w);
    reg w;
    always @(a, b, s) begin
        if (s) w = b;
        else w = a;
    end
    endmodule
  prompt: Implement a 2-to-1 multiplexer using a procedural block

- code: |
    module ANDOR (input i1, i2, i3, i4, output y);
    assign y = (i1 & i2) | (i3 & i4);
    endmodule
  prompt: Implement a module combining AND and OR operations on four inputs

- code: |
    module MultiplexerE (input a, b, s, output w);
    wire s_bar;
    not U1 (s_bar, s);
    ANDOR U2 (a, s_bar, s, b, w);
    endmodule
  prompt: Implement a 2-to-1 multiplexer using an ANDOR module and inverter

- code: |
    `timescale 1ns/100ps
    module Mux8 (input sel, input [7:0] data1, data0, output [7:0] bus1);
    assign #6 bus1 = sel ? data1 : data0;
    endmodule
  prompt: Implement an 8-bit 2-to-1 multiplexer with 6ns delay

- code: |
    `timescale 1ns/100ps
    module Flop (reset, din, clk, qout);
    input reset, din, clk;
    output qout;
    reg qout;
    always @(negedge clk) begin
        if (reset) qout <= #8 1'b0;
        else qout <= #8 din;
    end
    endmodule
  prompt: Implement a 1-bit flip-flop with synchronous reset and negative-edge clock

- code: |
    module Counter4 (input reset, clk, output [3:0] count);
    reg [3:0] count;
    always @(negedge clk) begin
        if (reset) count <= #3 4'b00_00;
        else count <= #5 count + 1;
    end
    endmodule
  prompt: Implement a 4-bit up counter with negative-edge clock and reset

- code: |
    `timescale 1ns/100ps
    module full_adder (input a, b, cin, output sum, cout);
    assign #5 sum = a ^ b ^ cin;
    assign #3 cout = (a & b) | (a & cin) | (b & cin);
    endmodule
  prompt: Implement a full adder with specified delays for sum and carry outputs

- code: |
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule
  prompt: Implement an 8-bit shift register with multiple modes and negative-edge clock

- code: |
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always @(left, right, mode) begin
        case (mode)
            0: ALUout = left + right;
            1: ALUout = left - right;
            2: ALUout = left & right;
            3: ALUout = left | right;
            default: ALUout = 8'bX;
        endcase
    end
    endmodule
  prompt: Implement an 8-bit ALU with addition, subtraction, AND, and OR operations

- code: |
    `timescale 1ns/100ps
    module Synchronizer (input clk, adata, output reg synched);
    always @(posedge clk)
        if (adata == 0) synched <= 0; else synched <= 1;
    endmodule
  prompt: Implement a synchronizer for a single-bit data input

- code: |
    module Detector110 (input a, clk, reset, output w);
    parameter [1:0] s0=2'b00, s1=2'b01, s2=2'b10, s3=2'b11;
    reg [1:0] current;
    always @(posedge clk) begin
        if (reset) current = s0;
        else
            case (current)
                s0: if (a) current <= s1; else current <= s0;
                s1: if (a) current <= s2; else current <= s0;
                s2: if (a) current <= s2; else current <= s3;
                s3: if (a) current <= s1; else current <= s0;
            endcase
    end
    assign w = (current == s3) ? 1: 0;
    endmodule
  prompt: Implement a Moore FSM to detect the sequence 110

- code: |
    `timescale 1ns/100ps
    module Detector110Tester;
    reg aa, clock, rst;
    wire ww;
    Detector110 UUT (aa, clock, rst, ww);
    initial begin
        aa = 0; clock = 0; rst = 1;
    end
    initial repeat (44) #7 clock = ~clock;
    initial repeat (15) #23 aa = ~aa;
    initial begin
        #31 rst = 1;
        #23 rst = 0;
    end
    always @(ww) if (ww == 1)
        $display ("A 1 was detected on w at time = %t", $time);
    endmodule
  prompt: Implement a testbench for the 110 sequence detector

- code: |
    `timescale 1ns/100ps
    module Full_adder (input a, b, ci, output co, s);
    assign #4 co = a & b | a & ci | b & ci;
    assign #3 s = a ^ b ^ ci;
    endmodule
  prompt: Implement a full adder with different delays for carry and sum

- code: |
    module FulladderTester;
    reg a = 0, b = 0, ci = 0;
    wire co, s;
    parameter tlimit = 500;
    Full_adder MUT (a, b, ci, co, s);
    always begin
        if ($time >= tlimit) $stop;
        else begin
            #17;
            a = ~a;
            #13;
            ci = ~ci;
            #19;
            b = ~b;
        end
    end
    endmodule
  prompt: Implement a testbench for a full adder with periodic input changes

- code: |
    module FlipFlop (preset, reset, din, clk, qout);
    input preset, reset, din, clk;
    output qout;
    reg qout;
    always @(posedge clk) begin
        if (reset) qout <= #7 0;
        else if (preset) qout <= #7 1;
        else qout <= #8 din;
    end
    endmodule
  prompt: Implement a D flip-flop with synchronous preset and reset

- code: |
    module NumberTest;
    reg [11:0] a = 8'shA6; initial $displayb ("a=", a);
    reg [11:0] b = 8'sh6A; initial $displayb ("b=", b);
    reg [11:0] c = 'shA6; initial $displayb ("c=", c);
    reg [11:0] d = 'sh6A; initial $displayb ("d=", d);
    reg [11:0] e = -8'shA6; initial $displayb ("e=", e);
    reg [11:0] f = -'shA6; initial $displayb ("f=", f);
    reg [11:0] g = 9'shA6; initial $displayb ("g=", g);
    reg [11:0] h = 9'sh6A; initial $displayb ("h=", h);
    reg [11:0] i = -9'shA6; initial $displayb ("i=", i);
    reg [11:0] j = -9'sh6A; initial $displayb ("j=", j);
    reg [11:0] k = 596; initial $displayb ("k=", k);
    reg [11:0] l = -596; initial $displayb ("l=", l);
    endmodule
  prompt: Test various number formats and signed/unsigned representations in Verilog

- code: |
    module Mux2to1 (input a, b, c, output w);
    wire n, m, p;
    assign #3 m = a & b;
    assign #3 p = n & c;
    assign #6 n = ~b;
    assign #2 w = m | p;
    endmodule
  prompt: Implement a 2-to-1 multiplexer with delayed assignments

- code: |
    module Mux2to1Net (input a, b, c, output w);
    wire #3
        m = a & b,
        p = n & c,
        n = ~b,
        w = m | p;
    endmodule
  prompt: Implement a 2-to-1 multiplexer with concurrent net assignments

- code: |
    module Mux2to1Multiple (input a, b, c, output w);
    wire n;
    wor #2 w;
    assign #3 w = a & b;
    assign #3 w = n & c;
    assign #6 n = ~b;
    endmodule
  prompt: Implement a 2-to-1 multiplexer with wired-OR output

- code: |
    module FlipflopAssign (input reset, din, clk, output qout);
    reg qout;
    always @(reset) begin
        if (reset) assign qout <= 0;
        else deassign qout;
    end
    always @(posedge clk) begin
        qout <= din;
    end
    endmodule
  prompt: Implement a D flip-flop with asynchronous reset using assign/deassign

- code: |
    module quest1 (a, b, c, y);
    input [3:0] a, b, c;
    output [7:0] y;
    assign #3 a = 2'b2;
    assign #4 b = -3'b3;
    assign #1 y = ~c;
    assign #2 c = a ^ b;
    endmodule
  prompt: Implement a combinational circuit with fixed assignments and bitwise operations

- code: |
    module quest2 (a, b, w, y);
    input [3:0] a, b;
    output [7:0] y;
    output [11:0] w;
    assign #30 b = 1'hF;
    assign #40 y = {a, b};
    assign #50 w = {a, b, b[1:0], b[3:2]};
    endmodule
  prompt: Implement a module with concatenation and delayed assignments

- code: |
    module quest3 (a, b, w, y);
    input [3:0] a, b;
    output [7:0] y;
    wor [7:0] y;
    output [7:0] w;
    reg [7:0] w;
    assign #30 y = 8'h22;
    assign #20 y = {a, b};
    always @(a or b or y) #10 w = y;
    endmodule
  prompt: Implement a module with wired-OR output and procedural assignment

- code: |
    module quest4 (a, b, w, y);
    input [3:0] a, b;
    output [7:0] w, y;
    reg [7:0] w, y;
    always @(a or b) #17 w = {a, b};
    always @(a or b) y = #17 {a, b};
    endmodule
  prompt: Implement a module with dual procedural blocks for concatenation

- code: |
    module test;
    reg b, c, d;
    initial begin
        b=1'b1;
        c=1'b0;
        #10 b=1'b0;
    end
    initial d = #25 (b|c);
    endmodule
  prompt: Test timing control with initial blocks and logical operations

- code: |
    module test;
    wire a;
    reg x, y, z;
    assign #25 a = 1;
    always begin
        #20;
        x = #10 a;
        #3 y = a;
        #3 z = a;
        #7;
    end
    endmodule
  prompt: Test timing control with continuous and procedural assignments

- code: |
    module Anding (input a, b, output y);
    and (y, a, b);
    endmodule
  prompt: Implement a simple AND gate using a primitive

- code: |
    module TriMux (input i0, i1, sel, output y);
    wire sel_;
    not #5 g0 (sel_, sel);
    bufif1 #4
        g1 (y, i0, sel_),
        g2 (y, i1, sel);
    endmodule
  prompt: Implement a tri-state 2-to-1 multiplexer with delays

- code: |
    module TriMuxTest;
    reg i0=0, i1=0, s=0;
    wire y;
    TriMux MUT (i0, i1, s, y);
    initial begin
        #15 i1=1'b1;
        #15 s=1'b1;
        #15 s=1'b0;
        #15 i0=1'b1;
        #15 i0=1'b0;
        #15 $finish;
    end
    endmodule
  prompt: Implement a testbench for a tri-state multiplexer

- code: |
    module maj3 (a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    and #(2, 4)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(3, 5) (y, im1, im2, im3);
    endmodule
  prompt: Implement a 3-input majority circuit with gate delays

- code: |
    module xor3_mtm (input a, b, c, output y);
    wire a_, b_, c_;
    wire im1, im2, im3, im4;
    not #(1:3:5, 2:4:6)
        (a_, a),
        (b_, b),
        (c_, c);
    nand #(2:4:6, 3:5:7)
        (im1, a_, b_, c),
        (im2, a_, b, c_),
        (im3, a, b_, c_),
        (im4, a, b, c);
    nand #(2:4:6, 3:5:7) (y, im1, im2, im3, im4);
    endmodule
  prompt: Implement a 3-input XOR using NAND gates with min:typ:max delays

- code: |
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(tplh2, tphl2) (y, im1, im2, im3);
    endmodule
  prompt: Implement a 3-input majority circuit with parameterized delays

- code: |
    `timescale 1ns/100ps
    module xor3_p (input a, b, c, output y);
    wire a_, b_, c_;
    wire im1, im2, im3, im4;
    parameter
        tplh1=0.6, tphl1=1.1,
        tplh2=0.3, tphl2=0.9,
        tplh3=0.8, tphl3=1.3;
    not #(tplh1, tphl1)
        (a_, a),
        (b_, b),
        (c_, c);
    nand #(tplh2, tphl2)
        (im1, a_, b_, c),
        (im2, a_, b, c_),
        (im3, a, b_, c_),
        (im4, a, b, c);
    nand #(tplh3, tphl3) (y, im1, im2, im3, im4);
    endmodule
  prompt: Implement a 3-input XOR with parameterized min:typ:max delays

- code: |
    module add_1bit_p (input a, b, ci, output sum, co);
    xor3_p xr1 (a, b, ci, sum);
    maj3_p mj1 (a, b, ci, co);
    endmodule
  prompt: Implement a 1-bit full adder using parameterized XOR and majority modules

- code: |
    `timescale 1ns/100ps
    module add_1bit_p_named (input a, b, ci, output sum, co);
    xor3_p xr1 (.a(a), .b(b), .c(ci), .y(sum));
    maj3_p mj1 (.a(a), .b(b), .c(ci), .y(co));
    endmodule
  prompt: Implement a 1-bit full adder with named port connections

- code: |
    module add_4bit_vec (input [3:0] a, b, input ci,
    output [3:0] s, output co);
    wire c1, c2, c3;
    add_1bit_p fa[3:0] (a, b, {c3, c2, c1, ci}, s,
    {co, c3, c2, c1});
    endmodule
  prompt: Create a 4-bit adder using vector instantiation of a 1-bit adder module.

- code: |
    module add_4bit_gen (a, b, ci, s, co);
    parameter SIZE = 4;
    input [SIZE-1:0] a, b;
    input ci;
    output [SIZE-1:0] s;
    output co;
    wire [SIZE:0] carry;
    genvar i;
    assign carry[0] = ci;
    assign co = carry[SIZE];
    generate
    for (i=0; i<SIZE; i=i+1) begin : full_adders
    add_1bit_p fa (a[i], b[i], carry[i], s[i], carry[i+1]);
    end
    endgenerate
    endmodule
  prompt: Create a generic N-bit ripple-carry adder using a generate for loop (default N=4).

- code: |
    module add_4bit_genif (a, b, ci, s, co);
    parameter SIZE = 4;
    input [SIZE-1:0] a, b;
    input ci;
    output [SIZE-1:0] s;
    output co;
    wire [3:0] carry;
    genvar i;
    generate
    for (i=0; i<SIZE; i=i+1) begin : full_adders
    if (i==0) add_1bit_p fa (a[0], b[0], ci, s[0], carry[0]);
    else if (i==SIZE-1)
    add_1bit_p fa (a[i], b[i], carry[i-1], s[i]co);
    else add_1bit_p fa (a[i], b[i],
    carry[i-1], s[i], carry[i]);
    end
    endgenerate
    endmodule
  prompt: Create a generic N-bit ripple-carry adder using a generate for loop with conditional logic (default N=4).

- code: |
    module add_1bit_p2p (input a, b, ci, output sum, co);
    specify
    (a, b, ci *> co) = 12;
    (a, b, ci *> sum) = 15;
    endspecify
    xor3_p xr1 (a, b, ci, sum);
    maj3_p mj1 (a, b, ci, co);
    endmodule
  prompt: Create a 1-bit full adder module using XOR and Majority gate instances with specify path delays.

- code: |
    module add_4bit_p2p (input [3:0] a, b, input ci,
    output [3:0] s, output co);
    wire c1, c2, c3;
    specify
    (a *> s) = 31;
    (b *> s) = 32;
    (a, b, ci *> co) = 37;
    endspecify
    add_1bit_p fa0 (a[0], b[0], ci, s[0], c1);
    add_1bit_p fa1 (a[1], b[1], c1, s[1], c2);
    add_1bit_p fa2 (a[2], b[2], c2, s[2], c3);
    add_1bit_p fa3 (a[3], b[3], c3, s[3], co);
    endmodule
  prompt: Create a 4-bit ripple-carry adder by instantiating four 1-bit adders, including specify path delays.

- code: |
    module xor3 (input a, b, c, output y);
    assign y = a ^ b ^ c;
    endmodule
  prompt: Create a 3-input XOR gate using a continuous assign statement.

- code: |
    module maj3 (input a, b, c, output y);
    assign #(4) y = ( a & b ) | ( b & c ) | ( a & c );
    endmodule
  prompt: Create a 3-input majority gate using a continuous assign statement with a 4ns delay.

- code: |
    module add_1bit (input a, b, ci, output s, co);
    assign #(10) s = a ^ b ^ ci;
    assign #(8) co = ( a & b ) | ( b & ci ) | ( a & ci );
    endmodule
  prompt: Create a 1-bit full adder using two continuous assign statements with delays (10ns for sum, 8ns for carry-out).

- code: |
    module add_1bit (input a, b, ci, output s, co);
    assign #(3, 4) {co, s} = {(a & b)|(b & ci)|(a & ci), a^b^ci};
    endmodule
  prompt: Create a 1-bit full adder using a single continuous assign statement with concatenation and rise/fall delays (3ns rise, 4ns fall).

- code: |
    module comp_4bit (input [3:0] a, b, output eq );
    wire [3:0] im;
    assign im = a ^ b;
    assign eq = ~|im;
    endmodule
  prompt: Create a 4-bit equality comparator using XOR and reduction NOR operators.

- code: |
    module parity_gen (input [7:0] a, output even, odd);
    assign #(3, 4)
    even = ^a,
    odd = ~^a;
    endmodule
  prompt: Create an 8-bit parity generator (even and odd) using reduction XOR with rise/fall delays.

- code: |
    module quad_mux2_1 (input [3:0] i0, i1, input s,
    output [3:0] y);
    assign y = s ? i1 : i0;
    endmodule
  prompt: Create a 4-bit 2-to-1 multiplexer using the conditional operator in an assign statement.

- code: |
    module test_quad_mux2_1;
    reg [3:0] i0, i1;
    reg s;
    wire [3:0] y;
    quad_mux2_1 MUT (i0, i1, s, y);
    initial begin
    i0=4âb1010; i1=4âb0101; s=1âb0;
    #20 i0=4âb0000;
    #20 s=1âb1;
    #20 i1=4âb1111;
    #20 i0=4âb0z11; i1=4âb1z1x; s=1âbz;
    #20 $finish;
    end
    endmodule
  prompt: Create a testbench for the 4-bit 2-to-1 multiplexer (`quad_mux2_1`).

- code: |
    module dcd2_4 (input a, b, output d0, d1, d2, d3 );
    assign
    {d3, d2, d1, d0} = ( {a, b} == 2âb00 ) ? 4âb0001 :
    ( {a, b} == 2âb01 ) ? 4âb0010 :
    ( {a, b} == 2âb10 ) ? 4âb0100 :
    ( {a, b} == 2âb11 ) ? 4âb1000 :
    4âb0000;
    endmodule
  prompt: Create a 2-to-4 decoder using nested conditional operators in an assign statement.

- code: |
    module comp_4bit ( input [3:0] a, b,
    output a_gt_b, a_eq_b, a_lt_b);
    assign
    a_gt_b = (a>b),
    a_eq_b = (a==b),
    a_lt_b = (a<b);
    endmodule
  prompt: Create a 4-bit magnitude comparator (gt, eq, lt outputs) using relational and equality operators.

- code: |
    module comp_4bit (input [3:0] a, b, input gt, eq, lt,
    output a_gt_b, a_eq_b, a_lt_b );
    assign
    a_gt_b = (a==b) ? gt : (a>b),
    a_eq_b = (a==b) ? eq : 1âb0,
    a_lt_b = (a==b) ? lt : (a<b);
    endmodule
  prompt: Create a cascadable 4-bit magnitude comparator using conditional operators and cascading inputs.

- code: |
    module add_4bit (input [3:0] a, b, input ci,
    output [3:0] s, output co);
    assign { co, s } = a + b + ci;
    endmodule
  prompt: Create a 4-bit adder using the Verilog arithmetic addition operator.

- code: |
    module add_1bit_f (input a, b, ci, output s, co );
    function [1:0] adder (input a, b, c);
    begin
    adder = {(a & b)|(b & c)|(a & c), a^b^c };
    end
    endfunction
    assign #(3, 4) {co, s} = adder ( a, b, ci );
    endmodule
  prompt: Create a 1-bit full adder using a Verilog function called within an assign statement, with rise/fall delays.

- code: |
    module mux2_1 (input i0, i1, s, output y);
    wire #(0.6, 0.8)
    im0 = i0 & ~s,
    im1 = i1 & s;
    assign #(3, 4) y = im0 | im1;
    endmodule
  prompt: Create a 2-to-1 multiplexer using explicit AND/OR logic with delays on intermediate wires and the final output.

- code: |
    module xor3 (input a, b, c, output y);
    reg y;
    always @(a, b, c)
    y = a ^ b ^ c;
    endmodule
  prompt: Create a 3-input XOR gate using a combinational always block.

- code: |
    module maj3 (input a, b, c, output reg y);
    always @(a, b, c)
    begin
    y = (a & b) | (b &c) | (a & c);
    end
    endmodule
  prompt: Create a 3-input majority gate using a combinational always block with begin/end.

- code: |
    module maj3 (input a, b, c, output reg y);
    always begin
    @(a, b, c)
    y = (a & b) | (b & c) | (a & c);
    end
    endmodule
  prompt: Create a 3-input majority gate using an always block with the sensitivity list inside the block.

- code: |
    module maj3 (input a, b, c, output reg y);
    always @(a, b, c) #5 y = (a & b) | (b &c) | (a & c);
    endmodule
  prompt: Create a 3-input majority gate using a combinational always block with a 5ns intra-assignment delay.

- code: |
    module maj3 (input a, b, c, output reg y);
    always @(a, b, c) y = #5 (a & b) | (b &c) | (a & c);
    endmodule
  prompt: Create a 3-input majority gate using a combinational always block with a 5ns intra-assignment delay (alternative syntax).

- code: |
    module add_1bit (input a, b, ci, output s, co );
    reg s, co;
    always @(a, b, ci)
    begin
    s = #5 a ^ b ^ ci;
    co = #3 (a & b) | (b &ci) | (a & ci);
    end
    endmodule
  prompt: Create a 1-bit full adder using a single always block with blocking assignments and different intra-assignment delays.

- code: |
    module add_1bit (input a, b, ci, output s, co );
    reg s, co;
    always @(a, b, ci) begin
    s <= #5 a ^ b ^ ci;
    co <= #3 (a & b) | (b &ci) | (a & ci);
    end
    endmodule
  prompt: Create a 1-bit full adder using a single always block with non-blocking assignments and different intra-assignment delays.

- code: |
    module add_1bit (input a, b, ci, output reg s, co );
    always @(a, b, ci) #3 co = (a & b) | (b &ci) | (a & ci);
    always @(a, b, ci) #5 s = a ^ b ^ ci;
    endmodule
  prompt: Create a 1-bit full adder using two separate always blocks, one for sum and one for carry-out, with different delays.

- code: |
    module mux2_1 (input i0, i1, s, output reg y);
    always @(i0, i1, s) begin
    if (s==1âb0)
    y = i0;
    else
    y = i1;
    end
    endmodule
  prompt: Create a 2-to-1 multiplexer using a combinational always block with an if/else statement.

- code: |
    module add_sub_4bit (input [3:0] a, b, input ci, m,
    output reg [3:0] s, output reg co );
    always @(a, b, ci, m)
    if ( m )
    { co, s } = a + b + ci;
    else
    { co, s } = a - b - ci;
    endmodule
  prompt: Create a 4-bit adder/subtractor controlled by an input 'm', using an always block and if/else.

- code: |
    module dcd2_4 (input a, b, output reg d0, d1, d2, d3 );
    always @(a, b) begin
    case ( { a, b } )
    2âb00 : { d3, d2, d1, d0 } = 4âb0001;
    2âb01 : { d3, d2, d1, d0 } = 4âb0010;
    2âb10 : { d3, d2, d1, d0 } = 4âb0100;
    2âb11 : { d3, d2, d1, d0 } = 4âb1000;
    default: { d3, d2, d1, d0 } = 4âb0000;
    endcase
    end
    endmodule
  prompt: Create a 2-to-4 decoder using a combinational always block with a case statement.

- code: |
    module alu_n_bit (a, b, f, y );
    parameter N=4;
    input [N-1:0] a, b;
    input [1:0] f;
    output [N-1:0] y;
    reg [N-1:0] y;
    always @ (a, b, f)
    begin
    casez ( f )
    2âb00 : y = a + b;
    2âb01 : y = a - b;
    2âb10 : y = a & b;
    2âb11 : y = a ^ b;
    default: y = 0;
    endcase
    end
    endmodule
  prompt: Create a generic N-bit ALU (default N=4) performing add, subtract, AND, XOR based on a function select input, using an always block and casez statement.

- code: |
    module priority_encoder (input i0, i1, i2, i3,
    output reg y1, y0, f);
    wire [3:0] im = { i3, i2, i1, i0 };
    reg [2:0] indx;
    always @(im) begin
    { y1, y0 } = 2âb00;
    f = 1âb0;
    for (indx=0; indx<4; indx=indx+1)
    begin
    if ( im[indx] )
    begin
    { y1, y0 } = indx;
    f = 1âb1;
    end
    end
    end
    endmodule
  prompt: Create a 4-to-2 priority encoder (highest index has highest priority) using an always block and a for loop.

- code: |
    module alu_4bit (a, b, f, oe, y, p, ov, a_gt_b,
    a_eq_b, a_lt_b);
    input [3:0] a, b;
    input [1:0] f;
    input oe;
    output [3:0] y;
    output p, ov, a_gt_b, a_eq_b, a_lt_b;
    reg ov, a_gt_b, a_eq_b, a_lt_b;
    reg [4:0] im_y;
    always @( a or b or f ) begin : arithmethic
    ov = 1âb0;
    im_y = 0;
    case ( f )
    2âb00 :
    begin
    im_y = a + b;
    if ( im_y>5âb01111 ) ov = 1âb1;
    end
    2âb01 :
    begin
    im_y = a - b;
    if ( im_y>5âb01111 ) ov = 1âb1;
    end
    2âb10 : im_y[3:0] = a & b;
    2âb11 : im_y[3:0] = a ^ b;
    default: im_y[3:0] = 4âb0000;
    endcase
    end
    always @( a or b ) begin : compare
    if ( a > b ) { a_gt_b, a_eq_b, a_lt_b } = 3âb100;
    else if ( a < b ) { a_gt_b, a_eq_b, a_lt_b } = 3âb001;
    else { a_gt_b, a_eq_b, a_lt_b } = 3âb010;
    end
    assign p = ^ im_y[3:0];
    assign y = oe ? im_y[3:0] : 4âbz;
    endmodule
  prompt: Create a 4-bit ALU performing add, subtract, AND, XOR, plus comparison, parity, overflow, and output enable.

- code: |
    module fa_1bit ( x, y, ci, s, co );
    input x, y, ci;
    output s, co;
    wire im1, im2, im3;
    xor ( s, x, y, ci );
    and ( im1, x, y ),
    ( im2, y, ci ),
    ( im3, ci, x );
    or ( co, im1, im2, im3 );
    endmodule
  prompt: Create a structural 1-bit full adder using primitive Verilog gates (xor, and, or).

- code: |
    module compartor ( a, b, gt, eq, lt );
    input [3:0] a, b;
    output gt, eq, lt;
    assign gt = (a>b) ? 1âb1 : 1âb0;
    assign eq = (a==b) ? 1âb1 : 1âb0;
    assign lt = (a<b) ? 1âb1 : 1âb0;
    endmodule
  prompt: Create a 4-bit magnitude comparator (gt, eq, lt outputs) using assign statements.

- code: |
    module alu ( a, b, add_sub, func, y, co, gt, eq, lt, ov );
    input [3:0] a, b;
    input add_sub;
    input [1:0] func;
    output [3:0] y;
    reg [3:0] y;
    output co, gt, eq, lt, ov;
    reg co;
    always @( a or b or add_sub or func ) : arithmetic
    case (func)
    2âb00 :
    if (add_sub) { co, y } = a - b;
    else { co, y } = a + b;
    2âb01 : { co, y } = { 1âb0, a };
    2âb10 : { co, y } = { 1âb0, a & b };
    2âb11 : { co, y } = { 1âb0, ~a };
    default: { co, y } = , 5âb00000 ;
    endcase
    compartor cmp ( a, b, gt, eq, lt );
    assign ov = (func==2âb00)
    ? ((a[3] & b[3] & ~y[3]) | (~a[3] & ~b[3] & y[3]))
    : 1âb0;
    endmodule
  prompt: Create a 4-bit ALU performing add/subtract, pass-through, AND, NOT, including comparison (instantiating `compartor`) and overflow logic.

- code: |
    module infer (q, d, e, c);
    input d, c;
    output q;
    reg q;
    always @(c, d, e)
    if (c == 1 && e == 0) q = d; else q = 1;
    endmodule
  prompt: Infer a latch-like element where q gets d if c is high and e is low, otherwise q becomes 1.

- code: |
    module latch (input s, r, output q, q_b );
    nor #(4)
    g1 ( q_b, s, q ),
    g2 ( q, r, q_b );
    endmodule
  prompt: Create a structural SR latch using two cross-coupled NOR gates with a delay of 4.

- code: |
    module latch_p #(parameter tplh=3, tphl=5) (input s, r, c,
    output q, q_b );
    wire _s, _r;
    nand #(tplh,tphl)
    g1 ( _s, s, c ),
    g2 ( _r, r, c ),
    g3 ( q, _s, q_b ),
    g4 ( q_b, _r, q );
    endmodule
  prompt: Create a parameterized structural gated SR latch using four NAND gates with configurable rise/fall delays.

- code: |
    module master_slave (input d, c, output q, q_b );
    wire qm, qm_b;
    defparam master.tplh=4, master.tphl=4, slave.tplh=4,
    slave.tphl=4;
    latch_p
    master ( d, ~d, c, qm, qm_b ),
    slave ( qm, qm_b, ~c, q, q_b );
    endmodule
  prompt: Create a master-slave D flip-flop by instantiating two parameterized gated latches (`latch_p`) with fixed delays using `defparam`.

- code: |
    module master_slave_p #(parameter delay=3) (input d,c, output q);
    wire qm;
    assign #(delay) qm = c ? d : qm;
    assign #(delay) q = ~c ? qm : q;
    endmodule
  prompt: Create a parameterized behavioral master-slave D flip-flop using two assign statements with configurable delays.

- code: |
    module latch (input d, c, output reg q, q_b );
    always @( c or d )
    if ( c ) begin
    #4 q = d;
    #3 q_b = ~d;
    end
    endmodule
  prompt: Create a behavioral D latch (level-sensitive) using an always block with blocking assignments and delays.

- code: |
    module latch (input d, c, output reg q, q_b );
    always @( c or d )
    if ( c ) begin
    q <= #4 d;
    q_b <= #3 ~d;
    end
    endmodule
  prompt: Create a behavioral D latch (level-sensitive) using an always block with non-blocking assignments and delays.

- code: |
    module d_ff (input d, clk, output reg q, q_b );
    always @( posedge clk ) begin
    q <= #4 d;
    q_b <= #3 ~d;
    end
    endmodule
  prompt: Create a behavioral positive edge-triggered D flip-flop using non-blocking assignments with delays.

- code: |
    module d_ff_sr_Synch (input d, s, r, clk, output reg q, q_b );
    always @(posedge clk) begin
    if( s ) begin
    q <= #4 1âb1;
    q_b <= #3 1âb0;
    end else if( r ) begin
    q <= #4 1âb0;
    q_b <= #3 1âb1;
    end else begin
    q <= #4 d;
    q_b <= #3 ~d;
    end
    end
    endmodule
  prompt: Create a behavioral positive edge-triggered D flip-flop with synchronous set (s) and reset (r).

- code: |
    module d_ff_sr_Asynch (input d, s, r, clk, output reg q, q_b );
    always @( posedge clk, posedge s, posedge r ) begin
    if( s ) begin
    q <= #4 1âb1;
    q_b <= #3 1âb0;
    end else if( r ) begin
    q <= #4 1âb0;
    q_b <= #3 1âb1;
    end else begin
    q <= #4 d;
    q_b <= #3 ~d;
    end
    end
    endmodule
  prompt: Create a behavioral D flip-flop with asynchronous, positive edge-triggered set (s) and reset (r).

- code: |
    module latch (input d, c, output reg q, q_b );
    always begin
    wait ( c );
    #4 q <= d;
    #3 q_b <= ~d;
    end
    endmodule
  prompt: Create a behavioral D latch using a `wait(c)` statement for level sensitivity.

- code: |
    module d_ff (input d, clk, output reg q, q_b );
    always @( posedge clk )
    fork
    #4 q <= d;
    #3 q_b <= ~d;
    join
    endmodule
  prompt: Create a behavioral positive edge-triggered D flip-flop using fork-join for concurrent non-blocking assignments with delays.

- code: |
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    #6 assign q = 1âb1;
    #4 assign q_b = 1âb0;
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    #6 assign q = 1âb0;
    #4 assign q_b = 1âb1;
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    #4 q = d;
    #3 q_b = ~d;
    end
    endmodule
  prompt: Create a D flip-flop with asynchronous set/reset using `assign`/`deassign` and a separate clocked process.

- code: |
    module d_ff ( input d, clk, s, r, output reg q, q_b );
    specify
    $setup ( d, posedge clk, 5 );
    endspecify
    always @( posedge clk or posedge s or posedge r ) begin
    if( s ) begin
    q <= #4 1âb1;
    q_b <= #3 1âb0;
    end else if( r ) begin
    q <= #4 1âb0;
    q_b <= #3 1âb1;
    end else begin
    q <= #4 d;
    q_b <= #3 ~d;
    end
    end
    endmodule
  prompt: Create a D flip-flop with asynchronous set/reset and a `$setup` timing check.

- code: |
    module d_ff ( input d, clk, s, r, output reg q, q_b );
    specify
    $hold ( posedge clk, d, 3 );
    endspecify
    always @( posedge clk or posedge s or posedge r ) begin
    if( s ) begin
    q <= #4 1âb1;
    q_b <= #3 1âb0;
    end else if( r ) begin
    q <= #4 1âb0;
    q_b <= #3 1âb1;
    end else begin
    q <= #4 d;
    q_b <= #3 ~d;
    end
    end
    endmodule
  prompt: Create a D flip-flop with asynchronous set/reset and a `$hold` timing check.

- code: |
    module d_ff ( input d, clk, s, r, output reg q, output q_b );
    specify
    $setuphold ( posedge clk, d, 5, 3 );
    $width (posedge r, 4);
    $width (posedge s, 4);
    $period (negedge clk, 43);
    endspecify
    always @( posedge clk or posedge s or posedge r )
    if( s ) q <= #4 1âb1;
    else if( r ) q <= #4 1âb0;
    else q <= #4 d;
    assign #2 q_b = ~q;
    endmodule
  prompt: Create a D flip-flop with asynchronous set/reset and `$setuphold`, `$width`, and `$period` timing checks.

- code: |
    module vector_latch (input [7:0] d, input c, output reg [7:0] q);
    always @( c or d )
    if( c )
    #4 q = d;
    endmodule
  prompt: Create a behavioral 8-bit D latch with a delay.

- code: |
    module vector_ff (input [7:0] d, input clk, rst, oe,
    output [7:0] q);
    reg [7:0] internal_q;
    always @( posedge clk )
    if( rst )
    #4 internal_q <= 8âb0000_0000;
    else
    #4 internal_q <= d;
    assign q = oe ? internal_q : 8âbZ;
    endmodule
  prompt: Create a behavioral 8-bit D flip-flop with synchronous reset and tristate output enable.

- code: |
    module sizable_reg #(size) ( input [size-1:0] d, input clk, rst,
    output reg [size-1:0] q );
    always @( posedge clk, negedge rst )
    begin
    if( ~rst )
    #4 q <= 0;
    else
    #4 q <= d;
    end
    endmodule
  prompt: Create a parameterizable N-bit register with asynchronous active-low reset.

- code: |
    module Memory_2Power_M_by_N #(parameter M=3, N=4)
    (input [M-1:0] adr, input rd, wr, inout [N-1:0] data);
    reg [N-1:0] mem [0:2**M-1];
    reg [N-1:0] temp;
    assign data = rd ? temp : âbZ;
    always @( data, adr, rd, wr )
    begin
    if( wr )
    #4 mem[adr] = data;
    else if( rd )
    #4 temp = mem[adr];
    else
    #4 temp = âbZ;
    end
    initial $readmemh(âmem.datâ, mem);
    endmodule
  prompt: Create a parameterizable behavioral memory (2^M words x N bits) with read/write control, tristate data bus, and initialization from "mem.dat".

- code: |
    module pla ( in, out );
    input [7:0]in;
    output [3:0]out;
    reg [3:0]out;
    reg [1:8] mem[1:4];
    initial begin
    $readmemb (âpla.datâ, mem);
    // Contents of pla.dat external file:
    //11000000
    //10110100
    //00001100
    //00000111
    $async$nand$array ( mem,
    {in[7],in[6],in[5],in[4],in[3],in[2],in[1],in[0]},
    {out[3],out[2],out[1],out[0]} );
    end
    endmodule
  prompt: Implement a behavioral PLA using `$readmemb` for initialization and the `$async$nand$array` system task.

- code: |
    module shift_reg (input [3:0] d, input clk, ld, rst, l_r, s_in,
    output reg [3:0] q);
    always @( posedge clk ) begin
    if( rst )
    #5 q <= 4âb0000;
    else if( ld )
    #5 q <= d;
    else if( l_r )
    #5 q <= {q[2:0], s_in};
    else
    #5 q <= {s_in, q[3:1]};
    end
    endmodule
  prompt: Create a 4-bit shift register with synchronous reset, load, left/right shift controlled by `l_r`, and serial input `s_in`.

- code: |
    module shift_reg (input clk, rst, r_in, l_in, en, s1, s0,
    inout [7:0] io);
    reg [7:0] q_int;
    assign io = (en) ? q_int : 8âbz;
    always @( posedge clk ) begin
    if( rst )
    #5 q_int = 8âb0;
    else
    case ( {s1,s0} )
    2âb01 : // Shift right
    q_int <= { r_in, q_int[7:1] };
    2âb10 : // Shift left
    q_int <= { q_int[6:0], l_in };
    2âb11 : // Parallel load
    q_int = io;
    default : // Do nothing
    q_int <= q_int;
    endcase
    end
    endmodule
  prompt: Create an 8-bit universal shift register (shift left/right, parallel load, hold) with tristate bidirectional I/O, controlled by `s1`, `s0`.

- code: |
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,
    input [1:0] s_cnt, output reg [3:0] q);
    reg [3:0] int_q;
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = q >> s_cnt;
    else if( sl )
    int_q = q << s_cnt;
    else int_q = q;
    end
    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else q <= int_q;
    end
    endmodule
  prompt: Create a 4-bit barrel shifter/register with parallel load, synchronous reset, and variable shift amount (`s_cnt`).

- code: |
    module counter (input [3:0] d_in, input clk, rst, ld, u_d,
    output reg [3:0] q);
    always @( posedge clk ) begin
    if( rst )
    q = 4âb0000;
    else if( ld )
    q = d_in;
    else if( u_d )
    q = q + 1;
    else
    q = q - 1;
    end
    endmodule
  prompt: Create a 4-bit synchronous up/down counter with parallel load and synchronous reset.

- code: |
    module gray_counter (input [3:0] d_in, input clk, rst, ld,
    output reg [3:0] q);
    reg [3:0] mem[0:15];
    reg [3:0] im_q;
    initial
    $readmemb(âmem.datâ, mem);
    always @( d_in or ld or q ) begin: combinational
    if( ld )
    im_q = d_in;
    else
    im_q = mem[q];
    end
    always @( posedge clk ) begin: register
    if( rst )
    q <= 4âb0000;
    else
    q <= im_q;
    end
    endmodule
  prompt: Create a 4-bit Gray code counter using a lookup table (initialized from "mem.dat") with parallel load and synchronous reset.

- code: |
    module dff (input clk, set, rst, d, output reg q);
    always @(posedge clk or posedge set or posedge rst)
    if( set )
    q <= 1âb1;
    else if( rst )
    q <= 1âb0;
    else
    q <= d;
    endmodule
  prompt: Create a simple D flip-flop with asynchronous, positive edge-triggered set and reset.

- code: |
    module structural_lfsr #(parameter [3:0] seed=4âb0)
    (input clk, init, sin, output sout);
    wire im1, im2, im3, im4, im5;
    dff ff[3:0] ( clk, {4{init}}&seed, {4{init}}&~seed,
    {im1,im2,im4,im5}, {im2,im3,im5,sout} );
    xor ( im1, sin, sout );
    xor ( im4, im3, sout );
    endmodule
  prompt: Create a structural 4-bit Linear Feedback Shift Register (LFSR) using `dff` instances and XOR gates, with a parameterizable seed and initialization input.

- code: |
    module behavioral_lfsr #(parameter [3:0] poly=0, seed=0)
    (input clk, init, sin, output reg sout );
    reg [3:0] im_data;
    always @( posedge clk or posedge init )
    begin
    if( init )
    im_data = seed;
    else
    im_data = { sin^ im_data[0],
    im_data[3:1] ^ (poly[2:0] & {3{im_data[0]}} };
    sout = im_data[0];
    end
    endmodule
  prompt: Create a behavioral Linear Feedback Shift Register (LFSR) with parameterizable polynomial and seed, and initialization input.

- code: |
    module fifo (input [7:0] data_in, input clk, rst, rd, wr,
    output empty, full, output reg [3:0]fifo_cnt,
    output reg [7:0] data_out);
    reg [7:0] fifo_ram[0:7];
    reg [2:0] rd_ptr, wr_ptr;
    assign empty = (fifo_cnt==0);
    assign full = (fifo_cnt==8);
    always @( posedge clk ) begin: write
    if(wr && !full)
    fifo_ram[wr_ptr] <= data_in;
    else if(wr && rd)
    fifo_ram[wr_ptr] <= data_in;
    end
    always @( posedge clk ) begin: read
    if(rd && !empty)
    data_out <= fifo_ram[rd_ptr];
    else if(rd && wr && empty)
    data_out <= fifo_ram[rd_ptr];
    end
    always @( posedge clk ) begin: pointer
    if( rst ) begin
    wr_ptr <= 0;
    rd_ptr <= 0;
    end else begin
    wr_ptr <= ((wr && !full)||(wr && rd)) ? wr_ptr+1 :
    wr_ptr;
    rd_ptr <= ((rd && !empty)||(wr && rd)) ? rd_ptr+1 :
    rd_ptr;
    end
    end
    always @( posedge clk ) begin: count
    if( rst ) fifo_cnt <= 0;
    else begin
    case ({wr,rd})
    2âb00 : fifo_cnt <= fifo_cnt;
    2âb01 : fifo_cnt <= (fifo_cnt==0) ? 0 : fifo_cnt-1;
    2âb10 : fifo_cnt <= (fifo_cnt==8) ? 8 : fifo_cnt+1;
    2âb11 : fifo_cnt <= fifo_cnt;
    default: fifo_cnt <= fifo_cnt;
    endcase
    end
    end
    endmodule
  prompt: Create an 8x8 behavioral FIFO with read/write pointers, full/empty flags, and count logic handling simultaneous read/write.

- code: |
    module moore_detector (input x, rst, clk, output z);
    localparam [1:0]
    reset=0, got1=1, got10=2, got101=3;
    reg [1:0] current;
    always @( posedge clk ) begin
    if( rst ) current <= reset;
    else case ( current )
    reset: begin
    if( x==1âb1 ) current <= got1;
    else current <= reset;
    end
    got1: begin
    if( x==1âb0 ) current <= got10;
    else current <= got1;
    end
    got10: begin
    if( x==1âb1 ) current <= got101;
    else current <= reset;
    end
    got101: begin
    if( x==1âb1 ) current <= got1;
    else current <= got10;
    end
    default: begin
    current <= reset;
    end
    endcase
    end
    assign z = (current==got101) ? 1 : 0;
    endmodule
  prompt: Implement a Moore Finite State Machine (FSM) using `localparam` to detect the input sequence "101".

- code: |
    module moore_detector3 (input x, rst, clk, output z);
    reg [2:0] current;
    // Assumes defines like `define reset 3'b000, `define got1 3'b001, etc.
    always @( posedge clk or posedge rst ) begin
    if( rst ) current = `reset;
    else
    case ( current )
    `reset:
    if( x==1âb1 ) current <= `got1;
    else current <= `reset;
    `got1:
    if( x==1âb0 ) current <= `got10;
    else current <= `got11;
    `got10:
    if( x==1âb1 ) current <= `got101;
    else current <= `reset;
    `got11:
    if( x==1âb1 ) current <= `got11;
    else current <= `got110;
    `got101:
    if( x==1âb1 ) current <= `got11;
    else current <= `got10;
    `got110:
    if( x==1âb1 ) current <= `got101;
    else current <= `reset;
    default:
    // Assuming default should go to a known state, not got101
    current <= `reset;
    endcase
    end
    assign z = (current == `got101 || current == `got110);
    endmodule
  prompt: Implement a Moore FSM (using assumed `defines` for states) to detect sequences ending in "101" or "110".

- code: |
    module mealy_detector2 (input x, rst, clk, output z);
    localparam [1:0]
    reset = 0, // 0 = 0 0
    got1 = 1, // 1 = 0 1
    got10 = 2; // 2 = 1 0
    reg [1:0] current;
    always @( posedge clk ) begin
    if (rst) current <= reset;
    else case ( current )
    reset:
    if( x==1âb1 ) current <= got1;
    else current <= reset;
    got1:
    if( x==1âb0 ) current <= got10;
    else current <= got1;
    got10:
    if( x==1âb1 ) current <= got1;
    else current <= reset;
    default:
    current <= reset;
    endcase
    end
    assign z = ( current==got10 && x==1âb1 ) ? 1âb1 : 1âb0;
    endmodule
  prompt: Implement a Mealy FSM using `localparam` to detect the input sequence "101" (output depends on state and input).

- code: |
    module mealy_detector7 (input x, clk, rst, output z);
    localparam [1:0]
    reset=2âb00, got1=2âb01, got10=2âb10, got11=2âb11;
    reg [1:0] p_state;
    wire [1:0] n_state;
    reg [2:0] mem[0:7];
    initial
    $readmemb( âmealy.datâ, mem );
    assign { z, n_state } = mem[{ x, p_state }];
    always @( posedge clk ) begin:sequential
    if( rst ) p_state <= reset;
    else p_state <= n_state;
    end
    endmodule
  prompt: Implement a Mealy FSM using a memory lookup table (initialized from "mealy.dat") for state transitions and output logic based on input and present state.

- code: |
    module mult (a, b, start, clk, r, done);
    input [7:0] a, b;
    input start, clk;
    output [15:0] r;
    output done;
    reg [7:0] abuf, bbuf; // use these if you like
    reg [15:0] r;
    // . . . internals omitted . . .
    endmodule
  prompt: Define the module interface for an 8x8 multiplier with start and done signals (internals omitted).

- code: |
    module memory (mem_wr, mem_rd, databus, adbus);
    input mem_wr, mem_rd;
    inout [7:0] databus ;
    input [15:0] adbus;
    // . . . internals omitted . . .
    endmodule
  prompt: Define the module interface for a memory with read/write controls, 8-bit bidirectional data bus, and 16-bit address bus (internals omitted).

- code: |
    module alu_4bit (a, b, f, oe, y, p, ov, a_gt_b, a_eq_b,
    a_lt_b);
    input [3:0] a, b;
    input [1:0] f;
    input oe;
    output [3:0] y;
    output p, ov, a_gt_b, a_eq_b, a_lt_b;
    // . . . internals omitted . . .
    endmodule
  prompt: Define the module interface for the `alu_4bit` module (reference block, internals omitted).

- code: |
    module test_alu_4bit;
    reg [3:0] a=4âb1011, b=4âb0110;
    reg [1:0] f=2âb00;
    reg oe=1;
    wire [3:0] y;
    wire p, ov, a_gt_b, a_eq_b, a_lt_b;
    alu_4bit cut( a, b, f, oe, y, p, ov, a_gt_b, a_eq_b,
    a_lt_b );
    initial begin
    #20 b=4âb1011;
    #20 b=4âb1110;
    #20 b=4âb1110; // Note: Duplicate assignment
    #80 oe=1âb0;
    #20 $finish;
    end
    always #23 f = f + 1;
    endmodule
  prompt: Create a testbench for the `alu_4bit` module, applying stimulus via initial and always blocks and finishing simulation.

- code: |
    module #(parameter [3:0] poly=0) misr (input clk, rst,
    input [3:0] d_in, output reg [3:0] d_out );
    always @( posedge clk )
    if( rst )
    d_out =4âb0000;
    else
    d_out = d_in ^ ({4{d_out[0]}} & poly) ^
    {1âb0,d_out[3:1]};
    endmodule
  prompt: Create a behavioral Multiple Input Signature Register (MISR) with a parameterizable polynomial and synchronous reset.

- code: |
    module test_misr;
    reg clk=0, rst=0;
    reg [3:0] d_in;
    wire [3:0] d_out;
    misr #(4âb1100) MUT ( clk, rst, d_in, d_out );
    initial begin
    #13 rst=1âb1;
    #19 d_in=4âb1000; // Assign d_in while reset is active
    #31 rst=0âb0;
    #330 $finish;
    end
    always #37 d_in = d_in + 3;
    always #11 clk = ~clk;
    endmodule
  prompt: Create a testbench for the `misr` module, instantiating it with a specific polynomial, generating clock and stimulus, and applying reset.

- code: |
    module moore_detector (input x, rst, clk, output z );
    parameter [1:0] a=0, b=1, c=2, d=3;
    reg [1:0] current;
    always @( posedge clk )
    if ( rst ) current = a;
    else case ( current )
    a : current = x ? b : a ;
    b : current = x ? b : c ;
    c : current = x ? d : a ;
    d : current = x ? b : c ;
    default : current = a ;
    endcase
    assign z = (current==d) ? 1âb1 : 1âb0;
    endmodule
  prompt: Implement a Moore FSM using parameters to detect the input sequence "101" (alternative implementation).

- code: |
    module test_moore_detector;
    reg x, reset, clock;
    wire z;
    moore_detector MUT ( x, reset, clock, z );
    initial begin
    clock=1âb0; x=1âb0; reset=1âb1;
    end
    initial #24 reset=1âb0;
    always #5 clock=~clock;
    always #7 x=~x;
    endmodule
  prompt: Create a basic testbench for the `moore_detector` FSM, providing initial values and clock/input toggling.

- code: |
    module test_moore_detector;
    reg x=0, reset=1, clock=0;
    wire z;
    moore_detector MUT ( x, reset, clock, z );
    initial #24 reset=1âb0;
    always #5 clock=~clock;
    always #7 x=~x;
    initial #189 $stop;
    endmodule
  prompt: Create a testbench for `moore_detector`, stopping the simulation after 189 time units using `$stop`.

- code: |
    module test_moore_detector;
    reg x=0, reset=1, clock=0;
    wire z;
    moore_detector MUT ( x, reset, clock, z );
    initial begin
    #24 reset=1âb0;
    #165 $finish;
    end
    always #5 clock=~clock;
    always #7 x=~x;
    endmodule
  prompt: Create a testbench for `moore_detector`, finishing the simulation after a total of 189 time units using `$finish`.

- code: |
    module test_moore_detector;
    reg x=0, reset=1, clock=0;
    wire z;
    moore_detector MUT ( x, reset, clock, z );
    initial #24 reset=1âb0;
    initial repeat(13) #5 clock=~clock;
    initial repeat(10) #7 x=$random;
    endmodule
  prompt: Create a testbench for `moore_detector` using `repeat` loops to generate a fixed number of clock cycles and random inputs.

- code: |
    module test_moore_detector;
    reg x=0, reset=1, clock=0;
    wire z;
    moore_detector MUT ( x, reset, clock, z );
    initial #24 reset=0;
    initial repeat(13) #5 clock=~clock;
    initial forever @(posedge clock) #3 x=$random;
    endmodule
  prompt: Create a testbench for `moore_detector` generating random input `x` synchronized slightly after the positive clock edge using `forever @(posedge clock)`.

- code: |
    module test_moore_detector;
    reg x=0, reset=1, clock=0;
    wire z;
    moore_detector MUT ( x, reset, clock, z );
    initial #24 reset=0;
    initial repeat(13) #5 clock=~clock;
    initial forever @(posedge clock) #3 x=$random;
    initial forever @(posedge clock) #1 $displayb(z);
    endmodule
  prompt: Create a testbench for `moore_detector` with synchronized random input and displaying the output `z` shortly after each positive clock edge using `$displayb`.

- code: |
    module test_moore_detector;
    reg x=0, reset=1, clock=0;
    wire z;
    moore_detector MUT ( x, reset, clock, z );
    initial #24 reset=0;
    initial repeat(19) #5 clock=~clock;
    initial forever @(posedge clock) #3 x=$random;
    initial $monitor(âNew state is %d and occurs at %tâ,
    MUT.current, $time);
    always @(z) $display(âOutput changes at %t to %bâ,
    $time, z);
    endmodule
  prompt: Create a testbench for `moore_detector` using `$monitor` to display state changes and `$display` within an `always @(z)` block to show output changes.

- code: |
    module moore_detector (input x, start, rst, clk,
    output z );
    parameter a=0, b=1, c=2, d=3, e=4;
    reg [2:0] current;
    always @( posedge clk )
    if ( rst ) current <= a;
    else if ( ~start ) current <= a;
    else case ( current )
    a : current <= x ? b : a ;
    b : current <= x ? c : a ;
    c : current <= x ? c : d ;
    d : current <= x ? e : a ; // Changed from original: state 'd' always transitions
    e : current <= x ? c : a ; // Changed from original: state 'e' always transitions
    default: current <= a;
    endcase
    assign z = (current==e);
    endmodule
  prompt: Implement a Moore FSM using parameters, with an additional `start` input enabling state transitions. The output `z` is high when in state `e`.

- code: |
    module test_moore_detector;
    reg x=0, start, reset=1, clock=0;
    wire z;
    moore_detector MUT ( x, start, reset, clock, z );
    initial begin
    #24 reset=1âb0; start=1âb1;
    wait(z==1âb1);
    #11 start=1âb0;
    #13 start=1âb1;
    repeat(3) begin
    wait(z==1âb1); // Corrected: wait for z inside repeat loop
    #11 start=1âb0;
    #13 start=1âb1;
    end
    #50 $stop;
    end
    always #5 clock=~clock;
    always #7 x=$random;
    endmodule
  prompt: Create a testbench for the modified `moore_detector` (with `start`), using `wait(z==1'b1)` to synchronize actions based on the FSM reaching its output state.

- code: |
    module test_moore_detector;
    reg x=0, start, reset=1, clock=0;
    wire z;
    moore_detector MUT ( x, start, reset, clock, z );
    initial begin
    #24 reset=1âb0; start=1âb1;
    end
    always begin : Output_Display
    wait (MUT.current == MUT.e);
    $display (â$display task shows: The output is %b â,
    z);
    $strobe (â$strobe task shows: The output is %b â, z);
    #2 $stop; // Stop shortly after reaching state e
    end
    always #5 clock=~clock;
    always #7 x=$random;
    endmodule
  prompt: Create a testbench for the modified `moore_detector`, demonstrating the difference between `$display` and `$strobe` when the FSM reaches state `e`.

- code: |
    module test_moore_detector;
    reg x, start, reset, clock;
    wire z;
    reg [3:0] t; // Used for random delay
    moore_detector MUT ( x, start, reset, clock, z );
    initial begin:running
    clock <= 1âb0; x <= 1âb0;
    reset <= 1âb1; reset <= #7 1âb0; // Apply reset
    start <= 1âb0; start <= #17 1âb1; // Deassert reset, then assert start
    repeat (13) begin // Run for some clocks
    @( posedge clock );
    @( negedge clock );
    end
    start=1âb0; // Deassert start
    #5;
    $finish;
    end
    always #5 clock=~clock;
    always begin // Apply random input with random delay
    t = $random;
    #(t) x=$random;
    end
    endmodule
  prompt: Create a testbench for `moore_detector` applying random input `x` with random delays generated using `$random`.

- code: |
    module test_moore_detector;
    reg x=0, rst, start, clk=0;
    wire z;
    reg [18:0] buffer;
    moore_detector MUT ( x, start, rst, clk, z );
    initial buffer = 19âb0001101101111001001; // Predefined input sequence
    initial begin
    rst=1âb1; start=1âb0;
    #29 rst=1âb0; // Deassert reset
    #29 start=1âb1; // Assert start
    #500 $stop;
    end
    // Shift the buffer content into x on each clock edge
    always @(posedge clk) #1 {x, buffer} = {buffer, x};
    always #5 clk = ~clk; // Generate clock
    endmodule
  prompt: Create a testbench for `moore_detector` that feeds a predefined sequence of inputs stored in a register (`buffer`) using bit shifting.

- code: |
    module BCD_Counter (input rst, clk, output reg [3:0] cnt);
    always @(posedge clk) begin
    if (rst || cnt >= 9) cnt <= 0; // Corrected BCD condition: resets on >= 9 before incrementing
    else cnt <= cnt + 1;
    end
    // Assertion: Check if count stays within 0-9 range
    assert_always #(1, 0, âErr: Non BCD Countâ, 0)
    AA1 (clk, 1âb1, (cnt >= 0) && (cnt <= 9));
    endmodule
  prompt: Create a BCD counter module with synchronous reset and an `assert_always` assertion to verify the count remains within the valid BCD range (0-9).

- code: |
    module BCD_Counter_Tester;
    reg r, c;
    wire [3:0] count;
    BCD_Counter UUT (r, c, count);
    initial begin
    r = 0; c = 0;
    end
    initial repeat (200) #17 c= ~c; // Generate clock cycles
    initial repeat (03) #807 r= ~r; // Apply reset pulses
    endmodule
  prompt: Create a testbench for the `BCD_Counter`, providing clock and reset stimulus using `repeat` loops.

- code: |
    module Walking_One (input rst, clk, output reg [7:0] wo);
    always @(negedge clk) begin
    if (rst) wo <= 8âb10000000; // Initialize with 1 at MSB
    else wo <= {wo[0], wo[7:1]}; // Rotate right
    end
    // Assertion: Check if bit 0 changes within 7 negedges after reset goes low
    assert_change #(1, 1, 7, 0, 0, âErr: Bit 0 is not changingâ, 0)
    AC1 (~clk, ~rst, (rst==0), wo[0]);
    // Assertion: Check if only one bit is high at any time (one-hot)
    assert_one_hot #(1, 8, 0, âErr: Multiple active bitsâ, 0)
    AOH (~clk, ~rst, wo);
    endmodule
  prompt: Create a 'walking one' shift register module (rotates a single '1' bit right) with `assert_change` and `assert_one_hot` assertions.

- code: |
    module Walking_One_Tester ();
    reg rst=0, clk=0;
    wire [7:0] walking;
    Walking_One MUT (rst, clk, walking);
    initial repeat (223) #7 clk= ~clk; // Generate clock
    initial repeat (15) #109 rst= ~rst; // Generate reset pulses
    endmodule
  prompt: Create a testbench for the `Walking_One` module, providing clock and reset stimulus using `repeat` loops.

- code: |
    module gray_counter (input [3:0] d_in, input clk, rst, ld,
    output reg [3:0] q);
    reg [3:0] mem[0:15]; // Lookup table for Gray sequence
    reg [3:0] im_q;
    initial $readmemb(âmem.datâ, mem); // Load Gray sequence
    // Combinational logic for next state based on load or lookup
    always @( d_in or ld or q ) begin: combinational
    if( ld )
    im_q = d_in;
    else
    im_q = mem[q];
    end
    // Sequential logic for registering the state
    always @( posedge clk ) begin: register
    if( rst )
    q <= 4âb0000;
    else
    q <= im_q;
    end
    reg [3:0] old; always @(posedge clk) old <= q; // Store previous state
    // Assertion: Check if only one bit changes between consecutive counts (Gray property)
    assert_one_hot #(1, 4, 0, âErr: Not Grayâ, 0)
    AOH (~clk, ~rst, (old ^ q));
    endmodule
  prompt: Create a Gray code counter using a lookup table, with parallel load, reset, and an `assert_one_hot` assertion to verify the Gray code property.

- code: |
    module Sequencing_Machine (input x, start, rst, clk,
    output z );
    parameter a=0, b=1, c=2, d=3, e=4;
    reg [2:0] current;
    always @( posedge clk )
    if ( rst ) current <= a;
    else if ( ~start ) current <= a;
    else case ( current )
    a : current <= x ? b : a ;
    b : current <= x ? c : a ;
    c : current <= x ? c : d ;
    d : current <= e ; // Unconditional transition from d to e
    e : current <= a ; // Unconditional transition from e to a
    default: current <= a;
    endcase
    assign z = (current==e);
    // Assertion: Check if the state sequence d -> e -> a occurs
    assert_cycle_sequence
    #(1, 3, 0, 0, âErr: State sequence not followedâ, 0)
    ACS (clk, ~rst, {(current==d), (current==e),
    (current==a)});
    // Assertion: Check if z becomes 1 one cycle after (current==c && x==0)
    assert_next #(1, 2, 1, 0, 0, âErr: Output state not
    reachedâ, 0)
    AN1 (clk, ~rst, (current==c && x==0), (z==1));
    endmodule
  prompt: Create a state machine with `start` control, including `assert_cycle_sequence` to check for a specific state transition path (d->e->a) and `assert_next` to check a condition leading to the output state.

- code: |
    module Sequencing_Machine (input x, start, rst, clk, output z );
    parameter a=0, b=1, c=2, d=3, e=4;
    // . . . FSM logic as in Code Block 148 . . .
    // Assertion: Check if after three consecutive cycles with x=0, the state resets to 'a'
    assert_cycle_sequence
    #(1, 4, 0, 0, âErr: Resetting does not occurâ, 0)
    ACS2 (clk, ~rst, {(x==0), (x==0), (x==0), (current==a)});
    // . . . rest of module . . .
    endmodule
  prompt: Add an `assert_cycle_sequence` assertion to the `Sequencing_Machine` to verify that three consecutive cycles of input x=0 forces the machine back to the reset state 'a'.

- code: |
    module mealy_detector (input x, rst, clk, output z);
    localparam [1:0]
    reset = 0, // 0 = 0 0
    got1 = 1, // 1 = 0 1
    got10 = 2; // 2 = 1 0
    reg [1:0] current;
    always @( posedge clk ) begin
    if (rst) current <= reset;
    else case ( current )
    reset: if( x==1âb1 ) current <= got1;
    else current <= reset;
    got1: if( x==1âb0 ) current <= got10;
    else current <= got1;
    got10: if( x==1âb1 ) current <= got1; // Sequence "101" detected here
    else current <= reset;
    default: current <= reset;
    endcase
    end
    assign z = ( current==got10 && x==1âb1 ) ? 1âb1 : 1âb0;
    // Assertion: Check if the state becomes 'reset' one cycle after 'rst' is asserted
    assert_next
    #(1, 1, 1, 0, 0, âErr: Machine does not reset
    properlyâ, 0)
    AN1 (clk, 1âb1, rst, (current==reset));
    endmodule
  prompt: Implement a Mealy FSM to detect "101" and add an `assert_next` assertion to verify that the reset signal correctly forces the machine to the reset state on the next clock cycle.

- code: |
    module mealy_detector2 (input x, rst, clk, output z);
    // . . . FSM logic as in Code Block 150 . . .
    // Assertion: Check if (current==got10 && x) implies (z==1)
    assert_implication
    #(1, 0, âErr: Output not assertedâ, 0)
    AI1 (clk, 1âb1, (current==got10 && x), (z==1));
    // . . . rest of module . . .
    endmodule
  prompt: Add an `assert_implication` assertion to the Mealy detector to verify that the output `z` is correctly asserted when the condition for detecting the sequence ("101") is met.

- code: |
    module mealy_detector2 (input x, rst, clk, output z);
    // . . . FSM logic as in Code Block 150 . . .
    // Assertion: Check if the state register 'current' stays within the valid range [0, 2]
    assert_no_overflow #(1, 2, 0, 2, 0, âErr: Invalid stateâ, 0)
    ANV1 (clk, 1âb1, current);
    // . . . rest of module . . .
    endmodule
  prompt: Add an `assert_no_overflow` assertion to the Mealy detector to ensure the state register `current` never holds an invalid value (outside the defined states 0, 1, 2).

- code: |
    module mult (a, b, start, clk, r, done);
    input [7:0] a, b;
    input start, clk;
    output [15:0] r;
    output done;
    // . . . internals omitted . . .
    endmodule
  prompt: Define the module interface for an 8x8 multiplier with start and done signals (repeat of Code Block 124/153, internals omitted).

- code: |
    module an_nmos ( input a, b, output y );
    // Instantiate an NMOS switch with rise, fall, and turn-off delays
    nmos #(3, 4, 5) (y, a, b); // output, data_in, control
    endmodule
  prompt: Model a single NMOS transistor switch with specified rise (3ns), fall (4ns), and turn-off (5ns) delays.

- code: |
    module nand2_1d ( input a, b, output y );
    supply0 Gnd; // Define ground supply
    supply1 Vdd; // Define Vdd supply
    wire im1; // Intermediate wire
    // PMOS pull-up network
    pmos #(4) g1 ( y, Vdd, a ); // output, source, gate
    pmos #(4) g2 ( y, Vdd, b );
    // NMOS pull-down network
    nmos #(3) g3 ( y, im1, a );
    nmos #(3) g4 ( im1, Gnd, b );
    endmodule
  prompt: Create a structural model of a 2-input CMOS NAND gate using PMOS and NMOS transistor primitives with specified delays. Use code with caution.

- code: |
    module aoi_3d (input a, b, c, d, output y );
    supply0 Gnd;
    supply1 Vdd;
    wire im1, im2, im3;
    pmos #(3,5,7)
    g1( im1, Vdd, a ),
    g2( im1, Vdd, b ),
    g3( y, im1, c ),
    g4( y, im1, d );
    nmos #(2,4,6)
    g5( y, im2, a ),
    g6( im2, Gnd, b ),
    g7( y, im3, c ),
    g8( im3, Gnd, d );
    endmodule
  prompt: Create a structural model of an AOI (AND-OR-Invert) gate using PMOS and NMOS transistors with specified delays.

- code: |
    module mux (input i0, i1, s0, s1, output y );
    wire y; // Output should probably be declared as output, not wire here
    nmos #(4)
    g1( y, i0, s0 ), // Pass i0 if s0 is high
    g2( y, i1, s1 ); // Pass i1 if s1 is high
    endmodule
  prompt: Implement a 2-to-1 multiplexer using two NMOS pass transistors controlled by complementary select signals (s0, s1).

- code: |
    module shifter (input i3, i2, i1, i0, sin, ls,
    output y3, y2, y1, y0 );
    supply1 Vdd;
    supply0 Gnd;
    wire ls_b; // Internal wire for inverted control signal
    nmos #(3)
    ( y0, sin, ls ),   // Shift in if ls is high
    ( y0, i0 , ls_b ), // Pass i0 if ls is low
    ( y1, i0, ls ),
    ( y1, i1 , ls_b ),
    ( y2, i1, ls ),
    ( y2, i2 , ls_b ),
    ( y3, i2, ls ),
    ( y3, i3 , ls_b );
    // Inverter for control signal ls
    nmos #(5) ( ls_b, Gnd, ls );
    pmos #(5) ( ls_b, Vdd, ls );
    endmodule
  prompt: Create a structural 4-bit left shifter using NMOS pass transistors and a CMOS inverter for the shift control signal.

- code: |
    module barrel_shifter (i, l, y);
    parameter SIZE = 4;
    input [SIZE-1:0] i, l;
    output [SIZE-1:0] y;
    genvar a, b;
    generate for (a=0; a<SIZE; a=a+1) begin:row
    for (b=0; b<SIZE; b=b+1) begin:col
    // Connect input i[b] to output y[a] if control l[shift_amount] is high
    if (b>=a)
    nmos #2 (y[a], i[b], l[b-a]);
    else // Handle wrap-around for rotation
    nmos #2 (y[a], i[b], l[SIZE-(a-b)]);
    end
    end endgenerate
    endmodule
  prompt: Implement a parameterizable (default SIZE=4) barrel shifter/rotator using a grid of NMOS pass transistors generated with nested for loops.

- code: |
    module half_reg (input d, c, output q_bar);
    supply0 Gnd;
    supply1 Vdd;
    trireg #( 0, 0, 50 ) cap; // Capacitive storage node
    // CMOS transmission gate to pass d to cap when c is high
    cmos #(0,0,5) ( cap, d, c, ~c );
    // Inverter buffer at the output
    nmos #(3) ( q_bar, Gnd, cap );
    pmos #(4) ( q_bar, Vdd, cap );
    endmodule
  prompt: Model one half (e.g., master or slave stage) of a dynamic register using a CMOS transmission gate, a `trireg` for storage, and an output inverter.

- code: |
    module d_latch (input d, c, output q);
    wire im1, q_not; // Added q_not declaration
    // CMOS transmission gate pair forming the latch core
    cmos #(0,0,3)
    ( im1, d, c, ~c ),   // Pass d when c is high
    ( im1, q, ~c, c );   // Hold q when c is low
    // Cross-coupled inverters for storing the state
    not #(5)
    ( q_not, im1 ),
    ( q, q_not );
    endmodule
  prompt: Create a structural D-latch using CMOS transmission gates and cross-coupled NOT gates.

- code: |
    module cross_couple (input d, wr, rd, output q_bar);
    wire #(5) q_not;
    wire #(3) im1; // Removed q_bar from here as it's an output
    // NMOS pass transistors for write and read
    nmos
    ( im1, d, wr ),       // Write d to im1 when wr is high
    ( q_bar, q_not, rd ); // Read q_not to q_bar when rd is high
    // Cross-coupled inverters with pull strengths
    not ( q_not, im1 );
    not (pull0, pull1) ( im1, q_not ); // Feedback inverter
    endmodule
  prompt: Model a cross-coupled cell (potential memory element) using NMOS pass transistors for read/write and NOT gates with specified pull strengths.

- code: |
    module dynamic_cell (inout io, input rd_wr);
    trireg #(0, 0, 50) cap; // Capacitive storage
    // Bidirectional transmission gate controlled by rd_wr
    tranif1 #(5) ( cap, io, rd_wr ); // Connects io and cap if rd_wr is high
    endmodule
  prompt: Model a simple dynamic memory cell using a `trireg` for storage and a `tranif1` bidirectional switch for read/write access.

- code: |
    module master_slave_dff (input d, c, output q);
    wire im1, c_not; // Added c_not declaration
    // Instantiate master and slave stages
    half_reg master ( d, c, im1 );    // Master latches on high c
    half_reg slave ( im1, c_not, q ); // Slave latches on low c (high c_not)
    // Invert clock for slave stage
    not ( c_not, c );
    endmodule
  prompt: Create a master-slave D flip-flop by instantiating two `half_reg` modules (Block 160) with inverted clocks.

- code: |
    module register_4 (input [3:0] d, input c, output [3:0] q);
    genvar i;
    // Instantiate 4 flip-flops using a generate loop
    generate for (i=0; i<4; i=i+1) begin:bits
    master_slave_dff ff ( d[i], c, q[i] );
    end endgenerate
    endmodule
  prompt: Create a 4-bit register by instantiating four `master_slave_dff` flip-flops (Block 164) using a generate for loop.

- code: |
    module wired_strength (input a, b, output z1, z2, z3);
    wire z1;
    wand z2;
    wor z3;
    // Wired logic (wire): Resolution depends on strengths
    buf (pull1, weak0) (z1, a);
    buf (pull1, weak0) (z1, b);
    // Wired-and logic (wand): Behaves like AND
    buf (pull1, weak0) (z2, a);
    buf (pull1, weak0) (z2, b);
    // Wired-or logic (wor): Behaves like OR
    buf (pull1, weak0) a3 (z3, a);
    buf (pull1, weak0) b3 (z3, b);
    endmodule
  prompt: Demonstrate Verilog `wire`, `wand`, and `wor` net types by driving them with buffers having (pull1, weak0) strength.

- code: |
    module wired_strength (input a, b, output z1, z2, z3);
    wire z1;
    wand z2;
    wor z3;
    // Wired logic (wire) with (pull1, pull0) strength
    buf (pull1, pull0) (z1, a);
    buf (pull1, pull0) (z1, b);
    // Wired-and logic (wand) with (pull1, pull0) strength
    buf (pull1, pull0) (z2, a);
    buf (pull1, pull0) (z2, b);
    // Wired-or logic (wor) with (pull1, pull0) strength
    buf (pull1, pull0) (z3, a);
    buf (pull1, pull0) (z3, b);
    endmodule
  prompt: Demonstrate Verilog `wire`, `wand`, and `wor` net types by driving them with buffers having (pull1, pull0) strength.

- code: |
    module mos_strength (a, c, zn, zp);
    input a, c;
    output zn, zp;
    nmos (zn, a, c); // NMOS passes 'a' when 'c' is 1 (outputs St0 or Z)
    pmos (zp, a, c); // PMOS passes 'a' when 'c' is 0 (outputs St1 or Z)
    endmodule
  prompt: Model basic NMOS and PMOS transistors to show their inherent output strength characteristics (Strong 0 for NMOS, Strong 1 for PMOS).

- code: |
    module test_mos_strength;
    reg a, c;
    wire zn, zp;
    mos_strength cut (a, c, zn, zp);
    initial begin
    #10 a = 1; c = 0; // PMOS ON (zp=St1), NMOS OFF (zn=Z)
    #10 c = 1;         // PMOS OFF (zp=Z), NMOS ON (zn=St0 because a=1 -> Z) -> Actually zn=St1 from a=1
    #10 a = 0;         // PMOS OFF (zp=Z), NMOS ON (zn=St0)
    #10 c = 0;         // PMOS ON (zp=St1 because a=0 -> Z), NMOS OFF (zn=Z) -> Actually zp=St0 from a=0
    #10 a = 1;         // PMOS ON (zp=St1), NMOS OFF (zn=Z)
    #10 c = 1;         // PMOS OFF (zp=Z), NMOS ON (zn=St1 from a=1)
    #10 $stop;
    end
    initial
    // Monitor output values and strengths
    $monitor (âAt time %t zn: %v, zp: %vâ, $time, zn, zp);
    endmodule
  prompt: Create a testbench for the `mos_strength` module (Block 168), applying stimuli and using `$monitor` with `%v` to observe output strengths.

- code: |
    module mos_strength (a, c, zn, zp);
    input a, c;
    output zn, zp;
    rnmos (zn, a, c); // Resistive NMOS
    rpmos (zp, a, c); // Resistive PMOS
    endmodule
  prompt: Model resistive NMOS (`rnmos`) and PMOS (`rpmos`) transistors, which have weaker output strengths than standard `nmos`/`pmos`.

- code: |
    module datapath ( input clk, clr_P, load_P, load_B,
    msb_out, lsb_out, sel_sum, load_A, shift_A,
    inout [7:0] data, output A0 );
    wire [7:0] sum, ShiftAdd;
    reg [7:0] A, B, P; // Registers for operands and partial product
    wire co; // Carry out from adder
    // Register B logic
    always @( posedge clk ) if (load_B) B <= data;
    // Register P logic (partial product)
    always @( posedge clk )
    if (load_P) P <= {co&sel_sum, ShiftAdd[7:1]}; // Shift right, conditionally add carry
    // Adder logic
    assign { co, sum } = P + B;
    // Register A logic (multiplier)
    always @( posedge clk )
    case ( { load_A, shift_A } )
    2âb01 : A <= { ShiftAdd[0], A[7:1] }; // Shift right, LSB depends on ShiftAdd[0]
    2âb10 : A <= data; // Parallel load
    default : A <= A; // Hold
    endcase
    assign A0 = A[0]; // Output LSB of A for controller
    // Select input for P register shift/load
    assign ShiftAdd = clr_P ? 8'h00 : ( ~sel_sum ? P : sum ); // Clear P, Pass P, or Pass Sum
    // Tristate assignments for data bus output
    assign data = lsb_out ? A : 8'hzz; // Output A (LSBs of result)
    assign data = msb_out ? P : 8'hzz; // Output P (MSBs of result)
    endmodule
  prompt: Implement the datapath for a shift-and-add multiplier, including registers (A, B, P), an adder, multiplexers, and tristate outputs, controlled by signals from a controller.

- code: |
    module controller ( input clk, start, A0,
    output reg clr_P, load_P, load_B, msb_out,
    lsb_out, sel_sum,
    output reg load_A, Shift_A, done );
    reg [3:0] current; // State register
    // Assuming state parameters (`idle`, `init`, etc.) are defined elsewhere
    always @ ( posedge clk ) begin
    // Default assignments (signals are active high)
    clr_P = 0; load_P = 0; load_B = 0; msb_out = 0;
    lsb_out = 0;
    sel_sum = 0; load_A = 0; Shift_A = 0; done = 0;
    // State transition logic
    case ( current )
    `idle :
    if (~start) begin // Stay idle if not started
    current <= `idle;
    done = 1; // Signal completion
    end else begin // Start initiated
    current <= `init;
    load_A = 1; clr_P = 1; load_P = 1; // Load A, Clear P
    end
    `init : begin // Initialize B
    current <= `m1;
    load_B = 1;
    end
    `m1, `m2, `m3, `m4, `m5, `m6, `m7, `m8 : begin // 8 shift/add steps (Corrected typo `m6, `m6)
    current <= current + 1; // Go to next step
    Shift_A = 1; load_P = 1; if (A0) sel_sum = 1; // Shift A, Load P (conditionally add)
    end
    `rslt1 : begin // Output LSBs
    current <= `rslt2;
    lsb_out = 1;
    end
    `rslt2 : begin // Output MSBs
    current <= `idle;
    msb_out = 1;
    end
    default : current <= `idle; // Default to idle
    endcase
    end
    endmodule
  prompt: Implement the FSM controller for the shift-and-add multiplier datapath (Block 171), generating control signals based on the current state, `start` input, and `A0` from the datapath. Assumes state parameters are defined.

- code: |
    module Multiplier ( input clk, start,
    inout [7:0] databus,
    output lsb_out, msb_out, done );
    // Internal control and status signals
    wire clr_P, load_P, load_B, msb_out,
    lsb_out, sel_sum, load_A, Shift_A, A0; // Added A0 wire
    // Instantiate Datapath Unit
    datapath dpu( clk, clr_P, load_P, load_B,
    msb_out, lsb_out, sel_sum, load_A, Shift_A,
    databus, A0 );
    // Instantiate Controller Unit
    controller cu( clk, start, A0, clr_P, load_P, load_B,
    msb_out, lsb_out, sel_sum, load_A, Shift_A,
    done );
    endmodule
  prompt: Create the top-level multiplier module by instantiating the datapath (Block 171) and controller (Block 172) units and connecting their ports.

- code: |
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_out, done;
    reg [7:0] mem1[0:2], mem2[0:2]; // Memory for operands
    reg [7:0] im_data; // Data to drive onto bus
    reg [7:0] opnd1, opnd2; // Operands
    reg [15:0] expected_result, multiplier_result; // Results
    integer indx; // Loop index
    // Instantiate the Multiplier Unit Under Test
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );
    // --- Placeholder blocks referenced by Figure numbers ---
    initial begin: Apply_Data /* ... Figure 8.11 ... */ end
    initial begin: Apply_Start /* ... Figure 8.12 ... */ end
    initial begin: Expected_Result /* ... Figure 8.13 ... */ end
    always @(posedge clk)
    begin: Actual_Result /* ... Figure 8.14 ... */ end
    always @(posedge clk)
    begin: Compare_Results /* ... Figure 8.15 ... */ end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    assign databus = im_data; // Drive internal data onto bus
    endmodule
  prompt: Outline a testbench structure for the `Multiplier` module (Block 173), including DUT instantiation, stimulus generation placeholders, result checking placeholders, clock generation, and data bus assignment.

- code: |
    module AC ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out );
    // Simple register (Accumulator) loaded on posedge clk when load is high
    always @( posedge clk )
    if( load ) data_out <= data_in;
    endmodule
  prompt: Create a simple 8-bit register (Accumulator - AC) with a synchronous load enable.

- code: |
    module PC ( input [5:0] data_in, input load, inc, clr, clk,
    output reg [5:0] data_out );
    // Program Counter register with clear, load, and increment functionality
    always @( posedge clk )
    if( clr ) data_out <= 6âb000_000;    // Synchronous clear
    else if( load ) data_out <= data_in; // Synchronous load
    else if( inc ) data_out <= data_out + 1; // Synchronous increment
    endmodule
  prompt: Create a 6-bit Program Counter (PC) register with synchronous clear, load, and increment capabilities.

- code: |
    module IR ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out );
    // Simple register (Instruction Register) loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) data_out <= data_in;
    endmodule
  prompt: Create a simple 8-bit register (Instruction Register - IR) with a synchronous load enable.

- code: |
    module ALU ( input [7:0] a, b, input pass, add,
    output reg[7:0] alu_out );
    // Simple combinational ALU
    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0;           // Default output is 0
    endmodule
  prompt: Create a simple combinational 8-bit ALU that can pass input 'a' or add inputs 'a' and 'b'.

- code: |
    module DataPath ( input ir_on_adr, pc_on_adr, dbus_on_data,
    data_on_dbus, ld_ir, ld_ac, ld_pc,
    inc_pc, clr_pc, pass, add, alu_on_dbus,
    clk,
    output [5:0] adr_bus,
    output [1:0] op_code,
    inout [7:0] data_bus );
    // Internal wires
    wire [7:0] dbus, ir_out, a_side, alu_out;
    wire [5:0] pc_out;
    // Instantiate functional units
    IR ir ( dbus, ld_ir, clk, ir_out );
    PC pc ( ir_out[5:0], ld_pc, inc_pc, clr_pc, clk, pc_out );
    AC ac ( dbus, ld_ac, clk, a_side );
    ALU alu ( a_side, {2âb00,ir_out[5:0]}, pass, add, alu_out ); // ALU 'b' input from IR address field
    // Address Bus Multiplexing (Tristate)
    assign adr_bus = ir_on_adr ? ir_out[5:0] : 6âbzzzzzz;
    assign adr_bus = pc_on_adr ? pc_out : 6âbzzzzzz; // Note: Overwrites previous assign, likely intended to be conditional mux
    // Internal Data Bus (dbus) Multiplexing (Tristate)
    assign dbus = alu_on_dbus ? alu_out : 8âbzzzzzzzz;
    // External Data Bus (data_bus) Control (Tristate)
    assign data_bus = dbus_on_data ? dbus : 8âbzzzzzzzz; // Drive dbus onto data_bus
    assign dbus = data_on_dbus ? data_bus : 8âbzzzzzzzz; // Drive data_bus onto dbus (Note: Potential conflict/loop)
    // Opcode Output
    assign op_code = ir_out[7:6];
    endmodule
  prompt: Implement the datapath for a simple CPU, instantiating IR, PC, AC, ALU units and managing address/data buses using tristate assignments controlled by input signals. **Note:** Contains potential bus conflicts/overwrites.

- code: |
    module AddingCPU (input reset, clk,
    output [5:0] adr_bus, output rd_mem, wr_mem,
    inout [7:0] data_bus);
    // Internal control signals and opcode
    wire ir_on_adr, pc_on_adr, dbus_on_data, data_on_dbus,
    ld_ir,
    ld_ac, ld_pc, inc_pc, clr_pc, pass, add, alu_on_dbus;
    wire [1:0] op_code;
    // Instantiate Controller
    Controller cu ( reset, clk, op_code, rd_mem, wr_mem, ir_on_adr,
    pc_on_adr, dbus_on_data, data_on_dbus, ld_ir,
    ld_ac, ld_pc, inc_pc, clr_pc, pass,
    add, alu_on_dbus );
    // Instantiate DataPath
    DataPath dp ( ir_on_adr, pc_on_adr, dbus_on_data, data_on_dbus,
    ld_ir, ld_ac, ld_pc, inc_pc, clr_pc, pass, add,
    alu_on_dbus, clk, adr_bus, op_code, data_bus );
    endmodule
  prompt: Create the top-level module for a simple CPU (`AddingCPU`) by instantiating a Controller and the DataPath (Block 179) and connecting them.

- code: |
    module Test_AddingCPU;
    reg reset=1, clk=0;
    wire [5:0] adr_bus;
    wire rd_mem, wr_mem;
    wire [7:0] data_bus; // DUT connection (driven by assign below)
    reg [7:0] mem_data=8'b0; // Data driven onto bus during memory read
    reg control=0; // Placeholder?
    integer HexFile, check; // File handles/variables
    // Instantiate CPU Under Test
    AddingCPU UUT (reset, clk, adr_bus, rd_mem, wr_mem, data_bus);
    // Clock Generation
    always #10 clk = ~clk;
    // Initialization and Simulation Control
    initial begin
    Convert; // Call memory conversion task
    HexFile = $fopen (âHexadecimalFile.memâ, âr+â); // Open memory file
    #25 reset=1âb0; // Deassert reset
    #405 $fclose (HexFile); // Close file
    $stop; // Stop simulation
    end
    // Memory Read/Write Simulation Placeholder
    always @(posedge clk) begin : Memory_Read_Write
    // ... logic to handle rd_mem/wr_mem and interact with mem_data/HexFile ...
    end
    // Memory Initialization Task Placeholder
    task Convert;
    // ... logic to read assembly/machine code and prepare memory file ...
    endtask
    // Drive data bus during memory read cycles
    assign data_bus = rd_mem ? mem_data : 8'bzzzzzzzz;
    endmodule
  prompt: Outline a testbench structure for the `AddingCPU` (Block 180), including DUT instantiation, clock generation, reset control, memory file handling placeholders, and basic memory bus interaction logic.

- code: |
    module ProgramCounter (
    input [15:0] in, input enable, clk, output reg [15:0] out);
    // 16-bit register loaded on negedge clk when enable is high
    always @ (negedge clk) if (enable) out = in;
    endmodule
  prompt: Create a 16-bit Program Counter register with a negative-edge clock trigger and load enable.

- code: |
    module AddressLogic ( input [15:0] PCside, Rside,
    input [7:0] Iside, // Immediate offset
    input ResetPC, PCplusI, PCplus1, RplusI,
    Rplus0,
    output reg [15:0] ALout ); // Address Logic Output
    // Combinational logic to select/calculate next address
    always @ (PCside or Rside or Iside or ResetPC or
    PCplusI or PCplus1 or RplusI or Rplus0)
    case ({ResetPC, PCplusI, PCplus1, RplusI, Rplus0}) // Control signals select operation
    5âb10000: ALout = 0; // Reset PC
    5âb01000: ALout = PCside + Iside; // PC + Immediate Offset
    5âb00100: ALout = PCside + 1; // Increment PC
    5âb00010: ALout = Rside + Iside; // Register + Immediate Offset
    5âb00001: ALout = Rside; // Register Direct
    default: ALout = PCside; // Default to PC value
    endcase
    endmodule
  prompt: Implement the Address Logic unit for the SAYEH CPU, calculating or selecting the next instruction address based on various control signals using a case statement.

- code: |
    module InstrunctionRegister (in, IRload, clk, out); // Typo: Instrunction -> Instruction
    input [15:0] in;
    input IRload, clk;
    output [15:0] out;
    reg [15:0] out;
    // 16-bit register loaded on negedge clk when IRload is high
    always @(negedge clk) if (IRload == 1) out <= in;
    endmodule
  prompt: Create a 16-bit Instruction Register (IR) for the SAYEH CPU with a negative-edge clock trigger and load enable.

- code: |
    module RegisterFile ( input [15:0] in,
    input clk, RFLwrite, RFHwrite, // Low/High byte write enables
    input [1:0] Laddr, Raddr, // Read/Write address offsets
    input [2:0] Base, // Base pointer for register window
    output [15:0] Lout, Rout ); // Left/Right port outputs
    reg [15:0] MemoryFile [0:7]; // 8x16 register file memory
    // Calculate effective read addresses using base + offset
    wire [2:0] Laddress = Base + Laddr;
    wire [2:0] Raddress = Base + Raddr;
    // Combinational read ports
    assign Lout = MemoryFile [Laddress];
    assign Rout = MemoryFile [Raddress];
    reg [15:0] TempReg; // Temporary storage for read-modify-write
    // Synchronous write logic (negedge clk)
    always @(negedge clk) begin
    TempReg = MemoryFile [Laddress]; // Read current value
    // Modify low/high bytes based on write enables
    if (RFLwrite) TempReg [7:0] = in [7:0];
    if (RFHwrite) TempReg [15:8] = in [15:8];
    // Write back potentially modified value
    MemoryFile [Laddress] = TempReg;
    end
    endmodule
  prompt: Implement the Register File for the SAYEH CPU as an 8x16 two-port memory with a sliding window (`Base` pointer) and byte-level write enables.

- code: |
    module controller ( ExternalReset, clk, ResetPC, PCplusI,
    PCplus1, RplusI, Rplus0 /* , ... other inputs/outputs */ );
    input ExternalReset, clk /* , ... other inputs ... */;
    output ResetPC, PCplusI, PCplus1, RplusI, Rplus0 /* , ... other outputs ... */;
    reg ResetPC, PCplusI, PCplus1, RplusI, Rplus0 /* , ... other outputs ... */;
    // State definitions
    parameter [3:0]
    reset = 0, halt = 1, fetch = 2, memread = 3,
    exec1 = 4, exec2 = 5,
    exec1lda = 6, exec2lda = 7, incpc = 8;
    // Instruction opcode definitions (examples)
    parameter nop = 4âb0000;
    parameter hlt = 4âb0001;
    parameter szf = 4âb0010;
    // ... other opcodes ...
    reg [3:0] Pstate, Nstate; // Present and Next state registers
    // Example condition (Shadow register enable?)
    wire ShadowEn = ~(Instruction[7:0] == 8âbxxxxxxxx); // Instruction input assumed available
    // Combinational logic for next state and outputs
    always @(/* Instruction or */ Pstate or ExternalReset /* or Cflag or Zflag or memDataReady */) begin
    // Default output assignments
    ResetPC = 1âb0;
    PCplusI = 1âb0;
    PCplus1 = 1âb0;
    RplusI = 1âb0;
    Rplus0 = 1âb0;
    // ... other default outputs ...
    // State transition logic
    case (Pstate)
    reset : /* ... */ ;
    halt : /* ... */ ;
    fetch : /* ... */ ;
    memread : /* ... */ ;
    exec1 : /* ... */ ;
    exec1lda : /* ... */ ;
    exec2 : /* ... */ ;
    exec2lda : /* ... */ ;
    incpc : /* ... */ ;
    default: Nstate = reset;
    endcase
    end
    // Sequential logic for state register
    always @ (negedge clk) Pstate <= Nstate; // Use non-blocking for state register
    endmodule
  prompt: Outline the FSM controller structure for the SAYEH CPU, defining states and instruction parameters, and showing the combinational (`case` statement) and sequential (`always @(negedge clk)`) blocks. Internal logic is omitted.

- code: |
    module Sayeh ( clk, ReadMem, WriteMem, ReadIO, WriteIO,
    Databus, Addressbus, ExternalReset, MemDataready);
    input clk;
    output ReadMem, WriteMem, ReadIO, WriteIO;
    inout [15: 0] Databus;
    output [15: 0] Addressbus;
    input ExternalReset, MemDataready;
    // Internal wires for connections
    wire [15:0] Instruction; // Assumed connection or internal wire needed
    wire ResetPC, PCplusI, PCplus1, RplusI, Rplus0; // Corrected typo `esetPC`
    // ... other internal wires ...
    // Instantiate DataPath (assuming `dp` definition exists)
    DataPath dp (clk, Databus, Addressbus,
    ResetPC, PCplusI, PCplus1, RplusI, Rplus0 /* , ... other ports ... */ );
    // Instantiate Controller (Block 186)
    controller ctrl (ExternalReset, clk,
    ResetPC, PCplusI, PCplus1, RplusI, Rplus0 /* , ... other ports ... */ );
    endmodule
  prompt: Create the top-level module for the SAYEH CPU, instantiating the DataPath and Controller (Block 186) units and defining the external interface. Assumes sub-module ports match.

- code: |
    module sw2led (sw,ld) ;
    // ------------ Port declarations --------- //
    input [7:0] sw;
    wire [7:0] sw;
    output [7:0] ld;
    wire [7:0] ld;
    // ----------- Signal declarations -------- //
    wire [7:0] BUS7;
    // ----------- Terminals assignment --------//
    // ---- Input terminals --- //
    assign BUS7[7:0] = sw[7:0];
    // ---- Output terminals --- //
    assign ld[7:0] = BUS7[7:0];
    endmodule
  prompt: Define a module `sw2led` connecting 8 input switches (`sw`) to 8 output LEDs (`ld`) using explicit wire declarations and assignments.

- code: |
    module sw2led2 (
    input wire [7:0] sw ,
    output wire [7:0] ld
    ) ;
    assign ld = sw;
    endmodule
  prompt: Define a module `sw2led2` connecting 8 input switches (`sw`) to 8 output LEDs (`ld`) using Verilog-2001 port style and a single assign statement.

- code: |
    module gates2 (
    input wire a,
    input wire b,
    output wire and_,
    output wire nand_,
    output wire nor_,
    output wire or_,
    output wire xnor_,
    output wire xor_
    ) ;
    assign and_ = b & a;
    assign nand_ = ~(b & a);
    assign or_ = b | a;
    assign nor_ = ~(b | a);
    assign xor_ = b ^ a;
    assign xnor_ = ~(b ^ a);
    endmodule
  prompt: Implement various 2-input logic gates (AND, NAND, OR, NOR, XOR, XNOR) using continuous assign statements.

- code: |
    module gates4b (
    input wire [3:0] x ,
    output wire and4_ ,
    output wire or4_ ,
    output wire xor4_
    );
    assign and4_ = &x;
    assign or4_ = |x;
    assign xor4_ = ^x;
    endmodule
  prompt: Implement 4-input reduction operators (AND, OR, XOR) using continuous assign statements.

- code: |
    module gates4_top (
    input wire [3:0] sw ,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    endmodule
  prompt: Create a top-level module `gates4_top` instantiating a 4-input gate module (`gates4`) to connect switches (`sw`) to LEDs (`ld`).

- code: |
    module eqdet2 (
    input wire [1:0] a,
    input wire [1:0] b,
    output wire eq
    ) ;
    wire eq1;
    wire eq2;
    assign eq1 = ~(b[1] ^ a[1]); // Bit 1 equality (XNOR)
    assign eq2 = ~(b[0] ^ a[0]); // Bit 0 equality (XNOR)
    assign eq = eq2 & eq1;       // Overall equality if both bits are equal
    endmodule
  prompt: Implement a 2-bit equality comparator using XNOR logic and assign statements.

- code: |
    module mux21a (
    input wire a ,
    input wire b ,
    input wire s ,
    output wire y
    );
    assign y = ~s & a | s & b;
    endmodule
  prompt: Implement a 2-to-1 multiplexer using a Boolean expression in a continuous assign statement.

- code: |
    module mux21b (
    input wire a ,
    input wire b ,
    input wire s ,
    output reg y
    );
    always @(*)
    if(s == 0)
    y = a;
    else
    y = b;
    endmodule
  prompt: Implement a 2-to-1 multiplexer using a combinational always block with an if/else statement.

- code: |
    module mux24 (
    input wire s;
    input wire [3:0] a;
    input wire [3:0] b;
    output wire [3:0] y;
    ) ;
    // Assuming mux21 is a 1-bit 2-to-1 mux module
    mux21 U1
    ( .a(a[3]),
    .b(b[3]),
    .s(s),
    .y(y[3])
    );
    mux21 U2
    ( .a(a[2]),
    .b(b[2]),
    .s(s),
    .y(y[2])
    );
    mux21 U3
    ( .a(a[1]),
    .b(b[1]),
    .s(s),
    .y(y[1])
    );
    mux21 U4
    ( .a(a[0]),
    .b(b[0]),
    .s(s),
    .y(y[0])
    );
    endmodule
  prompt: Implement a 4-bit 2-to-1 multiplexer structurally by instantiating four 1-bit 2-to-1 multiplexer modules (`mux21`).

- code: |
    module mux24_top (
    input wire [0:0] btn; // Using bit 0 of btn as select
    input wire [7:0] sw;
    output wire [3:0] ld;
    ) ;
    // Assuming mux24 is a 4-bit 2-to-1 mux module
    mux24 U1
    ( .a(sw[7:4]), // Input 'a' from upper nibble of switches
    .b(sw[3:0]),  // Input 'b' from lower nibble of switches
    .s(btn[0]),   // Select signal from button
    .y(ld)        // Output to LEDs
    );
    endmodule
  prompt: Create a top-level module `mux24_top` instantiating a 4-bit 2-to-1 multiplexer (`mux24`) controlled by a button (`btn`) selecting between switch inputs (`sw`).

- code: |
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    if(s == 0)
    y = a;
    else
    y = b;
    endmodule
  prompt: Implement a 4-bit 2-to-1 multiplexer using a combinational always block with an if/else statement.

- code: |
    module mux2g
    #(parameter N = 4) // Parameter for bit width, default is 4
    (input wire [N-1:0] a,
    input wire [N-1:0] b,
    input wire s,
    output reg [N-1:0] y
    );
    always @(*) // Combinational block sensitive to all inputs
    if(s == 0)
    y = a; // Select input 'a' if 's' is 0
    else
    y = b; // Select input 'b' if 's' is 1
    endmodule
  prompt: Implement a generic N-bit 2-to-1 multiplexer (parameter N, default 4) using a combinational always block.

- code: |
    module mux28(
    input wire [7:0] a,
    input wire [7:0] b,
    input wire s,
    output wire [7:0] y
    );
    // Instantiate the generic mux with N=8
    mux2g #(
    .N(8))
    M8 (.a(a),
    .b(b),
    .s(s),
    .y(y)
    );
    endmodule
  prompt: Implement an 8-bit 2-to-1 multiplexer by instantiating a generic N-bit multiplexer module (`mux2g`) with N=8.

- code: |
    module mux41 (
    input wire [3:0] c , // 4 data inputs
    input wire [1:0] s , // 2 select inputs
    output wire z        // 1 output
    );
    // Internal signals
    wire v; // output of mux M2
    wire w; // output of mux M3
    // Module instantiations (assuming mux21 is a 2-to-1 mux)
    // Stage 2 mux
    mux21 U1
    ( .a(v),     // Input from M2
    .b(w),     // Input from M3
    .s(s[1]),  // Select LSB
    .y(z)      // Final output
    );
    // Stage 1 muxes
    mux21 U2
    ( .a(c[0]),
    .b(c[1]),
    .s(s[0]),  // Select MSB
    .y(v)      // Output to U1 input 'a'
    );
    mux21 U3
    ( .a(c[2]),
    .b(c[3]),
    .s(s[0]),  // Select MSB
    .y(w)      // Output to U1 input 'b'
    );
    endmodule
  prompt: Implement a 4-to-1 multiplexer structurally by instantiating three 2-to-1 multiplexer modules (`mux21`).

- code: |
    module mux41b (
    input wire [3:0] c ,
    input wire [1:0] s ,
    output wire z
    );
    assign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00
    | ~s[1] & s[0] & c[1] // Select c[1] when s=01
    | s[1] & ~s[0] & c[2] // Select c[2] when s=10
    | s[1] & s[0] & c[3]; // Select c[3] when s=11
    endmodule
  prompt: Implement a 4-to-1 multiplexer using a single Boolean expression in a continuous assign statement.

- code: |
    module mux41c (
    input wire [3:0] c ,
    input wire [1:0] s ,
    output reg z
    );
    always @(*) // Combinational block sensitive to inputs c, s
    case(s)
    2'b00: z = c[0]; // Select c[0] if s is 0
    2'b01: z = c[1]; // Select c[1] if s is 1
    2'b10: z = c[2]; // Select c[2] if s is 2
    2'b11: z = c[3]; // Select c[3] if s is 3
    default: z = c[0]; // Default case
    endcase
    endmodule
  prompt: Implement a 4-to-1 multiplexer using a combinational always block with a case statement.

- code: |
    module mux44 (
    input wire [15:0] x , // 16-bit input (four 4-bit groups)
    input wire [1:0] s ,  // 2-bit select
    output reg [3:0] z    // 4-bit output
    );
    always @(*) // Combinational block
    case(s)
    2'b00: z = x[3:0];   // Select bits 3:0 if s=0
    2'b01: z = x[7:4];   // Select bits 7:4 if s=1
    2'b10: z = x[11:8];  // Select bits 11:8 if s=2
    2'b11: z = x[15:12]; // Select bits 15:12 if s=3
    default: z = x[3:0]; // Default case
    endcase
    endmodule
  prompt: Implement a quad 4-to-1 multiplexer (selecting one 4-bit group from a 16-bit input) using a combinational always block and a case statement.

- code: |
    module counter
    #(parameter N = 4) // Parameter for counter width, default 4
    (input wire clr ,   // Asynchronous clear input
    input wire clk ,   // Clock input
    output reg [N-1:0] q // Counter output
    );
    // N-bit counter with asynchronous clear
    always @(posedge clk or posedge clr) // Sensitive to clock edge and clear edge
    begin
    if(clr == 1)
    q <= 0; // Reset counter if clear is asserted
    else
    q <= q + 1; // Increment counter on clock edge if clear is not asserted
    end
    endmodule
  prompt: Implement a generic N-bit synchronous counter (parameter N, default 4) with positive-edge asynchronous clear using a sequential always block.

- code: |
    module clkdiv (
    input wire clk , // Master clock input (e.g., 50MHz)
    input wire clr , // Asynchronous clear input
    output wire clk190 , // ~190 Hz output
    output wire clk25 , // 25 MHz output
    output wire clk3 // ~3 Hz output
    );
    reg [23:0] q; // 24-bit counter register
    // 24-bit counter
    always @(posedge clk or posedge clr)
    begin
    if(clr == 1)
    q <= 0; // Reset counter on clear
    else
    q <= q + 1; // Increment counter on clock edge
    end
    // Assign specific counter bits to output clocks
    assign clk190 = q[17]; // 50MHz / 2^18 = ~190.7 Hz
    assign clk25 = q[0]; // 50MHz / 2^1 = 25 MHz
    assign clk3 = q[23]; // 50MHz / 2^24 = ~2.98 Hz
    endmodule
  prompt: Implement a clock divider using a 24-bit counter with asynchronous clear to generate multiple output frequencies (e.g., ~190Hz, 25MHz, ~3Hz from 50MHz).

- code: |
    module count8_top (
    input wire mclk; // Master clock input
    input wire [3:3] btn; // Button input (using bit 3 for clear)
    output wire [7:0] ld; // 8-bit LED output
    ) ;
    wire clk3; // Slow clock from divider
    // Instantiate clock divider
    clkdiv U1
    ( .clk(mclk), // Connect master clock to divider input
    .clr(btn[3]), // Connect button to divider clear
    .clk3(clk3) // Get 3Hz clock output
    // Other clkdiv outputs not connected
    );
    // Instantiate 8-bit counter
    counter
    #( .N(8)) // Set counter width to 8
    U2
    ( .clk(clk3), // Clock the counter with the 3Hz signal
    .clr(btn[3]), // Connect button to counter clear
    .q(ld[7:0]) // Connect counter output to LEDs
    );
    endmodule
  prompt: Create a top-level module `count8_top` instantiating an 8-bit counter and a clock divider, driving the counter with a slow clock and clearing both with a button.

- code: |
    module hex7seg_le (
    input wire [3:0] x ,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)
    | x[3] & x[1] & x[0]
    | ~x[3] & x[2] & ~x[1] & x[0]
    | x[3] & x[2] & ~x[1] & ~x[0];
    assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    | x[3] & x[2] & x[1]
    | x[3] & x[2] & ~x[0];
    assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & ~x[2] & x[1] & ~x[0]
    | x[2] & x[1] & x[0];
    assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2)
    | ~x[3] & x[2] & ~x[1]
    | ~x[2] & ~x[1] & x[0];
    assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
    | ~x[3] & ~x[2] & x[1]
    | ~x[3] & x[1] & x[0]
    | x[3] & x[2] & ~x[1] & x[0];
    assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0)
    | x[3] & x[2] & ~x[1] & ~x[0]
    | ~x[3] & x[2] & x[1] & x[0];
    endmodule
  prompt: Implement a Hex-to-7-segment display decoder using direct Boolean logic equations in assign statements.

- code: |
    module hex7seg (
    input wire [3:0] x , // 4-bit hex input
    output reg [6:0] a_to_g // 7-segment output (active low common cathode assumed)
    );
    always @(*) // Combinational block
    case(x) // Case statement based on hex input
    4'h0: a_to_g = 7'b0000001; // 0
    4'h1: a_to_g = 7'b1001111; // 1
    4'h2: a_to_g = 7'b0010010; // 2
    4'h3: a_to_g = 7'b0000110; // 3
    4'h4: a_to_g = 7'b1001100; // 4
    4'h5: a_to_g = 7'b0100100; // 5
    4'h6: a_to_g = 7'b0100000; // 6
    4'h7: a_to_g = 7'b0001111; // 7
    4'h8: a_to_g = 7'b0000000; // 8
    4'h9: a_to_g = 7'b0000100; // 9
    4'hA: a_to_g = 7'b0001000; // A
    4'hb: a_to_g = 7'b1100000; // b
    4'hC: a_to_g = 7'b0110001; // C
    4'hd: a_to_g = 7'b1000010; // d
    4'hE: a_to_g = 7'b0110000; // E
    4'hF: a_to_g = 7'b0111000; // F
    default: a_to_g = 7'b0000001; // Default to 0
    endcase
    endmodule
  prompt: Implement a Hex-to-7-segment display decoder (common cathode, active low segments) using a combinational always block and a case statement.

- code: |
    module hex7seg_top (
    input wire [3:0] sw ,      // 4-bit switch input
    output wire [6:0] a_to_g , // 7-segment outputs
    output wire [3:0] an ,     // Anode enables (all off here)
    output wire dp             // Decimal point output (off here)
    );
    assign an = 4'b1111; // Turn all digits off (assuming active low anodes) -> Corrected: 4'b0000 turns all ON for common anode
    assign dp = 1'b1; // Turn decimal point off
    // Instantiate the decoder
    hex7seg D4 (.x(sw),       // Connect switches to decoder input
    .a_to_g(a_to_g) // Connect decoder output to segments
    );
    endmodule
  prompt: Create a top-level module `hex7seg_top` instantiating a hex-to-7-segment decoder (`hex7seg`) to display a 4-bit switch input on one common anode digit.

- code: |
    module mux7seg (
    input wire [3:0] btn,      // Button inputs for selection/enable
    output wire [6:0] a_to_g, // 7-segment outputs
    output wire [3:0] an       // Anode enables
    );
    wire [3:0] digit; // Digit value selected by mux
    wire [1:0] s;     // Select signal for mux
    wire [15:0] x;    // Hardcoded value to display
    assign x = 16'h1234; // Value to display across 4 digits
    // Instantiate hex decoder
    hex7seg U1
    ( .a_to_g(a_to_g), .x(digit));
    // Instantiate quad 4-to-1 mux to select the digit based on 's'
    mux44 U2 // Assuming mux44 selects one 4-bit group from 16-bit x based on s
    ( .s(s), .x(x), .z(digit));
    // Logic to generate select signal 's' from buttons (example)
    assign s[0] = btn[3] | btn[1];
    assign s[1] = btn[3] | btn[2];
    // Anode enable logic: Activate digit corresponding to pressed button (active low)
    assign an = ~btn;
    endmodule
  prompt: Implement a multiplexed 7-segment display driver that selects one digit from 'h1234' based on combinatorial button logic, using `mux44` and `hex7seg` modules, and drives the corresponding anode.

- code: |
    module x7seg (
    input wire cclk, // Display refresh clock (e.g., 190Hz)
    input wire clr,  // Clear signal (for counter)
    input wire [15:0] x, // 16-bit value to display
    output wire [6:0] a_to_g, // 7-segment outputs
    output wire [3:0] an      // Anode enables (active low)
    );
    // Internal signals
    wire nq0, nq1;        // Inverted counter outputs
    wire [3:0] digit;     // Selected 4-bit digit value
    wire [1:0] q;         // 2-bit counter output (selects digit 0-3)
    // Invert counter bits for anode logic
    assign nq1 = ~(q[1]);
    assign nq0 = ~(q[0]);
    // Anode enable logic (active low): Decode counter 'q' to enable one digit
    assign an[0] = q[0] | q[1];   // Enable digit 0 when q=00 (nq1&nq0)
    assign an[1] = nq0 | q[1];  // Enable digit 1 when q=01 (nq1&q0)
    assign an[2] = q[0] | nq1;  // Enable digit 2 when q=10 (q1&nq0)
    assign an[3] = nq0 | nq1;  // Enable digit 3 when q=11 (q1&q0) -> Corrected logic needed
    // Instantiate hex decoder
    hex7seg U1
    ( .a_to_g(a_to_g),.x(digit));
    // Instantiate quad 4-to-1 mux to select the digit based on counter 'q'
    mux44 U2
    ( .s(q[1:0]),.x(x),.z(digit));
    // Instantiate 2-bit counter to cycle through digits
    counter
    #( .N(2)) U3
    ( .clk(cclk),.clr(clr),.q(q[1:0]));
    endmodule
  prompt: Implement a time-multiplexed 4-digit 7-segment display driver using a 2-bit counter, a quad 4-to-1 mux (`mux44`), a hex decoder (`hex7seg`), and anode control logic. **Note:** Anode logic needs correction for active low.

- code: |
    module x7seg_top (
    input wire mclk, // Master clock
    input wire [3:3] btn, // Button for clear
    output wire dp, // Decimal point output
    output wire [6:0] a_to_g, // 7-segment outputs
    output wire [3:0] an // Anode enables
    );
    wire clk190; // Slow clock for display refresh
    wire [15:0] x; // Value to display
    assign x = 16'h1234; // Hardcoded value
    assign dp = 1'b1; // Decimal point off
    // Instantiate clock divider
    clkdiv U1
    ( .mclk(mclk),
    .clr(btn[3]),
    .clk190(clk190)
    );
    // Instantiate time-multiplexed display driver
    x7seg U3
    ( .x(x),
    .cclk(clk190),
    .clr(btn[3]),
    .a_to_g(a_to_g),
    .an(an)
    );
    endmodule
  prompt: Create a top-level module `x7seg_top` instantiating a time-multiplexed 7-segment display driver (`x7seg`) and a clock divider (`clkdiv`) to display the hardcoded value 'h1234'.

- code: |
    module x7segb_top (
    input wire clk , // Master clock (renamed from mclk?)
    input wire [3:0] btn , // Buttons
    input wire [7:0] sw , // Switches
    output wire [6:0] a_to_g , // 7-segment outputs
    output wire [3:0] an , // Anode enables
    output wire dp // Decimal point output
    );
    wire [15:0] x;
    // Concatenate switches and buttons to form the 16-bit value
    assign x = {sw,btn[2:0],5'b01010}; // digit 0 = A = 'b1010
    // Instantiate time-multiplexed display driver (definition not shown)
    x7segb X2 (.x(x),
    .clk(clk),
    .clr(btn[3]),
    .a_to_g(a_to_g),
    .an(an),
    .dp(dp)
    );
    endmodule
  prompt: Create a top-level module `x7segb_top` instantiating a time-multiplexed 7-segment display driver (`x7segb`) to display concatenated switch and button inputs.

- code: |
    module sat4bit (
    input wire [5:0] x, // 6-bit input (potentially signed or offset)
    output wire [3:0] y // 4-bit saturated output
    );
    // Internal signals for saturation detection
    wire c0, c1, s, xi;
    // Check sign bits for saturation conditions (example logic)
    assign c1 = ~(x[4] ^ x[3]); // Compare bits 4 and 3
    assign xi = ~(x[5]); // Invert MSB
    assign c0 = ~(x[5] ^ x[4]); // Compare bits 5 and 4
    assign s = c0 & c1; // Saturation control signal
    // Use mux to select between saturated value and lower bits
    mux24 U1 // Assuming mux24 selects between a and b based on s
    ( .a({x[5],xi,xi,xi}), // Saturated value (e.g., 1000 or 0111 based on sign)
    .b(x[3:0]), // Non-saturated value (lower 4 bits)
    .s(s), // Select based on saturation detection
    .y(y) // Output
    );
    endmodule
  prompt: Implement 4-bit saturating logic for a 6-bit input using combinatorial logic for detection and a 4-bit 2-to-1 multiplexer (`mux24`) for output selection.

- code: |
    module sat4bit_top (
    input wire mclk, // Master clock
    input wire [3:3] btn, // Button for clear
    input wire [5:0] sw, // 6-bit switch input for saturation logic
    output wire dp, // Decimal point
    output wire [6:0] a_to_g, // 7-segment outputs
    output wire [3:0] an, // Anode enables
    output wire [5:0] ld // LED output mirroring switches
    );
    wire clk190; // Slow clock for display
    wire [3:0] y; // Saturated 4-bit output
    assign ld = sw; // Mirror switch input to LEDs
    // Instantiate saturation logic
    sat4bit U1
    ( .x(sw),
    .y(y)
    );
    // Instantiate time-multiplexed display (definition not shown)
    x7segb11 U2
    ( .y(y), // Display the saturated value
    .cclk(clk190),
    .clr(btn[3]),
    .a_to_g(a_to_g),
    .an(an),
    .dp(dp)
    );
    // Instantiate clock divider
    clkdiv U3
    ( .mclk(mclk),
    .clr(btn[3]),
    .clk190(clk190)
    );
    endmodule
  prompt: Create a top-level module `sat4bit_top` instantiating saturation logic (`sat4bit`), a time-multiplexed display driver (`x7segb11`), and a clock divider (`clkdiv`).

- code: |
    module halfadd (
    input wire a,
    input wire b,
    output wire c, // Carry out
    output wire s  // Sum
    ) ;
    assign s = b ^ a; // Sum is XOR of inputs
    assign c = b & a; // Carry is AND of inputs
    endmodule
  prompt: Implement a half adder using XOR and AND gates via assign statements.

- code: |
    module fulladd (
    input wire a,
    input wire b,
    input wire cin, // Carry in
    output wire cout, // Carry out
    output wire s // Sum
    ) ;
    wire c1, c2, s1; // Internal wires
    // Instantiate two half adders
    halfadd U1
    ( .a(a),
    .b(b),
    .c(c1), // Carry from first half add
    .s(s1) // Sum from first half add
    );
    halfadd U2
    ( .a(s1), // Input is sum from first half add
    .b(cin), // Input is carry in
    .c(c2), // Carry from second half add
    .s(s) // Final sum output
    );
    // Combine carries
    assign cout = c2 | c1;
    endmodule
  prompt: Implement a full adder structurally by instantiating two half adder modules (`halfadd`).

- code: |
    module adder4 (
    input wire cin; // Carry in
    input wire [3:0] a; // 4-bit input A
    input wire [3:0] b; // 4-bit input B
    output wire cout; // Carry out
    output wire [3:0] s; // 4-bit sum output
    ) ;
    // Internal carry wires
    wire c1, c2, c3;
    // Instantiate four full adders in a ripple-carry chain
    fulladd U4 // Bit 0 (LSB)
    ( .a(a[0]), .b(b[0]), .cin(cin), .cout(c1), .s(s[0]) );
    fulladd U3 // Bit 1
    ( .a(a[1]), .b(b[1]), .cin(c1), .cout(c2), .s(s[1]) );
    fulladd U1 // Bit 2
    ( .a(a[2]), .b(b[2]), .cin(c2), .cout(c3), .s(s[2]) );
    fulladd U2 // Bit 3 (MSB)
    ( .a(a[3]), .b(b[3]), .cin(c3), .cout(cout), .s(s[3]) );
    endmodule
  prompt: Implement a 4-bit ripple-carry adder structurally by instantiating four full adder modules (`fulladd`).

- code: |
    module adder4_top (
    input wire mclk , // Master clock
    input wire [3:3] btn , // Button for clear
    input wire [7:0] sw , // 8 switches (two 4-bit operands)
    output wire [6:0] a_to_g , // 7-segment display segments
    output wire [3:0] an , // 7-segment display anodes
    output wire dp , // Decimal point
    output wire [7:0] ld // LEDs mirroring switches
    );
    wire clk190, clr, c4, cin; // Internal signals
    wire [15:0] x; // Data for display driver
    wire [3:0] sum; // Adder output
    assign cin = 1'b0; // Set carry-in to 0
    // Prepare data for display (switches, carry, sum)
    assign x = {sw, 3'b000, c4, sum};
    assign clr = btn[3]; // Use button as clear signal
    assign ld = sw; // Mirror switches to LEDs
    // Instantiate 4-bit adder
    adder4 U1 (.cin(cin), .a(sw[7:4]), .b(sw[3:0]),
    .cout(c4), .s(sum));
    // Instantiate clock divider
    clkdiv U2 (.mclk(mclk), .clr(clr), .clk190(clk190));
    // Instantiate 7-segment display driver (definition not shown)
    x7segb U3 (.x(x), .cclk(clk190), .clr(clr),
    .a_to_g(a_to_g), .an(an), .dp(dp));
    endmodule
  prompt: Create a top-level module `adder4_top` instantiating a 4-bit adder (`adder4`), a time-multiplexed display driver (`x7segb`), and a clock divider (`clkdiv`) to add two 4-bit switch inputs and display the inputs, carry, and sum.

- code: |
    module adder4b (
    input wire [3:0] a ,
    input wire [3:0] b ,
    output reg [3:0] s , // 4-bit sum output
    output reg cf // Carry flag output
    );
    reg [4:0] temp; // Temporary 5-bit storage for sum + carry
    always @(*) // Combinational logic
    begin
    // Perform addition, extend to 5 bits to capture carry
    temp = {1'b0, a} + {1'b0, b};
    s = temp[3:0]; // Assign lower 4 bits to sum
    cf = temp[4]; // Assign MSB to carry flag
    end
    endmodule
  prompt: Implement a 4-bit adder using a combinational always block and the '+' operator, providing sum and carry flag outputs.

- code: |
    module adder
    #(parameter N = 8) // Parameter for adder width, default 8
    (input wire [N-1:0] a,
    input wire [N-1:0] b,
    output reg [N-1:0] y // Sum output
    );
    always @(*) // Combinational logic
    begin
    y = a + b; // Perform N-bit addition
    end
    endmodule
  prompt: Implement a generic N-bit adder (parameter N, default 8) using a combinational always block and the '+' operator.

- code: |
    module comp
    #(parameter N = 8) // Parameter for comparator width, default 8
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than flag
    output reg eq, // Equal to flag
    output reg lt // Less than flag
    );
    always @(*) // Combinational logic
    begin
    // Default flags to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    // Set flags based on comparison
    if(x > y)
    gt = 1'b1;
    if(x == y)
    eq = 1'b1;
    if(x < y)
    lt = 1'b1;
    end
    endmodule
  prompt: Implement a generic N-bit comparator (parameter N, default 8) outputting greater-than, equal-to, and less-than flags using a combinational always block.

- code: |
    module register
    #(parameter N = 8)
    (input wire load , // Synchronous load enable
    input wire clk ,  // Clock input
    input wire clr ,  // Asynchronous clear input
    input wire [N-1:0] d , // Data input
    output reg [N-1:0] q   // Register output
    );
    always @(posedge clk or posedge clr) // Sensitive to clock and clear edges
    if(clr == 1)
    q <= 0; // Reset register if clear is asserted
    else if (load == 1) // Check load enable only if not cleared
    q <= d; // Load data if load is asserted
    // else q remains unchanged (implicit hold)
    endmodule
  prompt: Implement a generic N-bit register (parameter N, default 8) with synchronous load and positive-edge asynchronous clear using a sequential always block.

- code: |
    module test ;
    .... The semicolon ';' signifies termination of a
    statement1 ; module statement
    statement2 ;
    ...
    endmodule
  prompt: Define the basic structure of a Verilog module.

- code: |
    module nand_gate (O, I1, I2, I3, I4, I5, I6, I7, I8) ;
    ....
    statement1 ;
    statement2 ;
    ...
    endmodule
  prompt: Define the structure of a Verilog module with a port list, using an 8-input NAND gate as an example.

- code: |
    module fancy3;
    reg[11:0]a;
    always
    begin
    #0 $display("See this: ah=%d, ad=%h, ao=%o, ab=%b",a,a,a,a);
    #1 $display("How about this? ah=%0d, ad=%0h, ao=%0o, ab=%0b",a,a,a,a);
    a=a+7;
    end
    initial
    begin
    a=0;
    #10 $stop;
    end
    endmodule
  prompt: Create a module demonstrating Verilog `$display` formatting options for decimal, hex, octal, binary, and zero-padded outputs within an always block.

- code: |
    moduletest_and;
    rega1, a2;
    wireb;
    // Assuming 'and g1(b, a1, a2);' instantiates an AND gate module
    initial
    Begin
    a1 = 0;
    a2 = 0;
    #3 a1 = 1;
    #1 a1 = 0;
    #2 a2 = 1;
    #4 a1 = 1;
    #3 a2 = 0;
    #1 a2 = 1;
    end
    and g1(b, a1, a2); // Instantiation of the AND gate
    initial $monitor($time, "a1 = %b, a2 = %b, b = %b", a1, a2, b); // Corrected monitor string
    initial #100 $finish;
    endmodule
  prompt: Create a testbench `test_and` for an AND gate instance (`g1`), applying stimulus using an `initial` block and monitoring outputs with `$monitor`.

- code: |
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
  prompt: Implement an AOI gate structurally using Verilog `and` and `nor` gate primitives.

- code: |
    module aoi_st;
    reg a1,a2,b1,b2;
    //specific values will be assigned to a1,a2,b1,
    // and b2 and these connected
    //to input ports of the gate insatntiations;
    //hence these variables are declared as reg
    wire o;
    initial
    begin
    a1 = 0;
    a2 = 0;
    b1 = 0;
    b2 = 0;
    #3 a1 = 1;
    #3 a2 = 1;
    #3 b1 = 1;
    #3 b2 = 0; // Corrected: Missing semicolon was likely a typo
    #3 a1 = 1; // Corrected: Assignment seems intended
    #3 a2 = 0;
    #3 b1 = 0;
    end
    initial #100 $stop;//the simulation ends after
    //running for 100 tu's.
    initial $monitor($time , " o = %b , a1 = %b , a2 = %b , b1 = %b ,b2 = %b ",o,a1,a2,b1,b2);
    aoi_gate gg(o,a1,a2,b1,b2);
    endmodule
  prompt: Create a testbench `aoi_st` for the `aoi_gate` module (Block 9), applying stimulus and monitoring outputs.

- code: |
    module aoi_gate2(o,a);
    input [3:0]a;//A is a vector of 4 bits width
    output o;// output o is a scalar
    wire o1,o2;//these are intermediate signals
    and (o1,a[0],a[1]),(o2,a[2],a[3]);
    nor (o,o1,o2);/*The nor gate has one instantiation
    with assigned name g3.*/
    endmodule
  prompt: Implement an AOI gate with a 4-bit vector input using implicit Verilog `and` and `nor` gate instantiations.

- code: |
    module aoi_st2;
    reg[3:0] aa;
    wire o; // Added wire declaration for output 'o'
    aoi_gate2 gg(o,aa);
    initial
    begin
    aa = 4'b0000;//a being a vector, all its // Corrected: 4'b000 instead of 4'b000
    #3 aa = 4'b0001;//bit components are
    #3 aa = 4'b0010;//assigned values at one go.
    #3 aa = 4'b0100;//Similarly their changes are
    #3 aa = 4'b1000;//combined in the assignments
    #3 aa = 4'b1100;
    #3 aa = 4'b0110;
    #3 aa = 4'b0011;
    end
    initial
    $monitor( $time , " aa = %b , o = %b " , aa,o);
    initial #24 $stop;
    endmodule
  prompt: Create a testbench `aoi_st2` for the vector input AOI gate (`aoi_gate2`, Block 11), applying vector stimulus.

- code: |
    module dec2_4 (a,b,en);
    output [3:0] a;
    input [1:0]b; input en;
    wire [1:0]bb;
    not(bb[1],b[1]),(bb[0],b[0]);
    and(a[0],en, bb[1],bb[0]),(a[1],en, bb[1],b[0]),
    (a[2],en, b[1],bb[0]),(a[3],en, b[1],b[0]); // Corrected: a[3] likely depends on b[1],b[0] not b[1],bb[0]
    endmodule
  prompt: Implement a structural 2-to-4 decoder with enable using Verilog `not` and `and` primitives.

- code: |
    module tst_dec2_4();
    wire [3:0]a;
    reg[1:0] b; reg en;
    dec2_4 dec(a,b,en);
    initial
    begin
    {b,en} =3'b000;
    #2{b,en} =3'b001;
    #2{b,en} =3'b011;
    #2{b,en} =3'b101;
    #2{b,en} =3'b111;
    end
    initial
    $monitor ($time , "output a = %b, input b = %b, en = %b", a, b, en); // Added 'en' to monitor
    endmodule
  prompt: Create a testbench `tst_dec2_4` for the 2-to-4 decoder module (`dec2_4`, Block 13).

- code: |
    module dec3_8(pp,q,enn);
    output[7:0]pp;
    input[2:0]q;
    input enn;
    wire qq;
    wire[7:0]p; // Internal outputs from dec2_4
    not(qq,q[2]); // Invert MSB for selecting decoder
    // Instantiate two 2-to-4 decoders
    dec2_4 g1(.a(p[3:0]),.b(q[1:0]),.en(qq)); // Decoder for outputs 0-3 (q[2]=0)
    dec2_4 g2(.a(p[7:4]),.b(q[1:0]),.en(q[2])); // Decoder for outputs 4-7 (q[2]=1)
    // AND intermediate outputs with overall enable
    and g30(pp[0],p[0],enn);
    and g31(pp[1],p[1],enn);
    and g32(pp[2],p[2],enn);
    and g33(pp[3],p[3],enn);
    and g34(pp[4],p[4],enn);
    and g35(pp[5],p[5],enn);
    and g36(pp[6],p[6],enn);
    and g37(pp[7],p[7],enn);
    endmodule
  prompt: Implement a structural 3-to-8 decoder by instantiating two 2-to-4 decoder modules (`dec2_4`, Block 13) and AND gates for enable logic.

- code: |
    module dec4_16(m,n);
    output[15:0]m;
    input[3:0]n;
    wire nn;
    //wire en; // Unused
    not(nn,n[3]); // Invert MSB for selecting decoder
    // Instantiate two 3-to-8 decoders
    dec3_8 g3(.pp(m[7:0]),.q(n[2:0]),.enn(nn)); // Decoder for outputs 0-7 (n[3]=0)
    dec3_8 g4(.pp(m[15:8]),.q(n[2:0]),.enn(n[3])); // Decoder for outputs 8-15 (n[3]=1)
    endmodule
  prompt: Implement a structural 4-to-16 decoder by instantiating two 3-to-8 decoder modules (`dec3_8`, Block 15).

- code: |
    module comp(d,a,b,en);
    input en;
    input[7:0]a,b;
    output d;
    wire [7:0]c; // XOR results
    wire dd; // OR reduction result
    xor g1[7:0](c,b,a); // Bitwise XOR
    or(dd,c[7],c[6],c[5],c[4],c[3],c[2],c[1],c[0]); // OR reduction (explicit bits needed for standard 'or')
    notif1(d,dd,en); // Output is NOT(dd) if en=1, else Z
    endmodule
  prompt: Implement an 8-bit inequality comparator with enable using `xor` gates, reduction `or`, and a `notif1` gate (output 'd' is high if a!=b and en=1).

- code: |
    module comp_tb;
    reg[7:0]a,b;
    reg en;
    wire d; // Added wire declaration for output 'd'
    comp gg(d,a,b,en);
    initial
    begin
    a = 8'h00;
    b = 8'h00;
    en = 1'b0;
    end
    always
    #2 en = 1'b1;
    always
    begin
    #2 a = a+1'b1;
    #2 b = b+2'd2;
    end
    initial $monitor($time," en = %b , a = %h ,b = %h ,d = %b ",en,a,b,d); // Changed %b to %h for a, b
    initial #30 $stop;
    endmodule
  prompt: Create a testbench `comp_tb` for the 8-bit inequality comparator module (`comp`, Block 17), using `always` blocks for stimulus generation.

- code: |
    module ha(s,ca,a,b);
    input a,b;
    output s,ca;
    xor(s,a,b);
    and(ca,a,b);
    endmodule
  prompt: Implement a structural half adder using Verilog `xor` and `and` primitives.

- code: |
    module tstha();
    reg a,b;
    wire s,ca;
    ha hh(s,ca,a,b);
    initial
    begin
    a=0;b=0;
    end
    always
    begin
    #2 a=1;b=0;
    #2 a=0;b=1;
    #2 a=1;b=1;
    #2 a=0;b=0;
    end
    initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b " ,a,b,ca,s);
    initial #10 $stop; // Reduced stop time to see one full cycle + start
    endmodule
  prompt: Create a testbench `tstha` for the half adder module (`ha`, Block 19).

- code: |
    module fa(sum,cout,a,b,cin);
    input a,b,cin;
    output sum,cout;
    wire s,c1,c2;
    ha ha1(s,c1,a,b), ha2(sum,c2,s,cin);
    or(cout,c2,c1);
    endmodule
  prompt: Implement a structural full adder by instantiating two half adder modules (`ha`, Block 19) and an OR gate.

- code: |
    module tst_fa();
    reg a,b,cin;
    wire sum, cout; // Added wire declarations
    fa ff(sum,cout,a,b,cin);
    initial
    begin
    a =0;b=0;cin=0;
    end
    always
    begin
    #2 a=1;b=1;cin=0; #2 a=1;b=0;cin=1;
    #2 a=1;b=1;cin=1; #2 a=1;b=0;cin=0;
    #2 a=0;b=0;cin=0; #2 a=0;b=1;cin=0;
    #2 a=0;b=0;cin=1; #2 a=0;b=1;cin=1;
    //#2 a=1;b=0;cin=0; // Redundant
    //#2 a=1;b=1;cin=0; // Redundant
    //#2 a=0;b=1;cin=0; // Redundant
    //#2 a=1;b=1;cin=1; // Redundant
    end
    initial $monitor($time ," a = %b, b = %b, cin = %b, outsum = %b, outcar = %b ", a,b,cin,sum,cout);
    initial #18 $stop ; // Adjusted stop time
    endmodule
  prompt: Create a testbench `tst_fa` for the full adder module (`fa`, Block 21).

- code: |
    module mux4_1(y,i,s);
    input [3:0] i;
    input [1:0] s;
    output y;
    wire [1:0] ss; // Inverted select lines
    wire [3:0]yy; // Outputs of AND gates
    not (ss[0],s[0]),(ss[1],s[1]);
    // Logic for each select combination
    and (yy[0],i[0],ss[1],ss[0]); // s=00
    and (yy[1],i[1],ss[1],s[0]);  // s=01
    and (yy[2],i[2],s[1],ss[0]);  // s=10
    and (yy[3],i[3],s[1],s[0]);   // s=11
    // OR all AND outputs
    or (y,yy[0],yy[1],yy[2],yy[3]); // Corrected: OR gate takes multiple inputs
    endmodule
  prompt: Implement a structural 4-to-1 multiplexer using Verilog `not`, `and`, and `or` primitives.

- code: |
    module tst_mux4_1();
    reg [3:0]i;
    reg [1:0] s;
    wire y; // Added wire declaration
    mux4_1 mm(y,i,s);
    initial
    begin
    #2{i,s} = 6'b0000_00; // i=0, s=0 -> y=i[0]=0
    #2{i,s} = 6'b0001_00; // i=1, s=0 -> y=i[0]=1
    #2{i,s} = 6'b0010_01; // i=2, s=1 -> y=i[1]=1
    #2{i,s} = 6'b0100_10; // i=4, s=2 -> y=i[2]=1
    #2{i,s} = 6'b1000_11; // i=8, s=3 -> y=i[3]=1
    #2{i,s} = 6'b0001_00; // i=1, s=0 -> y=i[0]=1
    end
    initial
    $monitor($time," input s = %b, input i = %b, y = %b" ,s, i, y); // Added 'i' to monitor
    initial #14 $stop; // Added stop
    endmodule
  prompt: Create a testbench `tst_mux4_1` for the structural 4-to-1 multiplexer (`mux4_1`, Block 23).

- code: |
    module trimux4_1(o,e,i,s); // Changed name, assuming this is the intended module
    input e;
    input [1:0]s;
    input [3:0]i;
    output o;
    tri o; // Declare o as tri for bufif1 output
    wire y,y1,y2,y3,y4;
    wire [1:0]ss;
    // Standard MUX logic
    not(ss[0],s[0]),(ss[1],s[1]);
    and g1(y1,ss[1],ss[0],i[0]); // s=00
    and g2(y2,ss[1],s[0],i[1]);  // s=01
    and g3(y3,s[1],ss[0],i[2]);  // s=10
    and g4(y4,s[1],s[0],i[3]);   // s=11
    or(y,y1,y2,y3,y4); // Corrected: OR gate takes multiple inputs
    // Tristate buffer enable
    bufif1 buf2(o,y,e);
    endmodule
  prompt: Implement a 4-to-1 multiplexer using standard logic gates (`and`, `or`, `not`) followed by a tristate buffer (`bufif1`) for the output.

- code: |
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial 's' value
    end
    always
    begin
    #4 e =0; {i,s} = 3'b01_0; // e=0, out=Z
    #4 e =1; {i,s} = 3'b01_0; // e=1, s=0, out=i[0]=1
    #4 e =1; {i,s} = 3'b10_1; // e=1, s=1, out=i[1]=0
    #4 e =1; {i,s} = 3'b00_1; // e=1, s=1, out=i[1]=0
    #4 e =1; {i,s} = 3'b10_1; // e=1, s=1, out=i[1]=0
    #4 e =1; {i,s} = 3'b01_0; // e=1, s=0, out=i[0]=1
    #4 e =1; {i,s} = 3'b00_0; // e=1, s=0, out=i[0]=0
    #4 e =1; {i,s} = 3'b11_0; // e=1, s=0, out=i[0]=1
    end
    initial $monitor($time ," enable e = %b , s= %b , input i = %b ,output out = %b ",e ,s,i,out);
    initial #48 $stop;
    endmodule
  prompt: Create a testbench `ttst_ttrimux2_1` for a tristate 2-to-1 multiplexer (module definition `ttrimux2_1` not provided).

- code: |
    module ttrimux4_1(out,e,i,s);
    input[3:0]i;
    input e;
    input[1:0]s;
    output out;
    tri o; // Internal tristate wire
    tri [1:0]o1; // Internal tristate wires for first stage
    // First stage of tristate muxes (controlled by s[0])
    bufif0 g1(o1[0],i[0],s[0]); // Pass i[0] if s[0]=0
    bufif1 g2(o1[0],i[1],s[0]); // Pass i[1] if s[0]=1
    bufif0 g3(o1[1],i[2],s[0]); // Pass i[2] if s[0]=0
    bufif1 g4(o1[1],i[3],s[0]); // Pass i[3] if s[0]=1
    // Second stage of tristate muxes (controlled by s[1])
    bufif0 g5(o,o1[0],s[1]); // Pass output of first pair if s[1]=0
    bufif1 g6(o,o1[1],s[1]); // Pass output of second pair if s[1]=1
    // Final enable buffer
    bufif1 g7(out,o,e); // Pass internal result 'o' to 'out' if e=1
    endmodule
  prompt: Implement a structural 4-to-1 multiplexer with enable using tristate buffers (`bufif0`, `bufif1`) in a tree structure.

- code: |
    module sbrbff(sb,rb,q,qb);
    input sb,rb; // Set_bar, Reset_bar (active low)
    output q,qb;
    nand(q,sb,qb); // q = NOT (sb AND qb)
    nand(qb,rb,q); // qb = NOT (rb AND q)
    endmodule
  prompt: Implement a structural SR latch (active low set/reset) using two cross-coupled NAND gates.

- code: |
    module tstsbrbff; //test-bench
    reg sb,rb;
    wire q,qb;
    sbrbff ff(sb,rb,q,qb); // Corrected instance name to match module definition
    initial
    begin
    sb =1'b1; // High = Inactive
    rb =1'b0; // Low = Active (Reset) -> q=0, qb=1
    end
    always
    begin
    #2 sb =1'b1;rb =1'b1; // Both inactive (Hold) -> q=0, qb=1
    #2 sb =1'b0;rb =1'b1; // Set active -> q=1, qb=0
    #2 sb =1'b1;rb =1'b1; // Both inactive (Hold) -> q=1, qb=0
    #2 sb =1'b1;rb =1'b0; // Reset active -> q=0, qb=1
    #2 sb =1'b1;rb =1'b1; // Both inactive (Hold) -> q=0, qb=1
    end
    initial $monitor($time, " sb = %b, rb = %b, q = %b, qb = %b",sb,rb,q,qb);
    initial #12 $stop; // Adjusted stop time
    endmodule
  prompt: Create a testbench `tstsbrbff` for the active-low SR latch module (`sbrbff`, Block 28).

- code: |
    module srff(s,r,q,qb);
    input s,r; // Set, Reset (active high)
    output q,qb;
    wire ss,rr; // Internal inverted signals
    not(ss,s),(rr,r); // Invert inputs
    nand(q,ss,qb); // Core NAND latch using inverted inputs
    nand(qb,rr,q);
    endmodule
  prompt: Implement a structural SR latch (active high set/reset) using NOT and NAND gates.

- code: |
    module srffcplev(cp,s,r,q,qb);
    input cp,s,r; // Clock, Set, Reset
    output q,qb;
    wire ss,rr; // Gated inputs
    // Gate S and R inputs with clock
    nand(ss,s,cp);
    nand(rr,r,cp);
    // Core NAND latch
    nand(q,ss,qb);
    nand(qb,rr,q);
    endmodule
  prompt: Implement a structural clocked RS latch (level-sensitive) using NAND gates.

- code: |
    module srffcplev_tst;// test-bench
    reg cp,s,r;
    wire q,qb;
    srffcplev ff(cp,s,r,q,qb);
    initial
    begin
    cp=1'b0; // Clock initially low
    s =1'b1; // Initial S (ignored while cp=0)
    r =1'b0; // Initial R (ignored while cp=0)
    end
    always #2 cp=~cp; // Clock toggles every 2 time units
    always
    begin
    // cp changes at 0, 2, 4, 6, 8, 10, 12, 14, 16, 18
    // Events below happen at 0, 4, 8, 12, 16
    #4 s =1'b0;r =1'b0; // Hold (at t=4, cp=0) -> Q changes on rise at t=5
    #4 s =1'b0;r =1'b1; // Reset (at t=8, cp=0) -> Q changes on rise at t=9
    #4 s =1'b0;r =1'b0; // Hold (at t=12, cp=0) -> Q changes on rise at t=13
    #4 s =1'b1;r =1'b0; // Set (at t=16, cp=0) -> Q changes on rise at t=17
    #4 s =1'b0;r =1'b0; // Hold (at t=20, cp=0)
    end
    initial $monitor($time,"cp = %b ,s = %b , r = %b , q = %b , qb = %b " ,cp,s,r,q,qb);
    initial #22 $stop; // Adjusted stop time
    endmodule
  prompt: Create a testbench `srffcplev_tst` for the clocked RS latch module (`srffcplev`, Block 31).

- code: |
    module tstdlatch; //test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b , d = %b , q = %b , qb = %b " , en,d,q,qb);
    initial #40 $stop;
    endmodule
  prompt: Create a testbench `tstdlatch` for a D latch module (definition `dlatch` not provided).

- code: |
    module dffgatnew1(cp,d,q,qb);
    input d,cp;
    output q,qb;
    wire sb,rb; // Outputs of internal latches
    wire s,r; // Inputs to final latch
    // Instantiation of latch building blocks (definitions needed)
    sbrbffdff ff1(rb,cp,s); // Seems like a master stage component
    sbrbff1 ff2(s,d,cp,r,rb); // Seems like gating logic
    sbrbff ff3(s,r,q,qb); // Seems like a slave stage component
    endmodule
  prompt: Implement a structural D flip-flop (`dffgatnew1`) potentially using a master-slave structure by instantiating three SR latch variants (`sbrbffdff`, `sbrbff1`, `sbrbff`). Module definitions required.

- code: |
    module tst_dffgatnew1; //test-bench
    reg d,cp;
    wire q,qb;
    dffgatnew1 ff(cp,d,q,qb);
    initial // Clock generation (positive edges at 2, 6, 10, 14, ...)
    begin
    cp =1'b0;
    #2 cp =1'b1;#2 cp =1'b0;#2 cp =1'b1;#2 cp =1'b0;
    #2 cp =1'b1;#2 cp =1'b0;#2 cp =1'b1;#2 cp =1'b0;
    end
    initial // Data generation
    begin
    d=1'b0; // d=0 before edge at t=2
    #3 d=1'b1; // d=1 at t=3 (before edge at t=6)
    #2 d=1'b1; // d=1 at t=5 (before edge at t=6)
    #2 d=1'b0; // d=0 at t=7 (before edge at t=10)
    #3 d=1'b0; // d=0 at t=10 (at edge at t=10) - race condition possible
    #3 d=1'b1; // d=1 at t=13 (before edge at t=14)
    end
    initial $monitor($time," cp = %b , d = %b , q = %b , qb = %b " , cp,d,q,qb);
    initial #20 $stop; // Increased stop time
    endmodule
  prompt: Create a testbench `tst_dffgatnew1` for the structural D flip-flop module (`dffgatnew1`, Block 34).

- code: |
    module sbrbffdff(sb,rb,qb); // Likely an SR latch for DFF master/slave
    input sb,rb; // Set_bar, Reset_bar inputs
    output qb; // Only qb output?
    wire q; // Internal node
    nand(q,sb,qb);
    nand(qb,rb,q);
    endmodule
  prompt: Implement a modified SR latch (`sbrbffdff`) with only the Q-bar output, likely used within a D flip-flop structure.

- code: |
    module sbrbff1(sb,rb,cp,q,qb); // Clocked SR latch variant for DFF?
    input sb,rb,cp; // Inputs including clock
    output q,qb;
    // NAND logic, possibly gated SR or part of master stage
    nand(q,sb,cp,qb); // 3-input NAND for q? Unusual structure
    nand(qb,rb,q); // Standard cross-coupling for qb
    endmodule
  prompt: Implement a clocked SR latch variant (`sbrbff1`) with unusual 3-input NAND logic, likely used within a D flip-flop structure.

- code: |
    module netdelay(x,y);
    input x;
    output y;
    wire #2 nn; // Declare wire 'nn' with 2 time unit delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after 2 time units)
    buf (y, nn); // Assign 'nn' to 'y' (no extra delay specified for buf) // Corrected: buf syntax
    endmodule
  prompt: Demonstrate net delay declaration (`wire #2 nn`) on a wire connecting NOT and BUF gates.

- code: |
    module tst_netdelay ; //test-bench
    reg x;
    wire y;
    netdelay nd(x,y);
    initial
    begin
    x =1'b0; // At t=0, x=0 -> nn=1 (at t=2) -> y=1 (at t=2)
    #6 x = ~x; // At t=6, x=1 -> nn=0 (at t=8) -> y=0 (at t=8)
    end
    initial #10 $stop; // Adjusted stop time
    endmodule
  prompt: Create a testbench `tst_netdelay` for the net delay demonstration module (`netdelay`, Block 38).

- code: |
    module netdelay1(x,y);
    input x;
    output y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y=nn; // Assign 'nn' to 'y' (direct assignment)
    endmodule
  prompt: Demonstrate net delay declaration with rise/fall times (`wire #(2,1) nn`).

- code: |
    module tst_netdelay1; //test-bench
    reg x;
    wire y;
    netdelay1 nd(x,y);
    initial
    begin
    x =1'b0; // At t=0, x=0 -> nn rises to 1 (at t=2) -> y=1 (at t=2)
    #6 x = ~x; // At t=6, x=1 -> nn falls to 0 (at t=7) -> y=0 (at t=7)
    end
    initial #10 $stop; // Adjusted stop time
    endmodule
  prompt: Create a testbench `tst_netdelay1` for the rise/fall net delay module (`netdelay1`, Block 40).

- code: |
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule
  prompt: Instantiate OR and AND gates with specified inertial gate delays (`#3` and `#(2,1)`).

- code: |
    module tst_gade();//test-bench
    reg b,c,b1,c1;
    wire a, a1; // Corrected wire declarations, c/c1 are inputs
    gade ggde(a,a1,b,c,b1,c1);
    initial
    begin
    b =1'b0;c =1'b0;b1 =1'b0;c1=1'b0;
    end
    always
    begin
    #5 b =1'b0;c =1'b0;b1 =1'b1;c1=1'b1; // a=0, a1=1 (at t=8)
    #5 b =1'b1;c =1'b1;b1 =1'b0;c1=1'b0; // a=1 (at t=12), a1=0 (at t=13)
    #5 b =1'b1;c =1'b0;b1 =1'b1;c1=1'b0; // a=0 (at t=16), a1=1 (at t=18)
    #5 b =1'b0;c =1'b1;b1 =1'b0;c1=1'b1; // a=0, a1=1
    #5 b =1'b1;c =1'b1;b1 =1'b1;c1=1'b1; // a=1 (at t=27), a1=1
    //#5 b =1'b1;c =1'b1;b1 =1'b1;c1=1'b1; // Redundant
    end
    initial $monitor($time , " b= %b , c = %b , b1 = %b ,c1 = %b , a = %b ,a1 = %b" ,b,c,b1,c1,a,a1);
    initial #30 $stop;
    endmodule
  prompt: Create a testbench `tst_gade` for the gate delay demonstration module (`gade`, Block 42).

- code: |
    module gates(b1,b2,c1,c2,a); // Assuming 'a' is the output
    input b1,b2,c1,c2;
    output a; // Added output declaration
    wire #(2,1) a1,a2; // Intermediate wires with net delays (potentially conflicting with gate delays)
    // Instantiate gates with inertial rise/fall delays
    and #(3,4) g1(a1,b1,c1); // rise=3, fall=4
    and #(5,6) g2(a2,b2,c2); // rise=5, fall=6
    or #(8,7) g3(a,a1,a2); // rise=8, fall=7
    endmodule
  prompt: Instantiate AND and OR gates with specified inertial rise/fall gate delays (`#(3,4)`, `#(5,6)`, `#(8,7)`). Intermediate wires also have net delays.

- code: |
    module tst_gates;//test-bench
    reg b1,b2,c1,c2;
    wire a; // Added wire declaration
    gates gg(b1,b2,c1,c2,a);
    initial
    begin
    b1=1'b0;c1=1'b0;b2=1'b0;c2=1'b0;
    end
    initial #20 $stop; // Reduced stop time
    always
    begin
    #2 b1=1'b0;c1=1'b0;b2=1'b1;c2=1'b1; // a2=1 (t=2+5=7), a=1 (t=7+8=15)
    #2 b1=1'b1;c1=1'b1;b2=1'b0;c2=1'b0; // a1=1 (t=4+3=7), a2=0 (t=4+6=10), a=1 (remains 1)
    #2 b1=1'b0;c1=1'b1;b2=1'b0;c2=1'b0; // a1=0 (t=6+4=10), a=0 (t=10+7=17)
    #2 b1=1'b0;c1=1'b0;b2=1'b1;c2=1'b0; // a2=0 (t=8+6=14)
    #2 b1=1'b1;c1=1'b0;b2=1'b1;c2=1'b1; // a2=1 (t=10+5=15), a=1 (t=15+8=23)
    #2 b1=1'b1;c1=1'b1;b2=1'b0;c2=1'b0; // a1=1 (t=12+3=15), a2=0 (t=12+6=18), a=1
    #2 b1=1'b1;c1=1'b1;b2=1'b1;c2=1'b0; // a2=0 (t=14+6=20)
    #2 b1=1'b0;c1=1'b0;b2=1'b1;c2=1'b1; // a1=0 (t=16+4=20), a2=1 (t=16+5=21), a=1
    end
    initial $monitor($time," b1= %b , c1 = %b ,b2 = %b , c2 = %b , a = %b ",b1,c1,b2,c2,a);
    endmodule
  prompt: Create a testbench `tst_gates` for the rise/fall gate delay module (`gates`, Block 44).

- code: |
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule
  prompt: Demonstrate contention resolution on a `wire` net driven by two buffers both having (pull1, weak0) strength, effectively creating wired-OR logic.

- code: |
    module tst_contres; //TEST BENCH
    reg i1,i2;
    wire o; // Added wire declaration
    contres cc(o,i1,i2);
    initial
    begin
    i1 =0; // Driver 1 outputs weak0
    i2 =0; // Driver 2 outputs weak0 -> o = weak0
    end
    always
    begin
    #4 i1 =0; i2 = 1;// Driver 1: weak0, Driver 2: pull1 -> o = pull1
    #4 i1 =1; i2 = 0;// Driver 1: pull1, Driver 2: weak0 -> o = pull1
    #4 i1 =1; i2 = 1;// Driver 1: pull1, Driver 2: pull1 -> o = pull1
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #14 $stop; // Adjusted stop time
    endmodule
  prompt: Create a testbench `tst_contres` for the contention resolution module (`contres`, Block 46).

- code: |
    module contres1(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' with buffers of different strengths
    buf(strong1 ,pull0) g1(o,i1); // Driver 1: strong '1', pull '0'
    buf(pull1, pull0) g2(o,i2); // Driver 2: pull '1', pull '0'
    endmodule
  prompt: Demonstrate contention resolution on a `wire` net driven by two buffers with different strengths, (strong1, pull0) vs (pull1, pull0).

- code: |
    module tst_contres1; //TEST BENCH
    reg i1,i2;
    wire o; // Added wire declaration
    contres1 cc(o,i1,i2);
    initial
    begin
    i1 =0; i2 =0; // Drv1: pull0, Drv2: pull0 -> o = pull0
    end
    always
    begin
    #4 i1 = 0; i2 = 1; // Drv1: pull0, Drv2: pull1 -> Contention -> o = pull1 (pull1 > pull0)
    #4 i1 =1; i2 =0; // Drv1: strong1, Drv2: pull0 -> o = strong1 (strong1 > pull0)
    #4 i1 =1 ;i2 = 1; // Drv1: strong1, Drv2: pull1 -> o = strong1 (strong1 > pull1)
    end
    initial $monitor($time ," i1 = %b , i2 = %b ,o = %b " ,i1,i2,o);
    initial #14 $stop; // Adjusted stop time
    endmodule
  prompt: Create a testbench `tst_contres1` for the contention resolution module with differing strengths (`contres1`, Block 48).

- code: |
    module charge(out,in,control);
    output out;
    // Declare 'out' as a trireg net with medium capacitance (strength)
    trireg(medium) out;
    input in,control;
    // Use bufif1 to connect 'in' to 'out' when 'control' is high
    bufif1 g1(out,in,control);
    // When control goes low, 'out' retains its last driven value with 'medium' strength
    endmodule
  prompt: Model charge storage using a `trireg` with medium capacitance and a `bufif1` access switch.

- code: |
    module tst_charge; //TESTBENCH
    reg in, control;
    wire out; // Connect to trireg output
    charge c1(out,in,control);
    initial
    begin
    in =0; control =0; // control=0, bufif1 is high-Z, out=X initially
    #2 control =0; in =0; // out=X
    #2 control =1; in =0; // control=1, out driven to 0 (medium strength)
    #2 control =1; in =1; // control=1, out driven to 1 (medium strength)
    #2 control =0; in =0; // control=0, bufif1 is high-Z, out retains 1 (medium strength)
    end
    initial $monitor($time ," in= %b ,control = %b , out= %b " ,in,control,out);
    initial #10 $stop; // Adjusted stop time
    endmodule
  prompt: Create a testbench `tst_charge` for the charge storage module (`charge`, Block 50).

- code: |
    module wand1(i1,i2,o);
    input i1,i2;
    output o;
    wand o; // Declare output 'o' as wired-AND net type
    // Drive the wand net with buffers of different strengths
    buf(strong1,pull0) g1(o,i1);
    buf(pull1,pull0) g2(o,i2);
    // wand resolution: If any driver is 0, output is 0 with the strongest 0 strength.
    // If all drivers are 1 or Z, output is 1 with the weakest 1 strength.
    endmodule
  prompt: Demonstrate `wand` net type resolution driven by buffers with different strengths, (strong1, pull0) vs (pull1, pull0).

- code: |
    module tst_wand1; //testbench
    reg i1,i2;
    wire o; // Added wire declaration
    wand1 ww(i1,i2,o);
    initial
    begin
    i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    #2 i1=0; i2=1; // Drv1=pull0, Drv2=pull1 -> o = pull0 (wand rule, strongest 0)
    #2 i1=1; i2=0; // Drv1=strong1, Drv2=pull0 -> o = pull0 (wand rule, strongest 0)
    #2 i1=1; i2=1; // Drv1=strong1, Drv2=pull1 -> o = pull1 (wand rule, weakest 1)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #8 $stop; // Added stop
    endmodule
  prompt: Create a testbench `tst_wand1` for the `wand` net type demonstration module (`wand1`, Block 52).

- code: |
    module wor1(i1,i2,o);
    input i1,i2;
    output o;
    wor o; // Declare output 'o' as wired-OR net type
    // Drive the wor net with buffers of different strengths
    buf(strong1,pull0)g1(o,i1);
    buf(pull1,pull0)g2(o,i2);
    // wor resolution: If any driver is 1, output is 1 with the strongest 1 strength.
    // If all drivers are 0 or Z, output is 0 with the weakest 0 strength.
    endmodule
  prompt: Demonstrate `wor` net type resolution driven by buffers with different strengths, (strong1, pull0) vs (pull1, pull0).

- code: |
    module tst_wor1;//testbench
    reg i1,i2;
    wire o; // Added wire declaration
    wor1 ww(i1,i2,o);
    initial
    begin
    i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wor rule, weakest 0)
    #2 i1=0; i2=1; // Drv1=pull0, Drv2=pull1 -> o = pull1 (wor rule, strongest 1)
    #2 i1=1; i2=0; // Drv1=strong1, Drv2=pull0 -> o = strong1 (wor rule, strongest 1)
    #2 i1=1; i2=1; // Drv1=strong1, Drv2=pull1 -> o = strong1 (wor rule, strongest 1)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #8 $stop; // Added stop
    endmodule
  prompt: Create a testbench `tst_wor1` for the `wor` net type demonstration module (`wor1`, Block 54).

- code: |
    module add4g(sum,carry,a,b,cin);
    input[3:0]a,b;
    input cin;
    output[3:0]sum;
    output carry;
    wire [2:0]cc; // Internal carries
    // Instantiate 4 full adders (assuming 'fa' module exists)
    fa a0(sum[0],cc[0],a[0],b[0],cin); // LSB
    fa a1(sum[1],cc[1],a[1],b[1],cc[0]);
    fa a2(sum[2],cc[2],a[2],b[2],cc[1]);
    fa a3(sum[3],carry,a[3],b[3],cc[2]); // MSB
    endmodule
  prompt: Implement a structural 4-bit ripple-carry adder `add4g` by instantiating four full adder modules (`fa`).

- code: |
    module andg4(c,a,b);
    input[3:0]a,b;
    output[3:0]c;
    // Instantiate 4 AND gates for bitwise operation
    and(c[0],a[0],b[0]);
    and(c[1],a[1],b[1]);
    and(c[2],a[2],b[2]);
    and(c[3],a[3],b[3]);
    endmodule
  prompt: Implement a 4-bit bitwise AND gate `andg4` using structural `and` primitives.

- code: |
    module xorg(c,a,b);
    input[3:0]a,b;
    //input cen; // Unused input
    output[3:0]c;
    // wire [3:0]cc; // Unused wire
    // Instantiate 4 XOR gates for bitwise operation
    xor x0(c[0],a[0],b[0]);
    xor x1(c[1],a[1],b[1]);
    xor x2(c[2],a[2],b[2]);
    xor x3(c[3],a[3],b[3]);
    endmodule
  prompt: Implement a 4-bit bitwise XOR gate `xorg` using structural `xor` primitives.

- code: |
    module compl(c,a);
    input[3:0]a;
    output[3:0]c;
    // Instantiate 4 NOT gates for bitwise complement
    not(c[0],a[0]);
    not(c[1],a[1]);
    not(c[2],a[2]);
    not(c[3],a[3]);
    endmodule
  prompt: Implement a 4-bit bitwise NOT gate `compl` using structural `not` primitives.

- code: |
    module dec2_4 (a,b,en);
    output [3:0] a;
    input [1:0]b;
    input en;
    wire [1:0]bb; // Inverted inputs
    not(bb[1],b[1]),(bb[0],b[0]);
    // AND gates for decoded outputs, gated by enable
    and(a[0],en,bb[1],bb[0]), // Output 0 active when b=00
    (a[1],en,bb[1],b[0]),  // Output 1 active when b=01
    (a[2],en,b[1],bb[0]),  // Output 2 active when b=10
    (a[3],en,b[1],b[0]);   // Output 3 active when b=11 (Corrected logic: should be b[1],b[0])
    endmodule
  prompt: Implement a structural 2-to-4 decoder with enable using Verilog `not` and `and` primitives (repeat of Block 13).

- code: |
    module mux4_1alu(y,i,e); // Renamed: Represents 4 parallel tristate buffers
    input [3:0] i;
    input e; // Enable signal
    output [3:0]y;
    // Instantiate 4 tristate buffers controlled by 'e'
    bufif1 g1(y[3],i[3],e);
    bufif1 g2(y[2],i[2],e);
    bufif1 g3(y[1],i[1],e);
    bufif1 g4(y[0],i[0],e);
    endmodule
  prompt: Implement a 4-bit bus gate using four `bufif1` tristate buffers controlled by a common enable signal `e`.

- code: |
    module andgdf(c,a,b);
    output c;
    input a,b;
    // wire c; // Output 'c' should not be declared as wire here
    assign c = a && b; // Use logical AND operator
    endmodule
  prompt: Implement a 2-input AND gate `andgdf` using a dataflow `assign` statement and the `&&` operator.

- code: |
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Removed g declaration, it's an output
    // Dataflow assignments for intermediate signals and output
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g = ~g1;
    endmodule
  prompt: Implement an AOI gate `aoi2` using multiple dataflow `assign` statements with `&&` and `||` operators.

- code: |
    module aoi3(g,a,b,c,d);
    output g;
    input a,b,c,d;
    // wire g; // Output 'g' should not be declared as wire here
    // Intermediate wires with assignments in declaration
    wire e = a && b;
    wire f = c && d;
    wire g1 = e || f;
    // Final output assignment
    assign g = ~g1;
    endmodule
  prompt: Implement an AOI gate `aoi3` using dataflow `assign` statements combined with intermediate `wire` declarations.

- code: |
    module aoi4 (g, a, b, c, d);
    output g;
    input a, b, c, d;
    // wire g; // Output 'g' should not be declared as wire here
    // Intermediate signals
    wire e = a && b;
    wire f = c && d; // Corrected: && instead of & &
    wire g1 = e || f;
    // Assign output 'g' with specified strengths
    assign (pull1, strong0) g = ~g1;
    endmodule
  prompt: Implement a dataflow AOI gate `aoi4` specifying output strengths (pull1, strong0) in the `assign` statement.

- code: |
    module fancy3;
    reg[11:0]a;
    always
    begin
    #0 $display("See this: ah=%d, ad=%h, ao=%o, ab=%b",a,a,a,a);
    #1 $display("How about this? ah=%0d, ad=%0h, ao=%0o, ab=%0b",a,a,a,a);
    a=a+7;
    end
    initial
    begin
    a=0;
    #10 $stop;
    end
    endmodule
  prompt: Create a module demonstrating various `$display` format specifiers (%d, %h, %o, %b) and zero-padding within an always block.

- code: |
    moduletest_and;
    rega1, a2;
    wireb;
    // Assuming 'and' primitive or module instance
    // and g1(b, a1, a2);
    initial
    begin // Changed 'Begin' to 'begin'
    a1 = 0;
    a2 = 0;
    #3 a1 = 1;
    #1 a1 = 0;
    #2 a2 = 1;
    #4 a1 = 1;
    #3 a2 = 0;
    #1 a2 = 1;
    end
    and g1(b, a1, a2); // Instantiation assumed here based on context
    initial $monitor($time, "a1 = %b, a2 = %b, b = %b", a1, a2, b); // Corrected monitor string format
    initial #100 $finish;
    endmodule
  prompt: Create a testbench `test_and` for an AND gate, applying input stimulus using timed assignments in an initial block and monitoring outputs with `$monitor`.

- code: |
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
  prompt: Implement an AND-OR-Invert (AOI) gate structurally using Verilog `and` and `nor` gate primitives.

- code: |
    module aoi_st;
    reg a1,a2,b1,b2;
    //specific values will be assigned to a1,a2,b1,
    // and b2 and these connected
    //to input ports of the gate insatntiations;
    //hence these variables are declared as reg
    wire o;
    initial
    begin
    a1 = 0;
    a2 = 0;
    b1 = 0;
    b2 = 0;
    #3 a1 = 1;
    #3 a2 = 1;
    #3 b1 = 1;
    #3 b2 = 0;
    #3 a1 = 1;
    #3 a2 = 0;
    #3 b1 = 0;
    end
    initial #100 $stop;//the simulation ends after
    //running for 100 tu's.
    initial $monitor($time , " o = %b , a1 = %b , a2 = %b , b1 = %b ,b2 = %b ",o,a1,a2,b1,b2);
    aoi_gate gg(o,a1,a2,b1,b2);
    endmodule
  prompt: Create a testbench `aoi_st` for the structural AOI gate (`aoi_gate`), applying stimulus and monitoring outputs.

- code: |
    module aoi_gate2(o,a);
    input [3:0]a;//A is a vector of 4 bits width
    output o;// output o is a scalar
    wire o1,o2;//these are intermediate signals
    and (o1,a[0],a[1]),(o2,a[2],a[3]);
    nor (o,o1,o2);/*The nor gate has one instantiation
    with assigned name g3.*/
    endmodule
  prompt: Implement an AOI gate with a 4-bit vector input `a` using implicit Verilog `and` and `nor` gate instantiations.

- code: |
    module aoi_st2;
    reg[3:0] aa;
    wire o; // Declare output wire
    aoi_gate2 gg(o,aa);
    initial
    begin
    aa = 4'b0000;//a being a vector, all its // Corrected initial value
    #3 aa = 4'b0001;//bit components are
    #3 aa = 4'b0010;//assigned values at one go.
    #3 aa = 4'b0100;//Similarly their changes are
    #3 aa = 4'b1000;//combined in the assignments
    #3 aa = 4'b1100;
    #3 aa = 4'b0110;
    #3 aa = 4'b0011;
    end
    initial
    $monitor( $time , " aa = %b , o = %b " , aa,o);
    initial #24 $stop;
    endmodule
  prompt: Create a testbench `aoi_st2` for the vector input AOI gate (`aoi_gate2`), applying vector stimuli.

- code: |
    module dec2_4 (a,b,en);
    output [3:0] a;
    input [1:0]b; input en;
    wire [1:0]bb; // Inverted inputs
    not(bb[1],b[1]),(bb[0],b[0]);
    // AND gates for decoded outputs
    and(a[0],en, bb[1],bb[0]), // Output 0 when b=00
    (a[1],en, bb[1],b[0]),  // Output 1 when b=01
    (a[2],en, b[1],bb[0]),  // Output 2 when b=10
    (a[3],en, b[1],b[0]);   // Output 3 when b=11 (Corrected: should use b[1],b[0])
    endmodule
  prompt: Implement a structural 2-to-4 decoder with enable using Verilog `not` and `and` primitives.

- code: |
    module tst_dec2_4();
    wire [3:0]a;
    reg[1:0] b; reg en;
    dec2_4 dec(a,b,en);
    initial
    begin
    {b,en} =3'b000;
    #2{b,en} =3'b001;
    #2{b,en} =3'b011;
    #2{b,en} =3'b101;
    #2{b,en} =3'b111;
    end
    initial
    $monitor ($time , "output a = %b, input b = %b, en = %b", a, b, en); // Added 'en' to monitor
    initial #10 $stop; // Added stop
    endmodule
  prompt: Create a testbench `tst_dec2_4` for the 2-to-4 decoder module (`dec2_4`).

- code: |
    module dec3_8(pp,q,enn);
    output[7:0]pp;
    input[2:0]q;
    input enn; // Enable input
    wire qq; // Inverted MSB of q
    wire[7:0]p; // Internal outputs of the 2-to-4 decoders
    not(qq,q[2]); // Invert MSB q[2]
    // Instantiate two 2-to-4 decoders
    dec2_4 g1(.a(p[3:0]),.b(q[1:0]),.en(qq)); // Low decoder enabled when q[2]=0
    dec2_4 g2(.a(p[7:4]),.b(q[1:0]),.en(q[2])); // High decoder enabled when q[2]=1
    // AND decoder outputs with the main enable 'enn'
    and g30(pp[0],p[0],enn);
    and g31(pp[1],p[1],enn);
    and g32(pp[2],p[2],enn);
    and g33(pp[3],p[3],enn);
    and g34(pp[4],p[4],enn);
    and g35(pp[5],p[5],enn);
    and g36(pp[6],p[6],enn);
    and g37(pp[7],p[7],enn);
    endmodule
  prompt: Implement a structural 3-to-8 decoder by instantiating two 2-to-4 decoder modules (`dec2_4`) and AND gates for enable logic.

- code: |
    module dec4_16(m,n);
    output[15:0]m;
    input[3:0]n;
    wire nn; // Inverted MSB of n
    not(nn,n[3]); // Invert MSB n[3]
    // Instantiate two 3-to-8 decoders
    dec3_8 g3(.pp(m[7:0]),.q(n[2:0]),.enn(nn)); // Low decoder enabled when n[3]=0
    dec3_8 g4(.pp(m[15:8]),.q(n[2:0]),.enn(n[3])); // High decoder enabled when n[3]=1
    endmodule
  prompt: Implement a structural 4-to-16 decoder by instantiating two 3-to-8 decoder modules (`dec3_8`).

- code: |
    module comp(d,a,b,en);
    input en;
    input[7:0]a,b;
    output d; // Output high if a != b and en = 1
    wire [7:0]c; // Bitwise XOR results
    wire dd; // OR reduction result (high if any bit differs)
    xor g1[7:0](c,b,a); // Bitwise comparison
    // OR reduction to check if any bit differs
    or(dd, c[7], c[6], c[5], c[4], c[3], c[2], c[1], c[0]); // Explicit inputs for primitive OR
    // Output enabled NOT of equality
    notif1(d,dd,en); // d = NOT dd if en = 1, else Z
    endmodule
  prompt: Implement an 8-bit inequality comparator with enable using `xor`, `or`, and `notif1` primitives. Output `d` is high if `a != b` and `en` is high.

- code: |
    module comp_tb;
    reg[7:0]a,b;
    reg en;
    wire d; // Declare output wire
    comp gg(d,a,b,en);
    initial
    begin
    a = 8'h00;
    b = 8'h00;
    en = 1'b0;
    end
    always
    #2 en = 1'b1; // Enable after 2 time units
    always
    begin
    #2 a = a+1'b1; // Increment 'a' every 4 time units
    #2 b = b+2'd2; // Increment 'b' by 2 every 4 time units
    end
    initial $monitor($time," en = %b , a = %h ,b = %h ,d = %b ",en,a,b,d); // Monitor values
    initial #30 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `comp_tb` for the 8-bit inequality comparator module (`comp`).

- code: |
    module ha(s,ca,a,b);
    input a,b;
    output s,ca;
    xor(s,a,b); // Sum output
    and(ca,a,b); // Carry output
    endmodule
  prompt: Implement a structural half adder using Verilog `xor` and `and` primitives.

- code: |
    module tstha();
    reg a,b;
    wire s,ca;
    ha hh(s,ca,a,b);
    initial
    begin
    a=0;b=0;
    end
    always
    begin
    #2 a=1;b=0;
    #2 a=0;b=1;
    #2 a=1;b=1;
    #2 a=0;b=0;
    end
    initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b " ,a,b,ca,s);
    initial #10 $stop; // Stop after one cycle
    endmodule
  prompt: Create a testbench `tstha` for the half adder module (`ha`).

- code: |
    module fa(sum,cout,a,b,cin);
    input a,b,cin;
    output sum,cout;
    wire s,c1,c2; // Internal sum and carries
    ha ha1(s,c1,a,b); // First half adder for a, b
    ha ha2(sum,c2,s,cin); // Second half adder for intermediate sum and cin
    or(cout,c2,c1); // OR the carries from both half adders
    endmodule
  prompt: Implement a structural full adder by instantiating two half adder modules (`ha`) and an OR gate.

- code: |
    module tst_fa();
    reg a,b,cin;
    wire sum, cout; // Declare outputs
    fa ff(sum,cout,a,b,cin);
    initial
    begin
    a =0;b=0;cin=0;
    end
    always
    begin
    #2 a=1;b=1;cin=0; #2 a=1;b=0;cin=1;
    #2 a=1;b=1;cin=1; #2 a=1;b=0;cin=0;
    #2 a=0;b=0;cin=0; #2 a=0;b=1;cin=0;
    #2 a=0;b=0;cin=1; #2 a=0;b=1;cin=1;
    end
    initial $monitor($time ," a = %b, b = %b, cin = %b, outsum = %b, outcar = %b ", a,b,cin,sum,cout);
    initial #18 $stop ; // Adjusted stop time
    endmodule
  prompt: Create a testbench `tst_fa` for the full adder module (`fa`).

- code: |
    module mux4_1(y,i,s);
    input [3:0] i;
    input [1:0] s;
    output y;
    wire [1:0] ss; // Inverted select signals
    wire [3:0]yy; // Outputs of the AND gates
    not (ss[0],s[0]),(ss[1],s[1]);
    // AND gates select input based on 's'
    and (yy[0],i[0],ss[1],ss[0]); // s=00
    and (yy[1],i[1],ss[1],s[0]);  // s=01
    and (yy[2],i[2],s[1],ss[0]);  // s=10
    and (yy[3],i[3],s[1],s[0]);   // s=11
    // OR the outputs of the AND gates
    or (y,yy[0],yy[1],yy[2],yy[3]); // Corrected: Use yy[0]..yy[3]
    endmodule
  prompt: Implement a structural 4-to-1 multiplexer using Verilog `not`, `and`, and `or` primitives based on sum-of-products logic.

- code: |
    module tst_mux4_1();
    reg [3:0]i;
    reg [1:0] s;
    wire y; // Declare output
    mux4_1 mm(y,i,s);
    initial
    begin
    #2{i,s} = 6'b0000_00;
    #2{i,s} = 6'b0001_00;
    #2{i,s} = 6'b0010_01;
    #2{i,s} = 6'b0100_10;
    #2{i,s} = 6'b1000_11;
    #2{i,s} = 6'b0001_00;
    end
    initial
    $monitor($time," input s = %b, input i = %b, y = %b" ,s, i, y); // Added input 'i' to monitor
    initial #14 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_mux4_1` for the structural 4-to-1 multiplexer (`mux4_1`).

- code: |
    module trimux4_1(o,e,i,s); // Name suggests tristate 4-to-1 mux
    input e; // Enable
    input [1:0]s; // Select
    input [3:0]i; // Data inputs
    output o;
    tri o; // Declare output as tristate
    wire y,y1,y2,y3,y4; // Internal mux logic wires
    wire [1:0]ss; // Inverted select
    // Standard MUX logic
    not(ss[0],s[0]),(ss[1],s[1]);
    and g1(y1,ss[1],ss[0],i[0]); // s=00
    and g2(y2,ss[1],s[0],i[1]);  // s=01
    and g3(y3,s[1],ss[0],i[2]);  // s=10
    and g4(y4,s[1],s[0],i[3]);   // s=11
    or(y,y1,y2,y3,y4); // Corrected OR inputs
    // Output tristate buffer
    bufif1 buf2(o,y,e); // Output y if e=1, else Z
    endmodule
  prompt: Implement a 4-to-1 multiplexer with a tristate output using standard logic gates followed by a `bufif1` tristate buffer.

- code: |
    module ttst_ttrimux2_1(); // Testbench for tristate 2-to-1 mux
    reg e;
    reg [1:0]i; // Combined input (better as i0, i1)
    reg s;
    wire out; // Mux output
    // ttrimux2_1 mm(out,e,i,s); // Instantiation of DUT (definition not provided)
    initial
    begin
    e =0; i = 2'b00; s=1'b0; // Initialize signals
    end
    always
    begin
    // Apply sequence of inputs and enable signals
    #4 e =0; {i,s} = 3'b01_0;
    #4 e =1; {i,s} = 3'b01_0;
    #4 e =1; {i,s} = 3'b10_1;
    #4 e =1; {i,s} = 3'b00_1;
    #4 e =1; {i,s} = 3'b10_1;
    #4 e =1; {i,s} = 3'b01_0;
    #4 e =1; {i,s} = 3'b00_0;
    #4 e =1; {i,s} = 3'b11_0;
    end
    initial $monitor($time ," enable e = %b , s= %b , input i = %b ,output out = %b ",e ,s,i,out);
    initial #48 $stop;
    endmodule
  prompt: Create a testbench `ttst_ttrimux2_1` applying stimulus for a tristate 2-to-1 multiplexer (DUT module `ttrimux2_1` definition not provided).

- code: |
    module ttrimux4_1(out,e,i,s); // Tristate 4-to-1 mux using bufif primitives
    input[3:0]i;
    input e;
    input[1:0]s;
    output out;
    tri o; // Internal tristate wire (stage 2 output)
    tri [1:0]o1; // Internal tristate wires (stage 1 outputs)
    // Stage 1: Select between i[0]/i[1] and i[2]/i[3] based on s[0]
    bufif0 g1(o1[0],i[0],s[0]); // Pass i[0] if s[0]=0
    bufif1 g2(o1[0],i[1],s[0]); // Pass i[1] if s[0]=1
    bufif0 g3(o1[1],i[2],s[0]); // Pass i[2] if s[0]=0
    bufif1 g4(o1[1],i[3],s[0]); // Pass i[3] if s[0]=1
    // Stage 2: Select between stage 1 outputs based on s[1]
    bufif0 g5(o,o1[0],s[1]); // Pass o1[0] if s[1]=0
    bufif1 g6(o,o1[1],s[1]); // Pass o1[1] if s[1]=1
    // Final output enable
    bufif1 g7(out,o,e); // Pass internal result 'o' if e=1
    endmodule
  prompt: Implement a structural 4-to-1 multiplexer with enable using a tree of `bufif0` and `bufif1` tristate buffers.

- code: |
    module sbrbff(sb,rb,q,qb);
    input sb,rb; // Set_bar, Reset_bar (active low)
    output q,qb;
    nand(q,sb,qb); // Cross-coupled NAND gates
    nand(qb,rb,q);
    endmodule
  prompt: Implement a structural SR latch with active-low inputs using two cross-coupled NAND gates.

- code: |
    module tstsbrbff; //test-bench
    reg sb,rb;
    wire q,qb;
    sbrbff ff(sb,rb,q,qb); // Instantiate the latch
    initial
    begin
    sb =1'b1; // Deassert Set
    rb =1'b0; // Assert Reset -> Q=0, QB=1
    end
    always
    begin
    #2 sb =1'b1;rb =1'b1; // Hold -> Q=0, QB=1
    #2 sb =1'b0;rb =1'b1; // Assert Set -> Q=1, QB=0
    #2 sb =1'b1;rb =1'b1; // Hold -> Q=1, QB=0
    #2 sb =1'b1;rb =1'b0; // Assert Reset -> Q=0, QB=1
    #2 sb =1'b1;rb =1'b1; // Hold -> Q=0, QB=1
    end
    initial $monitor($time, " sb = %b, rb = %b, q = %b, qb = %b",sb,rb,q,qb);
    initial #12 $stop; // Adjusted simulation time
    endmodule
  prompt: Create a testbench `tstsbrbff` for the active-low SR latch module (`sbrbff`).

- code: |
    module srff(s,r,q,qb);
    input s,r; // Set, Reset (active high)
    output q,qb;
    wire ss,rr; // Internal inverted inputs
    not(ss,s),(rr,r); // Invert S and R
    // Core NAND latch using inverted inputs
    nand(q,ss,qb);
    nand(qb,rr,q);
    endmodule
  prompt: Implement a structural SR latch with active-high inputs using NOT and NAND gates.

- code: |
    module srffcplev(cp,s,r,q,qb);
    input cp,s,r; // Clock pulse (level sensitive enable), Set, Reset
    output q,qb;
    wire ss,rr; // Gated S and R inputs
    nand(ss,s,cp); // Gate S with clock
    nand(rr,r,cp); // Gate R with clock
    nand(q,ss,qb); // Core SR NAND latch
    nand(qb,rr,q);
    endmodule
  prompt: Implement a structural clocked RS latch (level-sensitive enable) using NAND gates.

- code: |
    module srffcplev_tst;// test-bench
    reg cp,s,r;
    wire q,qb;
    srffcplev ff(cp,s,r,q,qb);
    initial
    begin
    cp=1'b0; // Clock initially low (latch disabled)
    s =1'b1;
    r =1'b0;
    end
    always #2 cp=~cp; // Toggle clock every 2 time units
    always
    begin
    #4 s =1'b0;r =1'b0; // Hold applied at t=4 (while cp=0) -> state held
    #4 s =1'b0;r =1'b1; // Reset applied at t=8 (while cp=0) -> state held until cp=1 at t=9
    #4 s =1'b0;r =1'b0; // Hold applied at t=12 (while cp=0) -> state held
    #4 s =1'b1;r =1'b0; // Set applied at t=16 (while cp=0) -> state held until cp=1 at t=17
    #4 s =1'b0;r =1'b0; // Hold applied at t=20 (while cp=0) -> state held
    end
    initial $monitor($time,"cp = %b ,s = %b , r = %b , q = %b , qb = %b " ,cp,s,r,q,qb);
    initial #22 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `srffcplev_tst` for the clocked RS latch module (`srffcplev`).

- code: |
    module tstdlatch; //test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assumed instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled initially
    end
    always #4 en =~en; // Toggle enable every 4 time units
    always #8 d=~d; // Toggle data every 8 time units
    initial $monitor($time," en = %b , d = %b , q = %b , qb = %b " , en,d,q,qb);
    initial #40 $stop;
    endmodule
  prompt: Create a testbench `tstdlatch` applying stimulus for a D latch (module definition `dlatch` not provided).

- code: |
    module dffgatnew1(cp,d,q,qb);
    input d,cp;
    output q,qb;
    wire sb,rb; // Internal signals between stages
    wire s,r;   // Internal signals between stages
    // Instantiation of latch building blocks (definitions required)
    // These likely form a master-slave DFF structure
    sbrbffdff ff1(rb,cp,s); // Potential Master stage component? Input/output mapping unusual
    sbrbff1 ff2(s,d,cp,r,rb); // Potential Gating/Master stage component?
    sbrbff ff3(s,r,q,qb); // Potential Slave stage SR latch?
    endmodule
  prompt: Implement a structural D flip-flop (`dffgatnew1`) by instantiating three SR latch variants (`sbrbffdff`, `sbrbff1`, `sbrbff`), likely forming a master-slave structure. Requires sub-module definitions.

- code: |
    module tst_dffgatnew1; //test-bench
    reg d,cp;
    wire q,qb;
    dffgatnew1 ff(cp,d,q,qb);
    initial // Clock generation
    begin
    cp =1'b0;
    // Generate positive clock edges at t=2, 6, 10, 14, 18...
    #2 cp =1'b1;#2 cp =1'b0;#2 cp =1'b1;#2 cp =1'b0;
    #2 cp =1'b1;#2 cp =1'b0;#2 cp =1'b1;#2 cp =1'b0;
    end
    initial // Data generation
    begin
    d=1'b0; // D=0 before edge at t=2
    #3 d=1'b1; // D=1 at t=3 (stable before edge at t=6)
    #2 d=1'b1; // D=1 at t=5 (stable before edge at t=6)
    #2 d=1'b0; // D=0 at t=7 (stable before edge at t=10)
    #3 d=1'b0; // D=0 at t=10 (coincides with edge at t=10)
    #3 d=1'b1; // D=1 at t=13 (stable before edge at t=14)
    end
    initial $monitor($time," cp = %b , d = %b , q = %b , qb = %b " , cp,d,q,qb);
    initial #20 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_dffgatnew1` for the structural D flip-flop module (`dffgatnew1`).

- code: |
    module sbrbffdff(sb,rb,qb); // SR Latch variant for DFF?
    input sb,rb; // Set_bar, Reset_bar
    output qb; // Only Q_bar output
    wire q; // Internal Q node
    nand(q,sb,qb); // Cross-coupled NANDs
    nand(qb,rb,q);
    endmodule
  prompt: Implement a structural active-low SR latch variant (`sbrbffdff`) providing only the Q-bar output.

- code: |
    module sbrbff1(sb,rb,cp,q,qb); // Clocked SR latch variant for DFF?
    input sb,rb,cp; // Inputs include clock/enable 'cp'
    output q,qb;
    // NAND logic - unusual 3-input NAND for 'q'
    nand(q,sb,cp,qb);
    nand(qb,rb,q); // Standard cross-coupling for 'qb'
    endmodule
  prompt: Implement a structural clocked SR latch variant (`sbrbff1`) with an unusual 3-input NAND gate structure.

- code: |
    module netdelay(x,y);
    input x;
    output y;
    wire #2 nn; // Declare wire 'nn' with 2 time unit inertial delay
    not (nn,x); // NOT gate drives 'nn'
    buf (y, nn); // Buffer drives 'y' from 'nn'
    // Changes on x propagate to nn after 2tu, then immediately to y
    endmodule
  prompt: Demonstrate inertial net delay by declaring a `wire` with `#2` delay between a NOT and BUF gate.

- code: |
    module tst_netdelay ; //test-bench
    reg x;
    wire y;
    netdelay nd(x,y);
    initial
    begin
    x =1'b0; // t=0: x=0 -> nn=1 @t=2 -> y=1 @t=2
    #6 x = ~x; // t=6: x=1 -> nn=0 @t=8 -> y=0 @t=8
    end
    initial #10 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_netdelay` for the net delay demonstration module (`netdelay`).

- code: |
    module netdelay1(x,y);
    input x;
    output y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 inertial delay
    not (nn,x); // NOT gate drives 'nn'
    assign y=nn; // Assign 'nn' directly to output 'y'
    endmodule
  prompt: Demonstrate inertial net delay with separate rise and fall times using `wire #(rise, fall)` syntax.

- code: |
    module tst_netdelay1; //test-bench
    reg x;
    wire y;
    netdelay1 nd(x,y);
    initial
    begin
    x =1'b0; // t=0: x=0 -> nn rises to 1 @t=2 -> y=1 @t=2
    #6 x = ~x; // t=6: x=1 -> nn falls to 0 @t=7 -> y=0 @t=7
    end
    initial #10 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_netdelay1` for the rise/fall net delay module (`netdelay1`).

- code: |
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay of 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with inertial rise delay 2, fall delay 1
    and #(2,1) gg2(a,c,b);
    endmodule
  prompt: Instantiate OR and AND gates demonstrating inertial gate delay specification using `#delay` and `#(rise, fall)`.

- code: |
    module tst_gade();//test-bench
    reg b,c,b1,c1;
    wire a, a1; // Declare outputs
    gade ggde(a,a1,b,c,b1,c1);
    initial
    begin
    b =1'b0;c =1'b0;b1 =1'b0;c1=1'b0; // Initial state: a=0, a1=0
    end
    always
    begin
    #5 b =1'b0;c =1'b0;b1 =1'b1;c1=1'b1; // t=5: a1=1 @ t=5+3=8
    #5 b =1'b1;c =1'b1;b1 =1'b0;c1=1'b0; // t=10: a=1 @ t=10+2=12, a1=0 @ t=10+3=13
    #5 b =1'b1;c =1'b0;b1 =1'b1;c1=1'b0; // t=15: a=0 @ t=15+1=16, a1=1 @ t=15+3=18
    #5 b =1'b0;c =1'b1;b1 =1'b0;c1=1'b1; // t=20: a=0 @ t=20+1=21, a1=1 @ t=20+3=23
    #5 b =1'b1;c =1'b1;b1 =1'b1;c1=1'b1; // t=25: a=1 @ t=25+2=27, a1=1
    end
    initial $monitor($time , " b= %b , c = %b , b1 = %b ,c1 = %b , a = %b ,a1 = %b" ,b,c,b1,c1,a,a1);
    initial #30 $stop;
    endmodule
  prompt: Create a testbench `tst_gade` for the gate delay demonstration module (`gade`).

- code: |
    module gates(b1,b2,c1,c2,a); // Assumes 'a' is the output
    input b1,b2,c1,c2;
    output a; // Declare output
    wire #(2,1) a1,a2; // Intermediate wires with net delays rise=2, fall=1
    // Instantiate gates with specified inertial rise/fall delays
    and #(3,4) g1(a1,b1,c1); // rise=3, fall=4
    and #(5,6) g2(a2,b2,c2); // rise=5, fall=6
    or #(8,7) g3(a,a1,a2); // rise=8, fall=7
    endmodule
  prompt: Instantiate AND and OR gates with specified inertial rise/fall gate delays and intermediate wires with net delays.

- code: |
    module tst_gates;//test-bench
    reg b1,b2,c1,c2;
    wire a; // Declare output
    gates gg(b1,b2,c1,c2,a);
    initial
    begin
    b1=1'b0;c1=1'b0;b2=1'b0;c2=1'b0; // Initial: a1=0, a2=0, a=0
    end
    initial #20 $stop; // Stop simulation
    always
    begin
    // Apply stimulus sequence
    #2 b1=1'b0;c1=1'b0;b2=1'b1;c2=1'b1;
    #2 b1=1'b1;c1=1'b1;b2=1'b0;c2=1'b0;
    #2 b1=1'b0;c1=1'b1;b2=1'b0;c2=1'b0;
    #2 b1=1'b0;c1=1'b0;b2=1'b1;c2=1'b0;
    #2 b1=1'b1;c1=1'b0;b2=1'b1;c2=1'b1;
    #2 b1=1'b1;c1=1'b1;b2=1'b0;c2=1'b0;
    #2 b1=1'b1;c1=1'b1;b2=1'b1;c2=1'b0;
    #2 b1=1'b0;c1=1'b0;b2=1'b1;c2=1'b1;
    end
    initial $monitor($time," b1= %b , c1 = %b ,b2 = %b , c2 = %b , a = %b ",b1,c1,b2,c2,a);
    endmodule
  prompt: Create a testbench `tst_gates` for the module demonstrating combined gate and net delays (`gates`).

- code: |
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' with two buffers having pull1, weak0 strength
    buf(pull1, weak0) g1(o,i1);
    buf(pull1, weak0) g2(o,i2);
    // Contention resolution: pull1 overrides weak0, resulting in wired-OR behavior
    endmodule
  prompt: Demonstrate contention resolution on a `wire` net driven by two buffers both specified with `(pull1, weak0)` strength, resulting in wired-OR behavior.

- code: |
    module tst_contres; //TEST BENCH
    reg i1,i2;
    wire o; // Declare output
    contres cc(o,i1,i2);
    initial
    begin
    i1 =0; // Output weak0
    i2 =0; // Output weak0 -> o=weak0
    end
    always
    begin
    #4 i1 =0; i2 = 1; // weak0 vs pull1 -> o=pull1
    #4 i1 =1; i2 = 0; // pull1 vs weak0 -> o=pull1
    #4 i1 =1; i2 = 1; // pull1 vs pull1 -> o=pull1
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #14 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_contres` for the contention resolution module (`contres`).

- code: |
    module contres1(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' with buffers having different strengths
    buf(strong1 ,pull0) g1(o,i1); // Stronger driver
    buf(pull1, pull0) g2(o,i2); // Weaker driver
    endmodule
  prompt: Demonstrate contention resolution on a `wire` net driven by two buffers with differing strengths, `(strong1, pull0)` vs `(pull1, pull0)`.

- code: |
    module tst_contres1; //TEST BENCH
    reg i1,i2;
    wire o; // Declare output
    contres1 cc(o,i1,i2);
    initial
    begin
    i1 =0;i2 =0; // pull0 vs pull0 -> o=pull0
    end
    always
    begin
    #4 i1 = 0; i2 = 1; // pull0 vs pull1 -> o=pull1
    #4 i1 =1; i2 =0; // strong1 vs pull0 -> o=strong1
    #4 i1 =1 ;i2 = 1; // strong1 vs pull1 -> o=strong1
    end
    initial $monitor($time ," i1 = %b , i2 = %b ,o = %b " ,i1,i2,o);
    initial #14 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_contres1` for the contention resolution module with differing strengths (`contres1`).

- code: |
    module charge(out,in,control);
    output out;
    // Declare 'out' as a trireg net with medium capacitance strength
    trireg(medium) out;
    input in,control;
    // Controlled buffer connecting input 'in' to the trireg 'out'
    bufif1 g1(out,in,control); // Drives 'out' when control=1, high-Z otherwise
    endmodule
  prompt: Model charge storage on a net using a `trireg` declaration with `medium` capacitance and a `bufif1` controlled buffer.

- code: |
    module tst_charge; //TESTBENCH
    reg in, control;
    wire out; // Connect to the trireg output
    charge c1(out,in,control);
    initial
    begin
    in =0;control =0; // control=0 -> out=X (initial state)
    #2 control =0;in =0; // control=0 -> out=X
    #2 control =1;in =0; // control=1 -> out driven to 0 (medium)
    #2 control =1;in =1; // control=1 -> out driven to 1 (medium)
    #2 control =0;in =0; // control=0 -> out holds 1 (medium)
    end
    initial $monitor($time ," in= %b ,control = %b , out= %b " ,in,control,out);
    initial #10 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_charge` for the charge storage module (`charge`).

- code: |
    module wand1(i1,i2,o);
    input i1,i2;
    output o;
    wand o; // Declare 'o' as wired-AND net type
    // Drive the wand net with buffers of different strengths
    buf(strong1,pull0) g1(o,i1);
    buf(pull1,pull0) g2(o,i2);
    // Resolution follows wand logic: strongest 0 dominates, weakest 1 if no 0s
    endmodule
  prompt: Demonstrate `wand` (wired-AND) net type resolution driven by buffers with `(strong1, pull0)` and `(pull1, pull0)` strengths.

- code: |
    module tst_wand1; //testbench
    reg i1,i2;
    wire o; // Declare output
    wand1 ww(i1,i2,o);
    initial
    begin
    i1=0; i2=0; // pull0 vs pull0 -> wand resolves to pull0
    #2 i1=0; i2=1; // pull0 vs pull1 -> wand resolves to pull0 (strongest 0)
    #2 i1 =1; i2 =0; // strong1 vs pull0 -> wand resolves to pull0 (strongest 0)
    #2 i1 =1; i2=1; // strong1 vs pull1 -> wand resolves to pull1 (weakest 1)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #8 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_wand1` for the `wand` net type demonstration module (`wand1`).

- code: |
    module wor1(i1,i2,o);
    input i1,i2;
    output o;
    wor o; // Declare 'o' as wired-OR net type
    // Drive the wor net with buffers of different strengths
    buf(strong1,pull0)g1(o,i1);
    buf(pull1,pull0)g2(o,i2);
    // Resolution follows wor logic: strongest 1 dominates, weakest 0 if no 1s
    endmodule
  prompt: Demonstrate `wor` (wired-OR) net type resolution driven by buffers with `(strong1, pull0)` and `(pull1, pull0)` strengths.

- code: |
    module tst_wor1;//testbench
    reg i1,i2;
    wire o; // Declare output
    wor1 ww(i1,i2,o);
    initial
    begin
    i1=0; i2=0; // pull0 vs pull0 -> wor resolves to pull0 (weakest 0)
    #2 i1=0; i2=1; // pull0 vs pull1 -> wor resolves to pull1 (strongest 1)
    #2 i1 =1; i2 =0; // strong1 vs pull0 -> wor resolves to strong1 (strongest 1)
    #2 i1 =1; i2=1; // strong1 vs pull1 -> wor resolves to strong1 (strongest 1)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #8 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_wor1` for the `wor` net type demonstration module (`wor1`).

- code: |
    module add4g(sum,carry,a,b,cin);
    input[3:0]a,b;
    input cin;
    output[3:0]sum;
    output carry;
    wire [2:0]cc; // Internal carry wires
    // Instantiate 4 full adders (fa module definition required)
    fa a0(sum[0],cc[0],a[0],b[0],cin);
    fa a1(sum[1],cc[1],a[1],b[1],cc[0]);
    fa a2(sum[2],cc[2],a[2],b[2],cc[1]);
    fa a3(sum[3],carry,a[3],b[3],cc[2]);
    endmodule
  prompt: Implement a structural 4-bit ripple-carry adder `add4g` by instantiating four full adder modules (`fa`).

- code: |
    module andg4(c,a,b);
    input[3:0]a,b;
    output[3:0]c;
    // Instantiate 4 AND gates for bitwise operation
    and(c[0],a[0],b[0]);
    and(c[1],a[1],b[1]);
    and(c[2],a[2],b[2]);
    and(c[3],a[3],b[3]);
    endmodule
  prompt: Implement a 4-bit bitwise AND operation `andg4` using structural `and` primitives.

- code: |
    module xorg(c,a,b);
    input[3:0]a,b;
    //input cen; // Unused input
    output[3:0]c;
    // wire [3:0]cc; // Unused wire
    // Instantiate 4 XOR gates for bitwise operation
    xor x0(c[0],a[0],b[0]);
    xor x1(c[1],a[1],b[1]);
    xor x2(c[2],a[2],b[2]);
    xor x3(c[3],a[3],b[3]);
    endmodule
  prompt: Implement a 4-bit bitwise XOR operation `xorg` using structural `xor` primitives.

- code: |
    module compl(c,a);
    input[3:0]a;
    output[3:0]c;
    // Instantiate 4 NOT gates for bitwise complement
    not(c[0],a[0]);
    not(c[1],a[1]);
    not(c[2],a[2]);
    not(c[3],a[3]);
    endmodule
  prompt: Implement a 4-bit bitwise complement operation `compl` using structural `not` primitives.

- code: |
    module dec2_4 (a,b,en);
    output [3:0] a;
    input [1:0]b;
    input en;
    wire [1:0]bb; // Inverted inputs
    not(bb[1],b[1]),(bb[0],b[0]);
    // AND gates generate decoded outputs, enabled by 'en'
    and(a[0],en,bb[1],bb[0]), // Output 0 active for b=00
    (a[1],en,bb[1],b[0]),  // Output 1 active for b=01
    (a[2],en,b[1],bb[0]),  // Output 2 active for b=10
    (a[3],en,b[1],b[0]);   // Output 3 active for b=11 (Corrected: should be b[1], b[0])
    endmodule
  prompt: Implement a structural 2-to-4 decoder with enable using Verilog `not` and `and` primitives (repeat of Block 13).

- code: |
    module mux4_1alu(y,i,e); // Renamed: 4-bit tristate buffer array
    input [3:0] i;
    input e; // Enable input
    output [3:0]y;
    // Instantiate 4 tristate buffers
    bufif1 g1(y[3],i[3],e);
    bufif1 g2(y[2],i[2],e);
    bufif1 g3(y[1],i[1],e);
    bufif1 g4(y[0],i[0],e);
    endmodule
  prompt: Implement a 4-bit bus gate (parallel tristate buffers) using `bufif1` primitives controlled by a common enable `e`.

- code: |
    module andgdf(c,a,b);
    output c;
    input a,b;
    // Use dataflow assignment with logical AND
    assign c = a && b;
    endmodule
  prompt: Implement a 2-input AND gate `andgdf` using a dataflow `assign` statement and the logical AND operator (`&&`).

- code: |
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g = ~g1; // Final AOI output
    endmodule
  prompt: Implement an AOI gate `aoi2` using multiple dataflow `assign` statements.

- code: |
    module aoi3(g,a,b,c,d);
    output g;
    input a,b,c,d;
    // Intermediate wires with assignments in declaration
    wire e = a && b;
    wire f = c && d;
    wire g1 = e || f;
    // Final output assignment
    assign g = ~g1;
    endmodule
  prompt: Implement an AOI gate `aoi3` using dataflow `assign` statements combined directly with intermediate `wire` declarations.

- code: |
    module aoi4 (g, a, b, c, d);
    output g;
    input a, b, c, d;
    // Intermediate wires
    wire e = a && b;
    wire f = c && d; // Corrected operator
    wire g1 = e || f;
    // Assign output 'g' with specified strengths
    assign (pull1, strong0) g = ~g1;
    endmodule
  prompt: Implement a dataflow AOI gate `aoi4` and specify output strengths `(pull1, strong0)` in the `assign` statement.

- code: |
    module add_8(a,b,c);
    input[7:0]a,b;
    output[7:0]c;
    // 8-bit addition using dataflow assignment
    assign c = a + b ;
    endmodule
  prompt: Implement an 8-bit adder (no carry in/out) using a dataflow `assign` statement.

- code: |
    module add_8_c(c,cco,a,b,cci);
    input[7:0]a,b;
    output[7:0]c; // Sum output
    input cci; // Carry input
    output cco; // Carry output
    // Perform 8-bit addition with carry-in, using concatenation for carry-out
    assign {cco,c} = (a + b + cci);
    endmodule
  prompt: Implement an 8-bit adder with carry-in (`cci`) and carry-out (`cco`) using a dataflow `assign` statement and concatenation.

- code: |
    module tst_aludf1; //test-bench
    reg [3:0]a,b;
    reg[1:0] f; // Function select
    reg cci; // Carry in
    wire[3:0]d; // Output data
    wire co; // Carry out
    // alu_df1 aa(d,co,a,b,f,cci); // Assumed instantiation of ALU module
    initial
    begin
    cci= 1'b0;
    f = 2'b00;
    a = 4'b0; // Initial value (use 4'h0 for consistency)
    b = 4'h0;
    end
    always
    begin
    // Apply test vectors for different functions and operands
    #2 cci = 1'b0;f = 2'b00;a = 4'h1;b = 4'h0;
    #2 cci = 1'b1;f = 2'b00;a = 4'h8;b = 4'hf;
    #2 cci = 1'b1;f = 2'b01;a = 4'h2;b = 4'h1;
    #2 cci = 1'b0;f = 2'b01;a = 4'h3;b = 4'h7;
    #2 cci = 1'b1;f = 2'b10;a = 4'h3;b = 4'h3;
    #2 cci = 1'b1;f = 2'b11;a = 4'hf;b = 4'hc;
    end
    initial $monitor($time, " cci = %b , a= %h ,b = %h , f = %b ,d =%h ,co= %b ",cci ,a,b,f,d,co); // Use %h for hex display
    initial #14 $stop; // Adjusted stop time
    endmodule
  prompt: Create a testbench `tst_aludf1` for a 4-bit ALU (module definition `alu_df1` not provided), applying various function codes and operands.

- code: |
    module mux_df1(ao, a1, a2, a3, a4, f, en);
    // 4-to-1 Quad Mux with tristate output
    output [3:0] ao;
    input[3:0] a1, a2, a3, a4; // Data inputs
    input en; // Output enable
    input [1:0]f; // Select input
    trireg [3:0] aa0; // Internal tristate storage
    parameter d=4'hzzzz; // Use sized literal for default Z
    // Select input based on 'f' using conditional assignments to trireg
    // Multiple assigns to same net imply multiplexing behavior for trireg
    assign aa0 = (f==2'b00) ? a1 : d;
    assign aa0 = (f==2'b01) ? a2 : d;
    assign aa0 = (f==2'b10) ? a3 : d;
    assign aa0 = (f==2'b11) ? a4 : d;
    // Final output enable
    assign ao = (en) ? aa0 : d;
    endmodule
  prompt: Implement a 4-bit 4-to-1 multiplexer with tristate output using `trireg` and multiple conditional `assign` statements.

- code: |
    module bcd(co,sumd,a,b);
    input [3:0]a,b; // BCD inputs
    output [3:0]sumd; // BCD sum
    output co; // Carry out
    wire [4:0] sumb; // Changed to 5 bits for binary sum + carry
    assign sumb = a + b; // Binary addition
    // Conditional assignment for BCD correction
    assign {co,sumd}=(sumb<=5'd9)? {1'b0, sumb[3:0]} : (sumb + 5'd6); // Add 6 if sum > 9
    endmodule
  prompt: Implement a single-digit BCD adder using binary addition followed by conditional correction (+6) based on the result.

- code: |
    module tst_bcd;//Test bench
    reg [3:0]a,b;
    wire co;
    wire [3:0]sumd;
    bcd bcc(co,sumd,a,b);
    initial
    begin
    a = 4'h0 ; b = 4'h0;
    #2 a = 4'h1 ; b = 4'h0; // 1+0 = 1
    #2 a = 4'h2 ; b = 4'h1; // 2+1 = 3
    #2 a = 4'h4 ; b = 4'h5; // 4+5 = 9
    #2 a = 4'h6 ; b = 4'h6; // 6+6 = 12 -> 1_0010
    #2 a = 4'hd ; b = 4'h1; // Invalid BCD input (13+1) -> treated as binary 14 -> 1_0100
    #2 a = 4'hf ; b = 4'h0; // Invalid BCD input (15+0) -> treated as binary 15 -> 1_0101
    end
    initial $monitor($time,"a = %h, b = %h, co = %b, sumd = %h",a,b,co,sumd); // Use %h
    initial #16 $stop;
    endmodule
  prompt: Create a testbench `tst_bcd` for the BCD adder module (`bcd`).

- code: |
    module srff7474(sb, d, rb, db, q, qb); // Module name suggests 7474 DFF but implements a latch
    input sb, rb, d, db; // Two sets of SR inputs? Unusual for standard latch/FF
    output q, qb;
    // Cross-coupled NAND gates, unusual input structure
    nand(q, sb, d ,qb); // q depends on sb, d, qb
    nand(qb, rb, db, q); // qb depends on rb, db, q
    endmodule
  prompt: Implement a latch-like structure `srff7474` using cross-coupled NAND gates with two sets of inputs (sb/rb and d/db).

- code: |
    module dff7474new(cp,d,sd,rd,q,qb); // DFF with async set/reset
    input d,cp,sd,rd; // Data, Clock, Set_direct, Reset_direct
    output q,qb;
    wire sdd,rdd; // Inverted async inputs
    not(sdd,sd);
    not (rdd,rd);
    wire n1,n2,n1b,n2b; // Internal nodes
    // Instantiate three latch-like structures (srff7474 definition needed)
    // Likely forms a master-slave structure with asynchronous overrides
    srff7474 ff1(sdd,n2b,rdd,cp,n1,n1b); // Master stage input logic?
    srff7474 ff2(n1b,cp,rdd,d,n2,n2b);   // Master stage data path?
    srff7474 ff3(sdd,n1b,rdd,n2,q,qb);   // Slave stage?
    endmodule
  prompt: Implement a structural D flip-flop (`dff7474new`) with asynchronous set (`sd`) and reset (`rd`) by instantiating three `srff7474` latch modules (definition required).

- code: |
    module unishrg(clk,d,sd,rd,q,qb); // 4-bit Universal Shift Register? Name misleading, looks like parallel register
    input clk;
    input[3:0]d,sd,rd; // Parallel Data, Set, Reset inputs
    output[3:0]q,qb; // Parallel outputs
    // Instantiate 4 D flip-flops with async set/reset
    dff7474new ff1(clk,d[0],sd[0],rd[0],q[0],qb[0]);
    dff7474new ff2(clk,d[1],sd[1],rd[1],q[1],qb[1]);
    dff7474new ff3(clk,d[2],sd[2],rd[2],q[2],qb[2]);
    dff7474new ff4(clk,d[3],sd[3],rd[3],q[3],qb[3]);
    endmodule
  prompt: Implement a 4-bit parallel load register `unishrg` with asynchronous set and reset by instantiating four `dff7474new` flip-flops.

- code: |
    module rng_ctr(cen,clk,sd,rd,q,qb); // Ring Counter
    input clk,cen; // Clock, Count Enable
    input[3:0]sd,rd; // Asynchronous Set, Reset (applied to all FFs)
    output [3:0]q,qb; // Counter outputs
    wire [3:0]d; // Data inputs to the register FFs
    // Instantiate the 4-bit register
    unishrg uu(clk,d,sd,rd,q,qb);
    // Ring counter connections (rotate right)
    assign d[0] = (cen) ? q[3] : q[0]; // Corrected: Hold if cen=0
    assign d[1] = (cen) ? q[0] : q[1];
    assign d[2] = (cen) ? q[1] : q[2];
    assign d[3] = (cen) ? q[2] : q[3];
    endmodule
  prompt: Implement a 4-bit ring counter `rng_ctr` with count enable using a 4-bit register module (`unishrg`) and wiring the output `q` back to the input `d` in a rotated fashion.

- code: |
    module nil;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b", $time, a, b); // Added time
    #2 a = 1'b1;
    #3 b = 1'b1; // b changes at t=5
    #1 a = 1'b0; // a changes at t=6
    #100 $stop;
    end
    initial
    $monitor("t=%0t monitor: a = %b, b = %b", $time, a, b);
    // Monitor triggers at t=0, t=2, t=5, t=6
    endmodule
  prompt: Demonstrate the difference between `$display` (executes once) and `$monitor` (executes whenever arguments change) in an initial block.

- code: |
    module nil1;
    // initial // Cannot declare regs inside initial block start
    reg a, b;
    initial // Block 1
    begin
    a = 1'b0;
    b = 1'b0;
    $display ($time,"display block1: a = %b, b = %b", a, b);
    #2 a = 1'b1; // a changes at t=2
    #3 b = 1'b1; // b changes at t=5 from this block
    #1 a = 1'b0; // a changes at t=6
    end
    initial #100 $stop; // Stop simulation
    initial $monitor ($time, "monitor: a = %b, b = %b", a, b); // Monitor all changes
    initial // Block 2
    begin
    // b is already 0 from block 1
    #2 b = 1'b1; // b changes at t=2 from this block
    end
    endmodule
  prompt: Demonstrate the concurrent execution of multiple `initial` blocks and potential race conditions affecting `$monitor`.

- code: |
    module counterup(a,clk,N);
    input clk;
    input[3:0]N; // Upper count limit
    output[3:0]a;
    reg[3:0]a;
    initial a=4'b0000; // Initialize counter
    // Increment on negedge clk, reset to 0 when 'a' reaches 'N'
    always@(negedge clk) a=(a==N)?4'b0000:a+1'b1;
    endmodule
  prompt: Implement a behavioral N-bit up counter that counts from 0 up to an input limit `N` and then resets to 0.

- code: |
    module tst_counterup;//TEST_BENCH
    reg clk;
    reg[3:0]N;
    wire[3:0]a;
    counterup c1(a,clk,N);
    initial
    begin
    clk = 0;
    N = 4'b1011; // Set count limit to 11
    end
    always #2 clk=~clk; // Generate clock with period 4
    initial $monitor($time,"a=%d, clk=%b, N=%d",a,clk,N); // Display values
    initial #50 $stop; // Stop simulation (adjust as needed)
    endmodule
  prompt: Create a testbench `tst_counterup` for the behavioral up counter module (`counterup`).

- code: |
    module tst_counterdn();//TEST_BENCH
    reg clk;
    reg[3:0]N;
    wire[3:0]a;
    // counterdn cc(a,clk,N); // Assumed instantiation of down counter
    initial
    begin
    N = 4'b1010; // Set lower count limit (where it wraps around FROM)
    // Clk = 0; // Typo: should be clk = 0;
    clk = 0;
    end
    always #2 clk=~clk; // Generate clock
    initial $monitor($time,"a=%d, clk=%b, N=%d",a,clk,N);
    initial #55 $stop;
    endmodule
  prompt: Create a testbench `tst_counterdn` for a behavioral down counter (module `counterdn` definition not provided).

- code: |
    module updcounter(a,clk,N,u_d); // Up/Down Counter
    input clk,u_d; // Clock, Up/Down control (1=Up, 0=Down)
    input[3:0]N; // Upper limit for up count / Lower limit for down count
    output[3:0]a;
    reg[3:0]a;
    initial a =4'b0000; // Initialize counter
    always@(negedge clk)
    // If up_down=1: count up, reset to 0 if a==N
    // If up_down=0: count down, wrap to N if a==0
    a=(u_d)?((a==N)?4'b0000:a+1'b1):((a==4'b0000)?N:a-1'b1);
    endmodule
  prompt: Implement a behavioral 4-bit up/down counter with wrap-around limits based on input `N` and direction control `u_d`.

- code: |
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    always #2 clk=~clk; // Generate clock
    always #34 u_d=~u_d; // Change direction every 34 time units
    initial $monitor
    ($time,"clk=%b, N=%d, u_d=%b, a=%d",clk,N,u_d,a); // Display values
    initial #64 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_updcounter` for the behavioral up/down counter module (`updcounter`).

- code: |
    module clrupdcou(a,clr,clk,N,u_d); // Up/Down Counter with Async Clear
    input clr,clk,u_d; // Clear, Clock, Up/Down control
    input[3:0]N; // Count limit
    output[3:0]a;
    reg[3:0]a;
    initial a =4'b0000; // Initialize counter
    // Sensitive to clock edge OR clear edge
    always@(negedge clk or posedge clr)
    // Asynchronous clear takes precedence
    a=(clr)?4'h0:((u_d)?((a==N)?4'b0000:a+1'b1):((a==4'b0000)?N:a-1'b1));
    endmodule
  prompt: Implement a behavioral 4-bit up/down counter with asynchronous clear, limits based on `N`, and direction control `u_d`.

- code: |
    module tst_clrupdcou;//TEST_BENCH
    reg clr,clk,u_d;
    reg[3:0]N;
    wire [3:0]a;
    clrupdcou cc11(a,clr,clk,N,u_d);
    initial
    begin
    N = 4'b0111; // Set limit N=7
    clr = 1'b1; // Start with clear asserted
    u_d=1'b1; // Initial direction Up
    clk = 0;
    end
    always
    begin
    #2 clk = ~clk; // Generate clock
    clr = 1'b0; // Deassert clear after first clock edge
    end
    always #34 u_d = ~u_d; // Change direction periodically
    initial $monitor($time ,"clk=%b, clr=%b, u_d=%b, N=%d, a=%d",clk,clr,u_d,N,a);
    initial #60 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_clrupdcou` for the behavioral up/down counter with asynchronous clear (`clrupdcou`).

- code: |
    module tst_shifrlter;//test-bench
    reg clk,r_l; // Clock, Right/Left control (Assume 1=Right, 0=Left?)
    wire [7:0]a; // Shift register output
    // shifrlter shrr(a,clk,r_l); // Assumed instantiation of shift register module
    initial
    begin
    clk =1'b1; // Clock starts high? Usually start at 0.
    r_l = 0; // Initial direction (e.g., Left)
    end
    always #2 clk =~clk; // Generate clock
    initial #16 r_l = ~r_l; // Change direction at t=16
    initial
    $monitor($time,"clk=%b, r_l = %b, a =%b ",clk,r_l,a);
    initial #30 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_shifrlter` for an 8-bit shift register (module `shifrlter` definition not provided).

- code: |
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) do = di; // Use non-blocking <= for sequential logic
    endmodule
  prompt: Implement a simple behavioral D flip-flop triggered on the negative clock edge using an `always` block.

- code: |
    module tst_dffbeh();//test-bench
    reg di,clk;
    wire do;
    dff d1(do,di,clk); // Instantiate the DFF
    initial
    begin
    clk=0; // Initialize clock
    di=1'b0; // Initialize data input
    end
    always #3 clk=~clk; // Generate clock with period 6
    always #5 di=~di; // Toggle data every 5 time units
    initial
    $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    initial #35 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_dffbeh` for the simple behavioral D flip-flop module (`dff`).

- code: |
    module dffen(do,di,en); // Behavioral D-latch
    output do;
    input di,en; // Data input, Enable (level-sensitive)
    reg do; // Output must be reg
    initial
    do=1'b0; // Initialize output
    // Sensitive to data or enable changes
    always@(di or en)
    if(en) // If enable is high...
    do = di; // ...output follows input (transparent)
    // else: output 'do' holds its previous value
    endmodule
  prompt: Implement a behavioral D latch (level-sensitive transparent latch) using an `always` block sensitive to data and enable inputs.

- code: |
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_dffbehen` for the behavioral D latch module (`dffen`).

- code: |
    module del_dem5; // Delay demonstration 5
    integer a,b,c,d; // Use integer type (32-bit signed)
    always
    begin
    // Blocking assignments with delays
    c = #1 a; // Assign value of 'a' (sampled now) to 'c' after 1 time unit
    #2 b = a; // Assign value of 'a' (sampled after 1+2=3 time units) to 'b' after 2 more time units
    d = a; // Assign value of 'a' (sampled after 1+2=3 time units) to 'd' immediately (at t=3 relative to start)
    // Total delay in block is 1+2=3
    end
    initial
    begin
    a = 0; b = 0; c = 0; d = 0; // Initialize
    // Sequence of assignments to 'a'
    #1 a = 1; #2 a = 2; #2 a = 3; #2 a = 4; #2 a = 5; #2 a = 6; #2 a = 7; #2 a = 8;
    #2 a = 9; #2 a = 10;
    end
    initial $monitor ($time, " a = %d, b = %d, c = %d, d = %d", a, b, c, d);
    initial #25 $stop; // Stop simulation
    endmodule
  prompt: Demonstrate the effect of intra-assignment delays (`c = #1 a;`) and inter-assignment delays (`#2 b = a;`) within a blocking `always` block.

- code: |
    module ctr_wt(a,clk,N,En); // Counter with wait
    input clk,En; // Clock, Enable
    input[3:0]N; // Count limit
    output[3:0]a;
    reg[3:0]a;
    initial a=4'b1111; // Initialize counter
    always
    begin
    wait(En); // Wait until Enable (En) is high
    @(negedge clk) // Then wait for negative clock edge
    a=(a==N)?4'b0000:a+1'b1; // Increment counter, wrap at N
    // Use non-blocking <= for sequential logic
    end
    endmodule
  prompt: Implement a behavioral up counter that uses a `wait(En)` statement to pause counting until an enable signal is asserted.

- code: |
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    ctr_wt c1(a,clk,N,En);
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    #5 En=1'b1; // Enable at t=5
    #20 En=1'b0; // Disable at t=25
    end
    always
    #2 clk=~clk; // Generate clock
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
  prompt: Create a testbench `tst_ctr_wt` for the counter module that uses a `wait` statement (`ctr_wt`).

- code: |
    module sr_rec(do, ack, clk, di, recv); // Serial Receiver
    output [3:0] do; // Parallel data output
    output ack; // Acknowledge signal
    input clk, recv, di; // Clock, Receive enable, Serial data input
    reg [3:0] do; reg ack;
    initial ack = 1'b0; // Initialize ack
    always begin
    wait(recv); // Wait for receive enable to go high
    // Latch 4 bits of data on subsequent negative clock edges
    @(negedge clk) do[0] = di; // Use non-blocking <=
    @(negedge clk) do[1] = di;
    @(negedge clk) do[2] = di;
    @(negedge clk) do[3] = di;
    @(negedge clk) ack = 1'b1; // Assert acknowledge after 4 bits
    // Consider adding logic to de-assert ack and wait for recv to go low
    end
    endmodule
  prompt: Implement a simple 4-bit serial data receiver using a `wait` statement and sequential `@(negedge clk)` event controls.

- code: |
    module tst_sr_rec;
    reg clk, di, recv;
    wire [3:0]do; wire ack;
    initial begin
    clk=1'b0; recv=1'b0; di=1'b0; // Initialize signals
    #5 recv=1'b1; // Assert receive enable at t=5
    end
    always #2 clk = ~clk; // Generate clock with period 4
    initial begin // Generate serial data input 'di'
    #7 di=1'b1; // Data bit 0 (sampled at negedge t=8)
    #4 di=1'b0; // Data bit 1 (sampled at negedge t=12)
    #8 di=1'b1; // Data bit 2 (sampled at negedge t=16) - Error: change too late
    #8 di=1'b0; // Data bit 3 (sampled at negedge t=20) - Error: change too late
    end
    initial $monitor($time, "clk=%b, recv=%b, di=%b, do=%b, ack=%b", clk, recv, di, do, ack); // Corrected format specifier for clk
    sr_rec rrcc(do, ack, clk, di, recv);
    initial #25 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_sr_rec` for the serial receiver module (`sr_rec`).

- code: |
    module aoibeh(o,a,b); // Behavioral AOI gate
    output o;
    input[1:0]a,b; // Vector inputs
    reg o,a1,b1,o1; // Internal regs for procedural assignment
    // Sensitive to any change in input vectors
    always@(a[1] or a[0] or b[1] or b[0]) // Or use always@(a or b) or always@(*)
    begin
    // Use reduction AND for inputs
    a1 = &a;
    b1 = &b;
    // Perform OR and NOT
    o1 = a1 || b1;
    o = ~o1;
    end
    endmodule
  prompt: Implement a behavioral AOI gate using reduction AND (`&`), logical OR (`||`), and NOT (`~`) operators within an `always` block.

- code: |
    module tst_aoibeh;
    reg [1:0]a,b;
    wire o;
    initial
    begin
    a = 2'b00; b = 2'b00; // Initialize inputs (use vector literals)
    #3 a[0] =1'b1; // a=01
    #3 a[1] =1'b1; // a=11
    #3 b[0] =1'b1; // b=01
    #3 b[1] =1'b0; // b=01 (no change)
    #3 a[0] =1'b1; // a=11 (no change)
    #3 a[1] =1'b0; // a=01
    #3 b[0] =1'b0; // b=00
    end
    initial #24 $stop; // Increased stop time
    initial $monitor($time, "o=%b, a=%b, b=%b",o,a,b); // Simplified monitor
    aoibeh gg(o,a,b);
    endmodule
  prompt: Create a testbench `tst_aoibeh` for the behavioral AOI gate module (`aoibeh`).

- code: |
    module aoibeh1(o,a,b); // Compact behavioral AOI
    output o;
    input[1:0]a,b; // Vector inputs
    reg o; // Output must be reg
    // Single-line assignment within always block
    always@(a[1] or a[0] or b[1] or b[0]) // Or use always@(a or b) or always@(*)
    o = ~((&a) || (&b)); // Combined reduction AND, logical OR, logical NOT
    endmodule
  prompt: Implement a compact behavioral AOI gate using reduction AND, logical OR, and logical NOT directly in a single procedural assignment.

- code: |
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
  prompt: Implement an AOI gate using structural `and` primitives and a behavioral `always` block for the final NOR operation.

- code: |
    module aoibeh3(o,a,b); // Mixed dataflow/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Intermediate signals
    reg o; // Behavioral output must be reg
    // Dataflow assignments for AND operations using reduction operator
    assign a1=&a, b1=&b;
    // Behavioral NOR logic sensitive to intermediate signals
    always@(a1 or b1)
    o=~(a1||b1);
    endmodule
  prompt: Implement an AOI gate using dataflow `assign` statements for the AND operations and a behavioral `always` block for the final NOR operation.

- code: |
    module aoibeh4(o,a,b); // Mixed dataflow/structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Intermediate signals
    reg o; // Behavioral output must be reg
    // Dataflow assignment for one AND
    assign a1=&a;
    // Structural primitive for the other AND
    and g2(b1,b[1],b[0]);
    // Behavioral NOR logic
    always@(a1 or b1)
    o=~(a1||b1);
    endmodule
  prompt: Implement an AOI gate using a mix of dataflow (`assign`), structural (`and`), and behavioral (`always`) modeling styles.

- code: |
    module nil1 (c1, a, b); // Blocking delay example
      output c1;
      input a, b;
      reg c1;
      // Blocking assignment with #3 delay
      // Execution pauses here for 3 time units before assigning a&b to c1
      always @(a or b)
        #3 c1 = a&b;
    endmodule

    module nil2 (c2, a, b); // Non-blocking delay example
      output c2;
      input a, b;
      reg c2;
      // Non-blocking intra-assignment delay
      // a&b is evaluated now, scheduled to be assigned to c2 after 3 time units
      always @(a or b)
        c2 <= #3 (a&b); // Use non-blocking <=
    endmodule
  prompt: Compare blocking inter-assignment delay (`#3 c1 = ...`) with non-blocking intra-assignment delay (`c2 <= #3 ...`) within `always` blocks.

- code: |
    module dec2_4beh(o,i); // Behavioral 2-to-4 decoder
    output[3:0]o;
    input[1:0]i; // 2-bit input
    reg[3:0]o; // Output must be reg
    always@(i) // Sensitive to input changes
    begin
    case(i) // Select based on input 'i'
    2'b00: o = 4'b0001; // Output 0 active
    2'b01: o = 4'b0010; // Output 1 active
    2'b10: o = 4'b0100; // Output 2 active
    2'b11: o = 4'b1000; // Output 3 active
    default: // Handle unexpected values (like x or z)
    begin
    $display ("error: Invalid input %b", i); // Display error
    o = 4'b0000; // Default output
    end
    endcase
    end
    endmodule
  prompt: Implement a behavioral 2-to-4 decoder using an `always` block and a `case` statement. Output is one-hot active high.

- code: |
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    #2 i =2'b01;
    #2 i =2'b10;
    #2 i =2'b11;
    #2 i =2'b11; // Repeat input 11
    #2 i =2'b0x; // Test default case
    end
    initial $monitor ($time , " output o = %b , input i = %b " , o ,i);
    initial #14 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_dec2_4beh` for the behavioral 2-to-4 decoder (`dec2_4beh`).

- code: |
    module dec2_4beh1(o,i); // Behavioral 2-to-4 decoder handling 'x'
    output[3:0]o;
    input[1:0]i;
    reg[3:0]o;
    always@(i)
    begin
    o = 4'b0000; // Default output to 0 before case evaluation
    case(i)
    2'b00: o[0]=1'b1;
    2'b01: o[1]=1'b1;
    2'b10: o[2]=1'b1;
    2'b11: o[3]=1'b1;
    // Explicitly handle cases with 'x' - sets output to 0 (already default)
    2'b0x, 2'b1x, 2'bx0, 2'bx1: o=4'b0000;
    default: begin
    // Handles cases like 'z' or potentially other invalid states if possible
    $display ("error: Unhandled input %b", i);
    o=4'b0000; // Explicitly set default
    end
    endcase
    end
    endmodule
  prompt: Implement a behavioral 2-to-4 decoder using a `case` statement that explicitly handles `x` values in the input.

- code: |
    module tst_dec2_4beh1;//test bench
    wire [3:0]o;
    reg[1:0] i;
    dec2_4beh1 dec(o,i);
    initial
    begin
    i =2'b00;
    #2 i =2'b01;
    #2 i =2'b10;
    #2 i =2'b11;
    #2 i =2'b11; // Repeat 11
    #2 i =2'b1x; // Test 'x' handling
    #2 i =2'b0x;
    #2 i =2'bx0;
    #2 i =2'bx1;
    #2 i =2'bxx; // Test default case
    #2 i =2'b0z; // Test default case
    end
    initial $monitor ($time , " output o = %b , input i = %b " , o ,i);
    initial #24 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_dec2_4beh1` for the behavioral 2-to-4 decoder that handles 'x' values (`dec2_4beh1`).

- code: |
    module tst_alubeh;//test-bench
    reg[3:0]a,b;
    reg[1:0]f; // Function select
    wire[3:0]c; // ALU output
    wire s; // Status flag output? (Not used in monitor)
    // alubeh aa(c,s,a,b,f); // Assumed instantiation of behavioral ALU
    initial
    begin
    f=2'b00;a=4'b0000;b=4'b0000; // Initialize (use 4'h notation?)
    end
    always
    begin
    // Apply test vectors
    #2 f=2'b00;a=4'b0011;b=4'b0000;
    #2 f=2'b01;a=4'b0001;b=4'b0011;
    #2 f=2'b10;a=4'b1100;b=4'b1101;
    #2 f=2'b11;a=4'b1100;b=4'b1101;
    end
    initial $monitor($time,"f=%b, a=%b, b=%b, c=%b",f,a,b,c);
    initial #10 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_alubeh` applying stimulus for a 4-bit behavioral ALU (module `alubeh` definition not provided).

- code: |
    module pri_enc(a,b); // Priority Encoder
    output[1:0]a; // Encoded output
    input[3:0]b; // 4-bit input
    reg[1:0]a; // Output must be reg
    always@(b) // Sensitive to input changes
    casez(b) // Use casez for don't cares ('z')
    4'bzzz1: a=2'b00; // Input bit 0 has highest priority -> output 00
    4'bzz10: a=2'b01; // Input bit 1 has next priority -> output 01
    4'bz100: a=2'b10; // Input bit 2 has next priority -> output 10
    4'b1000: a=2'b11; // Input bit 3 has lowest priority -> output 11
    default: a=2'bxx; // Optional: Output 'x' if no bits are high
    endcase
    endmodule
  prompt: Implement a 4-to-2 behavioral priority encoder (LSB has highest priority) using an `always` block and `casez` statement.

- code: |
    module pri_enc_tst;//test-bench
    reg [3:0]b;
    wire[1:0]a;
    pri_enc pp(a,b);
    initial b=4'bzzz0; // Start with input 0
    always
    begin
    #2 b=4'bzzz1; // Input 1
    #2 b=4'bzzz1; // Repeat input 1
    #2 b=4'bzz10; // Input 2
    #2 b=4'bz100; // Input 4
    #2 b=4'b1000; // Input 8
    end
    initial $monitor($time, "input b =%b, a =%b ",b,a);
    initial #12 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `pri_enc_tst` for the behavioral priority encoder module (`pri_enc`).

- code: |
    module tst_demux();
    reg b; // Data input
    reg[1:0]s; // Select input
    wire[3:0]a; // Demux outputs
    // demux d1(a,b,s); // Assumed instantiation of 1-to-4 demux
    initial
    b=1'b0; // Initialize data input
    always
    begin
    // Cycle through select lines and toggle data
    #2 s=2'b00;b=1'b1;
    #2 s=2'b00;b=1'b0;
    #2 s=2'b01;b=1'b0;
    #2 s=2'b10;b=1'b1;
    #2 s=2'b11;b=1'b0;
    end
    initial
    $monitor("t=%0d, s=%b, b=%b, output a=%b",$time,s,b,a);
    initial #12 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_demux` applying stimulus for a 1-to-4 demultiplexer (module `demux` definition not provided).

- code: |
    module countif(a,clk); // Counter with If condition
    output[7:0]a;
    input clk;
    reg[7:0]a,n; // Counter reg, Limit reg
    initial
    begin
    n=8'h0a; // Initial limit = 10
    a=8'b00000000; // Initial count = 0
    #45 n=8'h23; // Change limit to 35 at t=45
    end
    always@(posedge clk)
    begin
    $write ("time=%0d ",$time); // Display time at each clock edge
    if(a==n) // Check if count reached limit 'n'
    a = 8'h00; // Reset if limit reached (use non-blocking <=)
    else a = a + 1'b1; // Increment otherwise (use non-blocking <=)
    end
    endmodule
  prompt: Implement a behavioral counter (`countif`) that counts up to a variable limit `n`, which can be changed during simulation.

- code: |
    module tst_countif();//test-bench
    reg clk;
    wire[7:0]a;
    countif c1(a,clk); // Instantiate the counter
    initial clk =1'b0; // Initialize clock
    always
    #2 clk=~clk; // Generate clock with period 4
    initial
    // Monitor internal limit 'n' (using hierarchical name) and output 'a'
    $monitor(" n=%h, a=%h",c1.n,a);
    initial #200 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_countif` for the counter with a variable limit (`countif`), monitoring the internal limit `n` via hierarchical reference.

- code: |
    module demux1(a0,a1,a2,a3,b,s); // Behavioral 1-to-4 Demux using assign
    output a0,a1,a2,a3; // Demux outputs
    input b; // Data input
    input [1:0]s; // Select input
    reg a0,a1,a2,a3; // Outputs must be reg for procedural assign
    always@(s or b) // Added 'b' to sensitivity list
    // Use procedural continuous assignment (assign/deassign implied by if/else)
    if(s==2'b00)
      assign {a3,a2,a1,a0} = {3'bz, b}; // Assign b to a0, others Z (Corrected order)
    else if(s==2'b01)
      assign {a3,a2,a1,a0} = {2'bz, b, 1'bz}; // Assign b to a1
    else if(s==2'b10)
      assign {a3,a2,a1,a0} = {1'bz, b, 2'bz}; // Assign b to a2
    else if(s==2'b11)
      assign {a3,a2,a1,a0} = {b, 3'bz}; // Assign b to a3
    // Need deassign logic or make always @(*) with normal assignment
    endmodule
  prompt: Implement a behavioral 1-to-4 demultiplexer using procedural continuous assignments (`assign` within an `always` block - requires deassign or rewrite). **Note:** This style is complex and often not recommended.

- code: |
    module tst_demux1();
    reg b;
    reg[1:0]s;
    wire a0,a1,a2,a3; // Declare outputs
    demux1 d2(a0,a1,a2,a3,b,s);
    initial begin b=1'b0;s=2'b0; end // Initialize
    always
    begin
    #1 s=s+1'b1; // Increment select
    $display("t=%0d, s=%b, b=%b, {a3,a2,a1,a0} =%b",$time,s,b,{a3,a2,a1,a0}); // Corrected order
    #1 b=~b; // Toggle data
    $display("t=%0d, s=%b, b=%b, {a3,a2,a1,a0} =%b",$time,s,b,{a3,a2,a1,a0});
    end
    initial #14 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_demux1` for the behavioral demultiplexer using procedural assignments (`demux1`).

- code: |
    module dffassign(q,qb,di,clk,clr,pr); // DFF with async overrides using assign/deassign
    output q,qb;
    input di,clk,clr,pr; // Data, Clock, Clear, Preset
    reg q; // Output q is reg
    assign qb=~q; // Combinational assignment for qb
    // Asynchronous override logic
    always@(clr or pr) // Sensitive to async inputs
    begin
    if(clr) assign q = 1'b0; // Override q to 0 if clr=1
    else if(pr) assign q = 1'b1; // Override q to 1 if pr=1 (priority to clr)
    else deassign q; // Release procedural assignment if neither override is active
    end
    // Synchronous logic
    always@(posedge clk)
    q <= di; // Clocked assignment (use non-blocking <=)
    // Note: q can be driven by both always blocks; procedural assign overrides continuous/clocked assignment
    endmodule
  prompt: Implement a D flip-flop with asynchronous active-high clear and preset using procedural continuous assignments (`assign`/`deassign`) to override clocked behavior.

- code: |
    module dffassign_tst();
    reg di,clk,clr,pr;
    wire q,qb;
    dffassign dd(q,qb,di,clk,clr,pr);
    initial
    begin
    clr=1'b1; pr=1'b0; clk=1'b0; di=1'b0; // Start with Clear asserted
    end
    always
    begin
    #2 clk=~clk; // Generate clock
    clr=1'b0; // Deassert clear after first edge (potential setup issue)
    end
    always
    # 4 di =~di; // Toggle data input
    always
    #16 pr=1'b1; // Assert preset at t=16
    always
    #20 pr =1'b0; // Deassert preset at t=20
    initial $monitor("t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b ", $time,clk,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `dffassign_tst` for the DFF with procedural asynchronous overrides (`dffassign`).

- code: |
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    #2 clk=~clk; // Generate clock
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=1'b1; // Assert preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b ", $time,clk,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench applying stimulus for a D flip-flop with asynchronous preset and clear (module `dffalter` definition not provided).

- code: |
    module ctr_a(a,n,clr,pr,clk); // Counter with async preset/clear using assign/deassign
    output [7:0]a;
    input [7:0]n; // Preset value
    input clr,pr,clk; // Clear, Preset, Clock
    reg[7:0]a; // Counter output must be reg
    initial a =8'h00; // Initialize counter
    // Synchronous increment
    always@(posedge clk)
    a <= a + 1'b1; // Use non-blocking <=
    // Asynchronous override logic
    always@(clr or pr)
    if (clr) assign a = 8'h00; // Override to 0 if clr=1
    else if (pr) assign a = n; // Override to preset value 'n' if pr=1
    else deassign a; // Release override
    endmodule
  prompt: Implement an 8-bit counter with asynchronous active-high clear and preset (loading value `n`) using procedural continuous assignments (`assign`/`deassign`).

- code: |
    module counprclrasgn_tst();//test-bench
    reg [7:0]n;
    reg clr,pr,clk;
    wire[7:0] a;
    ctr_a cc(a,n,clr,pr,clk); // Instantiate the counter
    initial
    begin
    n=8'h55; // Preset value
    clr=1'b1; // Start with clear asserted
    pr=1'b0; // Preset deasserted
    clk=1'b0; // Clock starts low
    end
    always
    begin
    #2 clk=~clk; // Generate clock
    clr=1'b0; // Deassert clear
    end
    always #16 pr=1'b1; // Assert preset at t=16
    always #20 pr =1'b0; // Deassert preset at t=20
    initial $monitor( $time , "clk = %b , clr = %b , pr = %b , a = %h ", clk,clr,pr,a); // Use %h for hex
    initial #44 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `counprclrasgn_tst` for the counter with procedural asynchronous preset/clear (`ctr_a`).

- code: |
    module dff_1beh_tst(); // Testbench, likely for a behavioral DFF 'dff_1beh'
    reg di,clk,clr,pr;
    wire q,qb;
    // dff_1beh dd(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    #2 clk=~clk; // Generate clock
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=1'b1; // Assert preset at t=16
    always #20 pr =1'b0; // Deassert preset at t=20
    always #24 clr=1'b1; // Assert clear at t=24
    always #28 clr =1'b0; // Deassert clear at t=28
    initial $monitor( "t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b ", $time, clk,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench applying stimulus including asynchronous preset and clear pulses for a D flip-flop (module `dff_1beh` definition not provided).

- code: |
    module trial_8a; // Module demonstrating memory array access
    reg[7:0] m[15:0]; // Declare a memory array: 16 locations of 8 bits each
    integer i; // Loop variable
    reg clk;
    always
    begin
    // Write to memory locations 0 through 7
    for(i=0; i<8; i=i+1)
    @(negedge clk) // Synchronize write to negedge clk
    m[i] = i*8;
    // Read from memory locations 0 through 7 and display
    for(i=0; i<8; i=i+1)
    @(negedge clk) // Synchronize read/display to negedge clk
    $display("t=%0d, i=%0d, m[%0d]=%0d", $time, i, i, m[i]); // Corrected m[i] index display
    end
    initial clk = 1'b0; // Initialize clock
    always #2 clk=~clk; // Generate clock
    initial #70 $stop; // Stop simulation
    endmodule
  prompt: Demonstrate writing to and reading from a Verilog memory array (`reg [7:0] m[15:0]`) synchronized to the negative clock edge within loops.

- code: |
    module sw2led (sw,ld) ;
    // ------------ Port declarations --------- //
    input [7:0] sw;
    wire [7:0] sw;
    output [7:0] ld;
    wire [7:0] ld;
    // ----------- Signal declarations -------- //
    wire [7:0] BUS7;
    // ----------- Terminals assignment --------//
    // ---- Input terminals --- //
    assign BUS7[7:0] = sw[7:0];
    // ---- Output terminals --- //
    assign ld[7:0] = BUS7[7:0];
    endmodule
  prompt: Connect 8 switches to 8 LEDs using explicit wire and assign statements.

- code: |
    module sw2led2 (
    input wire [7:0] sw ,
    output wire [7:0] ld
    ) ;
    assign ld = sw;
    endmodule
  prompt: Connect 8 switches to 8 LEDs using Verilog-2001 port style and a single assign statement.

- code: |
    module gates2 (
    input wire a,
    input wire b,
    output wire and_,
    output wire nand_,
    output wire nor_,
    output wire or_,
    output wire xnor_,
    output wire xor_
    ) ;
    assign and_ = b & a;
    assign nand_ = ~(b & a);
    assign or_ = b | a;
    assign nor_ = ~(b | a);
    assign xor_ = b ^ a;
    assign xnor_ = ~(b ^ a);
    endmodule
  prompt: Implement basic 2-input logic gates (AND, NAND, OR, NOR, XOR, XNOR) using assign statements.

- code: |
    module gates4b (
    input wire [3:0] x ,
    output wire and4_ ,
    output wire or4_ ,
    output wire xor4_
    );
    assign and4_ = &x; // Reduction AND
    assign or4_ = |x; // Reduction OR
    assign xor4_ = ^x; // Reduction XOR
    endmodule
  prompt: Implement 4-input reduction operators (AND, OR, XOR) using assign statements.

- code: |
    module gates4_top (
    input wire [3:0] sw ,
    output wire [2:0] ld
    );
    // Assuming gates4 module provides and4_, or4_, xor4_ outputs
    gates4 U1
    (
    .x(sw),         // Connect switches to input x
    .and4_(ld[2]),  // Connect reduction AND output to ld[2]
    .or4_(ld[1]),   // Connect reduction OR output to ld[1]
    .xor4_(ld[0])   // Connect reduction XOR output to ld[0]
    );
    endmodule
  prompt: Create a top-level module instantiating a 4-input reduction gate module (`gates4`) connecting switches to LEDs.

- code: |
    module eqdet2 (
    input wire [1:0] a,
    input wire [1:0] b,
    output wire eq
    ) ;
    wire eq1; // Equality of bit 1
    wire eq2; // Equality of bit 0
    assign eq1 = ~(b[1] ^ a[1]); // XNOR for bit 1
    assign eq2 = ~(b[0] ^ a[0]); // XNOR for bit 0
    assign eq = eq2 & eq1;       // Output is high if both bits are equal
    endmodule
  prompt: Implement a 2-bit equality comparator using XNOR logic with assign statements.

- code: |
    module mux21a (
    input wire a ,
    input wire b ,
    input wire s ,
    output wire y
    );
    // Standard sum-of-products implementation
    assign y = (~s & a) | (s & b);
    endmodule
  prompt: Implement a 2-to-1 multiplexer using a Boolean expression in an assign statement.

- code: |
    module mux21b (
    input wire a ,
    input wire b ,
    input wire s ,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    if(s == 0)
    y = a; // Select a if s=0
    else
    y = b; // Select b if s=1
    endmodule
  prompt: Implement a 2-to-1 multiplexer using a combinational always block and an if-else statement.

- code: |
    module mux24 (
    input wire s, // Changed semicolon to comma
    input wire [3:0] a,
    input wire [3:0] b,
    output wire [3:0] y // Changed semicolon to comma
    ) ;
    // Instantiate four 1-bit 2-to-1 muxes (mux21 module definition assumed)
    mux21 U1 ( .a(a[3]), .b(b[3]), .s(s), .y(y[3]) );
    mux21 U2 ( .a(a[2]), .b(b[2]), .s(s), .y(y[2]) );
    mux21 U3 ( .a(a[1]), .b(b[1]), .s(s), .y(y[1]) );
    mux21 U4 ( .a(a[0]), .b(b[0]), .s(s), .y(y[0]) );
    endmodule
  prompt: Implement a 4-bit 2-to-1 multiplexer structurally by instantiating four 1-bit 2-to-1 mux modules (`mux21`).

- code: |
    module mux24_top (
    input wire [0:0] btn, // Use btn[0] as select
    input wire [7:0] sw,
    output wire [3:0] ld // Changed semicolon to comma
    ) ;
    // Instantiate a 4-bit 2-to-1 mux (mux24 module definition assumed)
    mux24 U1
    ( .a(sw[7:4]), // Input a from upper 4 switches
    .b(sw[3:0]),  // Input b from lower 4 switches
    .s(btn[0]),   // Select signal
    .y(ld)        // Output to 4 LEDs
    );
    endmodule
  prompt: Create a top-level module instantiating a 4-bit 2-to-1 multiplexer (`mux24`), selecting between switch inputs based on a button.

- code: |
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*) // Combinational block
    if(s == 0)
    y = a; // Select input 'a'
    else
    y = b; // Select input 'b'
    endmodule
  prompt: Implement a 4-bit 2-to-1 multiplexer behaviorally using a combinational always block and an if-else statement.

- code: |
    module mux2g
    #(parameter N = 4) // Generic N-bit width, default 4
    (input wire [N-1:0] a,
    input wire [N-1:0] b,
    input wire s,
    output reg [N-1:0] y
    );
    always @(*) // Combinational logic
    if(s == 0)
    y = a; // Select a
    else
    y = b; // Select b
    endmodule
  prompt: Implement a generic N-bit 2-to-1 multiplexer (parameter N, default 4) behaviorally using an always block.

- code: |
    module mux28(
    input wire [7:0] a,
    input wire [7:0] b,
    input wire s,
    output wire [7:0] y
    );
    // Instantiate the generic mux with N=8
    mux2g #(
    .N(8))
    M8 (.a(a),
    .b(b),
    .s(s),
    .y(y)
    );
    endmodule
  prompt: Implement an 8-bit 2-to-1 multiplexer by instantiating a generic N-bit multiplexer module (`mux2g`) with N set to 8.

- code: |
    module mux41 (
    input wire [3:0] c , // Data inputs
    input wire [1:0] s , // Select inputs
    output wire z        // Output
    );
    // Internal signals for first stage outputs
    wire v;
    wire w;
    // Instantiate three 2-to-1 muxes (mux21 module definition assumed)
    mux21 U1 ( .a(v), .b(w), .s(s[1]), .y(z) ); // Second stage mux
    mux21 U2 ( .a(c[0]), .b(c[1]), .s(s[0]), .y(v) ); // First stage mux
    mux21 U3 ( .a(c[2]), .b(c[3]), .s(s[0]), .y(w) ); // First stage mux
    endmodule
  prompt: Implement a 4-to-1 multiplexer structurally using three instances of a 2-to-1 multiplexer module (`mux21`).

- code: |
    module mux41b (
    input wire [3:0] c ,
    input wire [1:0] s ,
    output wire z
    );
    // Dataflow implementation using Boolean expression
    assign z = (~s[1] & ~s[0] & c[0]) // Select c[0] when s=00
    | (~s[1] & s[0] & c[1]) // Select c[1] when s=01
    | (s[1] & ~s[0] & c[2]) // Select c[2] when s=10
    | (s[1] & s[0] & c[3]); // Select c[3] when s=11
    endmodule
  prompt: Implement a 4-to-1 multiplexer behaviorally using a single Boolean expression in an assign statement.

- code: |
    module mux41c (
    input wire [3:0] c ,
    input wire [1:0] s ,
    output reg z // Output must be reg
    );
    always @(*) // Combinational logic
    case(s)
    2'b00: z = c[0];
    2'b01: z = c[1];
    2'b10: z = c[2];
    2'b11: z = c[3];
    default: z = c[0]; // Default case
    endcase
    endmodule
  prompt: Implement a 4-to-1 multiplexer behaviorally using a combinational always block and a case statement.

- code: |
    module mux44 (
    input wire [15:0] x , // 16-bit input (four 4-bit groups)
    input wire [1:0] s ,  // 2-bit select
    output reg [3:0] z    // 4-bit output
    );
    always @(*) // Combinational logic
    case(s)
    2'b00: z = x[3:0];   // Select bits 3:0
    2'b01: z = x[7:4];   // Select bits 7:4
    2'b10: z = x[11:8];  // Select bits 11:8
    2'b11: z = x[15:12]; // Select bits 15:12
    default: z = x[3:0]; // Default case
    endcase
    endmodule
  prompt: Implement a quad 4-to-1 multiplexer selecting one 4-bit group from a 16-bit input using a combinational always block and a case statement.

- code: |
    module counter
    #(parameter N = 4) // Parameter for bit width, default 4
    (input wire clr , // Asynchronous clear (positive edge sensitive)
    input wire clk , // Clock input
    output reg [N-1:0] q // Counter output
    );
    always @(posedge clk or posedge clr) // Sensitive to clock and clear
    begin
    if(clr == 1)
    q <= 0; // Reset on clear
    else
    q <= q + 1; // Increment on clock edge
    end
    endmodule
  prompt: Implement a generic N-bit synchronous counter (parameter N, default 4) with positive-edge asynchronous clear using a sequential always block.

- code: |
    module clkdiv (
    input wire clk , // Master clock input (e.g., 50MHz)
    input wire clr , // Asynchronous clear input
    output wire clk190 , // ~190 Hz output
    output wire clk25 , // 25 MHz output
    output wire clk3 // ~3 Hz output
    );
    reg [23:0] q; // 24-bit counter
    always @(posedge clk or posedge clr) // Use synchronous counter logic
    begin
    if(clr == 1)
    q <= 24'b0; // Reset counter
    else
    q <= q + 1; // Increment counter
    end
    // Assign output clocks based on counter bits
    assign clk190 = q[17]; // Approx. 50MHz / 2^18
    assign clk25 = q[0]; // 50MHz / 2^1
    assign clk3 = q[23]; // Approx. 50MHz / 2^24
    endmodule
  prompt: Implement a clock divider generating multiple frequencies (~190Hz, 25MHz, ~3Hz) from a master clock using a 24-bit counter with asynchronous clear.

- code: |
    module count8_top (
    input wire mclk, // Changed semicolon to comma
    input wire [3:3] btn, // Button input (btn[3] for clear)
    output wire [7:0] ld // Changed semicolon to comma
    ) ;
    wire clk3; // Slow clock output from divider
    // Instantiate clock divider
    clkdiv U1
    ( .clk(mclk), // Changed mclk to clk to match clkdiv definition
    .clr(btn[3]),
    .clk3(clk3)
    );
    // Instantiate 8-bit counter
    counter
    #( .N(8)) // Override N parameter to 8
    U2
    ( .clk(clk3), // Clock counter with slow clock
    .clr(btn[3]), // Clear counter with button
    .q(ld[7:0]) // Output counter value to LEDs
    );
    endmodule
  prompt: Create a top-level module instantiating an 8-bit counter and a clock divider, driving the counter with the slow clock output (~3Hz) and connecting a button for clear.

- code: |
    module hex7seg_le (
    input wire [3:0] x ,
    output wire [6:0] a_to_g // Segment outputs a-g (active high assumed)
    );
    // Boolean equations for each segment (a=6, b=5, c=4, d=3, e=2, f=1, g=0)
    assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] | ~x[3] & x[2] & ~x[1] & ~x[0] | x[3] & x[2] & ~x[1] & x[0] | x[3] & ~x[2] & x[1] & x[0]; // a
    assign a_to_g[5] = x[2] & x[1] & ~x[0] | x[3] & x[1] & x[0] | ~x[3] & x[2] & ~x[1] & x[0] | x[3] & x[2] & ~x[1] & ~x[0]; // b
    assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] | x[3] & x[2] & x[1] | x[3] & x[2] & ~x[0]; // c
    assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] | ~x[3] & x[2] & ~x[1] & ~x[0] | x[3] & ~x[2] & x[1] & ~x[0] | x[2] & x[1] & x[0]; // d
    assign a_to_g[2] = ~x[3] & x[0] | ~x[3] & x[2] & ~x[1] | ~x[2] & ~x[1] & x[0]; // e
    assign a_to_g[1] = ~x[3] & ~x[2] & x[0] | ~x[3] & ~x[2] & x[1] | ~x[3] & x[1] & x[0] | x[3] & x[2] & ~x[1] & x[0]; // f
    assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] | x[3] & x[2] & ~x[1] & ~x[0] | ~x[3] & x[2] & x[1] & x[0]; // g
    endmodule
  prompt: Implement a Hex-to-7-segment display decoder using logic equations (sum-of-products) in assign statements (active high segments).

- code: |
    module hex7seg (
    input wire [3:0] x , // 4-bit hex input
    output reg [6:0] a_to_g // 7-segment output (common cathode, active low)
    );
    always @(*) // Combinational logic
    case(x)
    4'h0: a_to_g = 7'b0000001; // 0
    4'h1: a_to_g = 7'b1001111; // 1
    4'h2: a_to_g = 7'b0010010; // 2
    4'h3: a_to_g = 7'b0000110; // 3
    4'h4: a_to_g = 7'b1001100; // 4
    4'h5: a_to_g = 7'b0100100; // 5
    4'h6: a_to_g = 7'b0100000; // 6
    4'h7: a_to_g = 7'b0001111; // 7
    4'h8: a_to_g = 7'b0000000; // 8
    4'h9: a_to_g = 7'b0000100; // 9
    4'hA: a_to_g = 7'b0001000; // A
    4'hb: a_to_g = 7'b1100000; // b
    4'hC: a_to_g = 7'b0110001; // C
    4'hd: a_to_g = 7'b1000010; // d
    4'hE: a_to_g = 7'b0110000; // E
    4'hF: a_to_g = 7'b0111000; // F
    default: a_to_g = 7'b0000001; // Default to 0
    endcase
    endmodule
  prompt: Implement a Hex-to-7-segment display decoder (common cathode, active low segments) using a behavioral always block and case statement.

- code: |
    module hex7seg_top (
    input wire [3:0] sw ,
    output wire [6:0] a_to_g ,
    output wire [3:0] an , // Anode controls
    output wire dp // Decimal point
    );
    assign an = 4'b0000; // Enable all digits (assuming common anode)
    assign dp = 1'b1; // Turn decimal point off
    hex7seg D4 (.x(sw), // Connect switches to decoder input
    .a_to_g(a_to_g) // Connect decoder output to segments
    );
    endmodule
  prompt: Create a top-level module instantiating a hex-to-7-segment decoder (`hex7seg`) to display a 4-bit switch input on all digits of a common anode display.

- code: |
    module mux7seg (
    input wire [3:0] btn, // Buttons for anode enable
    output wire [6:0] a_to_g, // Segment outputs
    output wire [3:0] an // Anode enable outputs (active low)
    );
    wire [3:0] digit; // Selected digit value
    wire [1:0] s; // Mux select signal (derived from buttons)
    wire [15:0] x; // Hardcoded value to display
    assign x = 16'h1234;
    // Instantiate decoder for the selected digit
    hex7seg U1
    ( .x(digit), .a_to_g(a_to_g));
    // Instantiate mux to select one 4-bit digit from x
    mux44 U2 // Assuming mux44 definition exists
    ( .x(x), .s(s), .z(digit));
    // Example logic to derive select signal s from buttons
    assign s[0] = btn[3] | btn[1];
    assign s[1] = btn[3] | btn[2];
    // Enable anode based on button press (active low)
    assign an = ~btn;
    endmodule
  prompt: Implement a multiplexed 7-segment display driver using combinational logic to select and enable digits based on button inputs, displaying parts of 'h1234'.

- code: |
    module x7seg (
    input wire cclk, // Display refresh clock
    input wire clr, // Clear for counter
    input wire [15:0] x, // 16-bit value to display
    output wire [6:0] a_to_g, // Segment outputs
    output wire [3:0] an // Anode enables (active low)
    );
    wire nq0, nq1; // Inverted counter outputs
    wire [3:0] digit; // Selected 4-bit digit
    wire [1:0] q; // 2-bit counter for digit selection
    // Invert counter bits for anode decode logic
    assign nq1 = ~q[1];
    assign nq0 = ~q[0];
    // Active low anode selection based on counter 'q'
    // (Original logic was flawed, corrected for active low)
    assign an[0] = ~(nq1 & nq0); // Enable AN0 when q=00
    assign an[1] = ~(nq1 & q[0]); // Enable AN1 when q=01
    assign an[2] = ~(q[1] & nq0); // Enable AN2 when q=10
    assign an[3] = ~(q[1] & q[0]); // Enable AN3 when q=11
    // Instantiate hex decoder
    hex7seg U1 ( .x(digit), .a_to_g(a_to_g) );
    // Instantiate mux to select digit based on counter
    mux44 U2 ( .x(x), .s(q[1:0]), .z(digit) );
    // Instantiate 2-bit counter for scanning digits
    counter #( .N(2) ) U3 ( .clk(cclk), .clr(clr), .q(q[1:0]) );
    endmodule
  prompt: Implement a time-multiplexed 4-digit 7-segment display driver using a counter, mux, decoder, and anode control logic.

- code: |
    module x7seg_top (
    input wire mclk, // Master clock
    input wire [3:3] btn, // Button for clear
    output wire dp, // Decimal point
    output wire [6:0] a_to_g, // Segments
    output wire [3:0] an // Anodes
    );
    wire clk190; // Display refresh clock
    wire [15:0] x; // Value to display
    assign x = 16'h1234; // Hardcode value
    assign dp = 1'b1; // DP off
    // Instantiate clock divider
    clkdiv U1 ( .clk(mclk), .clr(btn[3]), .clk190(clk190) ); // Corrected port name mclk->clk
    // Instantiate multiplexed display driver
    x7seg U3 ( .x(x), .cclk(clk190), .clr(btn[3]), .a_to_g(a_to_g), .an(an) );
    endmodule
  prompt: Create a top-level module instantiating a time-multiplexed 7-segment driver (`x7seg`) and clock divider (`clkdiv`) to display 'h1234'.

- code: |
    module x7segb_top (
    input wire clk , // Master clock
    input wire [3:0] btn , // Buttons (btn[3] likely clear)
    input wire [7:0] sw , // Switches
    output wire [6:0] a_to_g ,
    output wire [3:0] an ,
    output wire dp
    );
    wire [15:0] x;
    // Concatenate switches and button bits to form display data
    assign x = {sw, btn[2:0], 5'b01010}; // Input LSB = 'A'
    // Instantiate multiplexed display driver (definition 'x7segb' not provided)
    x7segb X2 (.x(x), .clk(clk), .clr(btn[3]), .a_to_g(a_to_g), .an(an), .dp(dp) );
    endmodule
  prompt: Create a top-level module instantiating a multiplexed 7-segment driver (`x7segb`) to display data formed by concatenating switches and buttons.

- code: |
    module sat4bit (
    input wire [5:0] x, // 6-bit input value
    output wire [3:0] y // 4-bit saturated output
    );
    wire c0, c1, s, xi; // Internal signals for saturation detection
    // Example saturation logic (specific function depends on number format)
    assign c1 = ~(x[4] ^ x[3]); // Condition based on upper bits
    assign xi = ~x[5];
    assign c0 = ~(x[5] ^ x[4]);
    assign s = c0 & c1; // Saturation flag
    // Mux selects saturated value or lower input bits
    mux24 U1 // Assume mux24 is 4-bit 2-to-1 mux
    ( .a({x[5], xi, xi, xi}), // Saturated value (e.g., max/min)
    .b(x[3:0]), // Pass-through value
    .s(s), // Select based on saturation flag
    .y(y) // Output
    );
    endmodule
  prompt: Implement 4-bit saturation logic for a 6-bit input using combinatorial detection logic and a 4-bit 2-to-1 multiplexer (`mux24`).

- code: |
    module sat4bit_top (
    input wire mclk,
    input wire [3:3] btn, // Button for clear
    input wire [5:0] sw, // 6-bit switch input
    output wire dp,
    output wire [6:0] a_to_g,
    output wire [3:0] an,
    output wire [5:0] ld // LEDs mirroring input switches
    );
    wire clk190; // Display clock
    wire [3:0] y; // Saturated output
    assign ld = sw; // Mirror switches to LEDs
    // Instantiate saturation logic
    sat4bit U1 ( .x(sw), .y(y) );
    // Instantiate multiplexed 7-segment display (definition 'x7segb11' not provided)
    x7segb11 U2 ( .y(y), .cclk(clk190), .clr(btn[3]), .a_to_g(a_to_g), .an(an), .dp(dp) );
    // Instantiate clock divider
    clkdiv U3 ( .clk(mclk), .clr(btn[3]), .clk190(clk190) ); // Corrected port name mclk->clk
    endmodule
  prompt: Create a top-level module instantiating saturation logic (`sat4bit`), a multiplexed 7-segment display (`x7segb11`), and a clock divider (`clkdiv`).

- code: |
    module halfadd (
    input wire a,
    input wire b,
    output wire c, // Carry out
    output wire s  // Sum
    ) ;
    assign s = b ^ a; // Sum = a XOR b
    assign c = b & a; // Carry = a AND b
    endmodule
  prompt: Implement a half adder using dataflow assign statements for sum and carry.

- code: |
    module fulladd (
    input wire a,
    input wire b,
    input wire cin,
    output wire cout,
    output wire s
    ) ;
    wire c1, c2; // Intermediate carries
    wire s1; // Intermediate sum
    // Instantiate two half adders
    halfadd U1 ( .a(a), .b(b), .c(c1), .s(s1) );
    halfadd U2 ( .a(s1), .b(cin), .c(c2), .s(s) );
    // OR the intermediate carries
    assign cout = c2 | c1;
    endmodule
  prompt: Implement a full adder structurally by instantiating two half adder modules (`halfadd`) and an OR gate.

- code: |
    module adder4 (
    input wire cin, // Changed semicolon to comma
    input wire [3:0] a,
    input wire [3:0] b,
    output wire cout, // Changed semicolon to comma
    output wire [3:0] s // Changed semicolon to comma
    ) ;
    wire c1, c2, c3; // Internal carries
    // Instantiate four full adders in a ripple-carry chain
    fulladd U4 ( .a(a[0]), .b(b[0]), .cin(cin), .cout(c1), .s(s[0]) ); // Bit 0
    fulladd U3 ( .a(a[1]), .b(b[1]), .cin(c1), .cout(c2), .s(s[1]) ); // Bit 1
    fulladd U1 ( .a(a[2]), .b(b[2]), .cin(c2), .cout(c3), .s(s[2]) ); // Bit 2
    fulladd U2 ( .a(a[3]), .b(b[3]), .cin(c3), .cout(cout), .s(s[3]) ); // Bit 3
    endmodule
  prompt: Implement a 4-bit ripple-carry adder structurally by instantiating four full adder modules (`fulladd`).

- code: |
    module adder4_top (
    input wire mclk ,
    input wire [3:3] btn , // btn[3] for clear
    input wire [7:0] sw , // Operands a=sw[7:4], b=sw[3:0]
    output wire [6:0] a_to_g ,
    output wire [3:0] an ,
    output wire dp ,
    output wire [7:0] ld // LEDs mirror switches
    );
    wire clk190, clr, c4, cin;
    wire [15:0] x; // Data for display
    wire [3:0] sum; // Adder result
    assign cin = 1'b0; // No carry-in
    assign x = {sw, 3'b000, c4, sum}; // Format data for display (inputs, carry, sum)
    assign clr = btn[3]; // Clear signal
    assign ld = sw; // Mirror inputs to LEDs
    // Instantiate 4-bit adder
    adder4 U1 (.cin(cin), .a(sw[7:4]), .b(sw[3:0]), .cout(c4), .s(sum));
    // Instantiate clock divider
    clkdiv U2 (.clk(mclk), .clr(clr), .clk190(clk190)); // Corrected port name mclk->clk
    // Instantiate 7-segment display driver (definition 'x7segb' not provided)
    x7segb U3 (.x(x), .cclk(clk190), .clr(clr), .a_to_g(a_to_g), .an(an), .dp(dp));
    endmodule
  prompt: Create a top-level module instantiating a 4-bit adder (`adder4`), clock divider (`clkdiv`), and 7-segment display (`x7segb`) to add switch inputs and display results.

- code: |
    module adder4b (
    input wire [3:0] a ,
    input wire [3:0] b ,
    output reg [3:0] s , // Sum output
    output reg cf // Carry flag output
    );
    reg [4:0] temp; // 5-bit temporary result for carry
    always @(*) // Combinational block
    begin
    temp = {1'b0, a} + {1'b0, b}; // Perform 5-bit addition
    s = temp[3:0]; // Lower 4 bits are the sum
    cf = temp[4]; // MSB is the carry out
    end
    endmodule
  prompt: Implement a 4-bit adder behaviorally using the '+' operator in an always block, providing separate sum and carry outputs.

- code: |
    module adder
    #(parameter N = 8) // Generic width N, default 8
    (input wire [N-1:0] a,
    input wire [N-1:0] b,
    output reg [N-1:0] y // Sum output
    );
    always @(*) // Combinational logic
    begin
    y = a + b; // N-bit addition
    end
    endmodule
  prompt: Implement a generic N-bit adder (parameter N, default 8) behaviorally using the '+' operator in a combinational always block.

- code: |
    module comp
    #(parameter N = 8) // Generic width N, default 8
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    always @(*) // Combinational logic
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    // Set flags based on comparison results
    if(x > y)
    gt = 1'b1;
    if(x == y)
    eq = 1'b1;
    if(x < y)
    lt = 1'b1;
    end
    endmodule
  prompt: Implement a generic N-bit magnitude comparator (parameter N, default 8) behaviorally, outputting gt, eq, lt flags.

- code: |
    module register
    #(parameter N = 8)
    (input wire load , // Synchronous load enable
    input wire clk ,
    input wire clr , // Asynchronous clear (posedge sensitive)
    input wire [N-1:0] d ,
    output reg [N-1:0] q
    );
    always @(posedge clk or posedge clr)
    if(clr == 1)
    q <= {N{1'b0}}; // Clear output on reset
    else if (load == 1) // Check load only if not cleared
    q <= d; // Load input data on clock edge if load is enabled
    // else q holds its value
    endmodule
  prompt: Implement a generic N-bit register (parameter N, default 8) with synchronous load enable and positive-edge asynchronous clear.

- code: |
    module addfor(s,co,a,b,cin,en); // Adder using for loop
    output[7:0]s;
    output co;
    input[7:0]a,b;
    input en,cin; // Enable (level sensitive?), Carry in
    reg[8:0]c; // Internal carry vector
    reg co; // Output carry reg
    reg[7:0]s; // Output sum reg
    integer i;
    // This models a combinational ripple-carry adder triggered by 'en' edge
    always@( posedge en ) // Sensitive only to enable edge
    begin
    c[0] = cin; // Initialize carry chain
    for(i=0; i<=7; i=i+1) // Iterate through bits
    begin
    // Behavioral full adder stage within loop
    {c[i+1], s[i]} = (a[i] + b[i] + c[i]);
    end
    co = c[8]; // Final carry out
    end
    endmodule
  prompt: Implement an 8-bit ripple-carry adder behaviorally using a `for` loop within an `always` block triggered by `posedge en`.

- code: |
    module tst_addfor();
    wire [7:0]s;
    wire co;
    reg [7:0]a,b;
    reg en,cin;
    addfor add(s,co,a,b,cin,en);
    always #2 en=~en; // Toggle enable every 2 time units
    initial
    begin
    // Apply test vectors
    #0 en=1'b0; // Start disabled
    #1 cin=1'b0;a=8'h01;b=8'h00; // Inputs change while disabled
    #2 cin=1'b0;a=8'h01;b=8'h00; // Adder computes at t=3 (posedge en)
    #2 cin=1'b0;a=8'h01;b=8'h01;
    #2 cin=1'b0;a=8'h01;b=8'h01; // Adder computes at t=7
    #2 cin=1'b1;a=8'h01;b=8'h02;
    #2 en=1'b1;cin=1'b1;a=8'h01;b=8'h03; // Adder computes at t=11
    #2 cin=1'b0;a=8'h01;b=8'h09;
    #2 cin=1'b1;a=8'h01;b=8'h09; // Adder computes at t=15
    #2 cin=1'b0;a=8'hff;b=8'hff;
    #2 cin=1'b1;a=8'hff;b=8'hff; // Adder computes at t=19
    #2 cin=1'b1;a=8'hff;b=8'hff; // Adder computes at t=23
    end
    initial $monitor( "t=%0d, en = %b, cin = %b, a = %0h, b = %0h, s = %0h, co = %b ",$time,en,cin,a,b,s,co);
    initial #30 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_addfor` for the behavioral ripple-carry adder module (`addfor`).

- code: |
    module addfor1(s,co,a,b,cin,en,clk); // Clocked adder using for loop
    output[7:0]s;
    output co;
    input[7:0]a,b;
    input en,cin,clk; // Enable, Carry in, Clock
    reg[8:0]c; // Carry vector
    reg co; // Output carry reg
    reg[7:0]s; // Output sum reg
    integer i;
    // assign c[0]=cin; // Potential initial carry setting (commented out)
    always@(posedge en) // Sensitive to enable edge
    begin
    for(i=0; i<=7; i=i+1) // Loop through bits
    @(posedge clk) // Wait for clock edge inside loop (problematic style)
    begin
    if(i==0) c[0]=cin; // Initialize carry chain on first clock edge after enable
    // Perform bit addition, synchronized to clock within loop
    {c[i+1], s[i]} = (a[i] + b[i] + c[i]); // Use non-blocking <=
    end
    co = c[8]; // Final carry out assigned after loop finishes
    end
    endmodule
  prompt: Implement an 8-bit adder behaviorally using a `for` loop and `@(posedge clk)` within the loop, triggered by `posedge en`. **Note:** This style is generally not synthesizable and behaviorally complex.

- code: |
    module or_gate(b,a,en); // Behavioral OR gate using disable
    input [3:0]a; // 4-bit input
    input en; // Enable trigger
    output b;
    reg b; // Output must be reg
    integer i;
    always@(posedge en) // Triggered by enable edge
    begin:OR_gate // Named block
    b=1'b0; // Initialize output to 0
    for(i=0; i<=3; i=i+1) // Iterate through input bits
    if(a[i]==1'b1) // If any input bit is 1...
    begin
    b=1'b1; // ...set output to 1...
    disable OR_gate; // ...and exit the named block immediately
    end
    // If loop completes without finding a '1', b remains 0
    end
    endmodule
  prompt: Implement a 4-input OR gate behaviorally using a `for` loop and a `disable` statement for early exit within an `always` block triggered by `posedge en`.

- code: |
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    #2 en=1'b1; #2 a =4'h1; #2 en=1'b0; // Trigger OR with a=1
    #2 en=1'b1; #2 a =4'h2; #2 en=1'b0; // Trigger OR with a=2
    #2 en=1'b1; #2 a =4'h0; #2 en=1'b0; // Trigger OR with a=0
    #2 en=1'b1; #2 a =4'h3; #2 en=1'b0; // Trigger OR with a=3
    #2 en=1'b1; #2 a= 4'h4; #2 en=1'b0; // Trigger OR with a=4
    #2 en=1'b1; #2 a=4'hf; // Trigger OR with a=F
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial #30 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_or_gate` for the behavioral OR gate with disable (`or_gate`).

- code: |
    module int(n,a,en); // Priority Encoder using disable
    output [3:0]n; // Encoded output (index+1 or 0)
    input en; // Enable trigger
    input[7:0]a; // 8-bit interrupt vector input
    reg [3:0]n; // Output must be reg
    integer i;
    always@(posedge en) // Triggered by enable edge
    begin:source // Named block
    n=4'b0001; // Initialize output index to 1
    for(i=0; i<=7; i=i+1'b1) // Iterate through input bits (LSB to MSB)
    if (a[i]==1'b0) // If bit is inactive (assuming active high interrupt)...
    begin
    n=n+1'b1; // ...increment index...
    if(n==4'b1001) // If index reaches 9 (meaning no active bit found)...
    n = 4'b0000; // ...set output to 0.
    end
    else disable source; // If bit is active, exit the block with current 'n'
    // If loop completes (all bits inactive), n will be 0.
    end
    endmodule
  prompt: Implement an 8-input priority encoder (LSB has highest priority, active high inputs) behaviorally using a `for` loop and `disable`. Output is index+1 or 0 if none active.

- code: |
    module tst_while2();
    reg[7:0]n;
    reg en,clk;
    wire b;
    // while2 ww(b,n,en,clk); // Assumed instantiation of module using 'while'
    initial
    begin
    n = 8'h10;clk = 1'b1;en = 1'b0; // Initialize
    #3 en = 1'b1; // Enable at t=3
    #60 en = 1'b0; // Disable at t=63
    end
    initial $monitor( " t= %0d, output b = %b , ww.a = %0d , en = %b , clk = %b ",$time,b,ww.a,en,clk); // Monitor internal variable ww.a
    always
    #2 clk =~clk; // Generate clock
    initial #80 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_while2` applying stimulus and monitoring an internal variable (`ww.a`) of a DUT (`while2`, definition not provided).

- code: |
    module trial_8c; // Memory initialization and read using loops
    reg[7:0] m[15:0]; // 16x8 memory array
    integer i;
    reg clk;
    always // Main process block
    begin
    #0 // Start immediately
    while(i<8) // Initialize first 8 locations
    @(negedge clk) // Synchronized to negedge clock
    begin
    m[i] = i * 8; // Write value i*8
    $display("initializing: t=%0d, m[%0d]=%0d", $time,i,m[i]);
    i=i+1; // Increment index
    end
    #3 // Wait 3 time units after initialization
    begin
    for(i=7; i>=0; i=i-1) // Read locations 7 down to 0
    @(negedge clk) // Synchronized to negedge clock
    $display("reading: t=%0d, m[%0d]=%0d", $time,i,m[i]);
    end
    // This always block will loop indefinitely after finishing the read
    end
    initial
    begin
    clk = 1'b0; i=0; #65 $stop; // Initialize clock, index; stop simulation
    end
    always #2 clk=~clk; // Generate clock
    endmodule
  prompt: Demonstrate Verilog memory array initialization using a `while` loop and subsequent reading using a `for` loop within an `always` block, synchronized to the clock.

- code: |
    module clock_gen_forever; // Renamed module for clarity
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        forever #2 clk = ~clk; // Toggle clock every 2 time units forever
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
        #1 clk = 1'b1; // Manual clock pulse? Unnecessary due to forever loop.
        #4 en = 1'b1; // Enable clock generation at t=5
        #30 $stop; // Stop simulation
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
  prompt: Demonstrate using a `forever` loop triggered by `posedge en` to generate a continuous clock signal.

- code: |
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    #5 en=1; // Enable MUP at t=5
    #34 int=1'b1; // Assert interrupt at t=39
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_mup` applying stimulus (enable, interrupt) and monitoring internal state variables (`rr.pc`, `rr.ir`, `rr.dcop`) of a microprocessor DUT (`mup_opr`).

- code: |
    module fk_jn_a; // Sequential execution example
      integer a;
      initial // Standard sequential block
      begin
        a=0;
        #1 a=1;
        #2 a=2; // Executes at t=1+2=3
        #3 a=3; // Executes at t=3+3=6
        #4 $stop; // Stops at t=6+4=10
      end
      initial $monitor ("a=%0d, t=%0d",a,$time);
    endmodule

    module fk_jn_b; // Parallel execution example
      integer a;
      initial
      fork // Start parallel block
        a=0; // Executes at t=0
        #1 a=1; // Executes in parallel at t=1
        #2 a=2; // Executes in parallel at t=2
        #3 a=3; // Executes in parallel at t=3
        #4 $stop; // Executes in parallel at t=4
      join // End parallel block, waits for longest thread (#4 $stop)
      initial $monitor ("a=%0d, t=%0d",a,$time);
    endmodule
  prompt: Compare sequential execution within `begin/end` versus parallel execution within `fork/join` using integer assignments with delays.

- code: |
    module fk_jn_c; // Nested fork/join
      integer a;
      initial
      begin // Outer sequential block
        #5 a=5; // Executes at t=5
        fork // Inner parallel block starts at t=5
          #1 a=0; // Executes at t=5+1=6
          #2 a=1; // Executes at t=5+2=7
          #3 a=2; // Executes at t=5+3=8
          #4 a=3; // Executes at t=5+4=9
          #5 $stop; // Executes at t=5+5=10
        join // Waits until t=10
      end // End sequential block
      initial $monitor ("a=%0d, t=%0d",a,$time);
    endmodule
  prompt: Demonstrate nesting a `fork/join` block (parallel execution) within a sequential `begin/end` block.

- code: |
    module fk_jn_d; // Nested begin/end
      integer a;
      initial
      fork // Outer parallel block starts at t=0
        #5 a=5; // Executes at t=5
        begin // Inner sequential block also starts at t=0
          #1 a=0; // Executes at t=1
          #2 a=1; // Executes at t=1+2=3
          #3 a=2; // Executes at t=3+3=6
          #4 a=3; // Executes at t=6+4=10
          #5 $stop; // Executes at t=10+5=15
        end // End sequential block
      join // Waits for longest thread (#5 $stop), i.e., until t=15
      initial $monitor ("a=%0d, t=%0d",a,$time);
    endmodule
  prompt: Demonstrate nesting a sequential `begin/end` block within a parallel `fork/join` block.

- code: |
    module or_fr_rl(a,b,c); // OR gate with force/release
      input b,c; output a; wire a,b,c; // Use wire for output 'a'
      assign a = b|c; // Dataflow OR gate
      // Force/Release applied directly to input 'b' within the module
      initial begin
        #1 $display("display:time=%0d, b=%b, c=%b, a=%b", $time,b,c,a);
        #6 force b = 1'b1; // Force input b high at t=7
        #1 $display("display:time=%0d, b=%b, c=%b, a=%b", $time,b,c,a); // Display after force
        #6 release b; // Release force on b at t=14
        #1 $display("display:time=%0d, b=%b, c=%b, a=%b", $time,b,c,a); // Display after release
      end
    endmodule
  prompt: Demonstrate using `force` and `release` procedural statements within a module to override an input signal (`b`) of an OR gate.

- code: |
    module orfr_tst; // Testbench for OR gate with force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    endmodule
  prompt: Create a testbench `orfr_tst` for the OR gate module (`or_fr_rl`) which contains internal `force`/`release` statements.

- code: |
    module rec_tst; // Testbench for serial receiver 'rec'
      reg clk, di;
      integer n, i;
      reg[8:1] aa; // Data buffer to send (indexed 8 down to 1)
      wire [8:1] a; // Output from receiver
      always #2 clk = ~clk; // Generate clock
      // rec rrcc(a,di,clk); // Instantiate the receiver (definition needed)
      // Event trigger based on internal receiver signal (buf_ful)
      always @(rrcc.buf_ful) $display("t=%0d, buffer sent=%h, buffer received=%h",$time,aa,a); // Use hierarchical name
      initial // Stimulus generation loop
        for (n=1; n<3000; n=n+113) begin // Loop through different data values
          aa = n; // Load data to send
          i = 0; // Reset bit index
          repeat(8) @(posedge clk) begin // Send 8 bits
            i = i+1;
            di = aa[i]; // Send bit i (Note: index 8..1 requires care)
          end
          #3; // Delay between transmissions
        end
      initial clk=1'b0; initial #400 $stop; // Initialize clock and stop
      rec rrcc(a,di,clk); // Instantiate DUT
    endmodule
  prompt: Create a testbench `rec_tst` for a serial receiver (`rec`), sending data in a loop and reacting to an internal event (`rrcc.buf_ful`) from the DUT using hierarchical naming.

- code: |
    module rec(a,ddi,clk); // Serial receiver module
      output[8:1] a; // Parallel output (indexed 8 down to 1)
      input ddi, clk; // Serial data input, Clock
      reg[8:1] a; integer j,jj;
      event buf_ful; // Declare an event
      always // Main receiving loop
        for (j=0; j<20; j=j+1) begin // Loop multiple times?
          #0 jj=0; // Reset bit counter
          repeat(8) @(negedge clk) begin // Receive 8 bits
            jj=jj+1;
            a[jj]=ddi; // Latch input data (indices 1 to 8)
          end
          #0 ->buf_ful; // Trigger the buffer full event
        end
    endmodule
  prompt: Implement a serial receiver module (`rec`) that receives 8 bits of data synchronized to the clock and triggers an event (`buf_ful`) upon completion.

- code: |
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          #1 a = I[0]; // Assign LSB of I to a (Corrected indexing)
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
  prompt: Demonstrate an attempt (likely incorrect) to generate pulses based on bits of an incrementing integer `I` within a `while` loop.

- code: |
    module tst_pchk; // Testbench for parity checker
      reg [7:0]a; // Input byte
      reg en; // Enable signal
      wire chk; // Parity check output
      integer i;
      // parity_chk pchk(a,en,chk); // Assumed instantiation of parity checker
      initial #0 en=1'b0; // Start disabled
      always #2 en = ~en; // Toggle enable
      initial begin
        #1 a=8'h00; // Initial input
        for(i=0; i<8; i=i+1) begin // Generate inputs
          #4 a = a + 3'o6; // Modify input value
        end
      end
      initial #40 $stop; // Stop simulation
      parity_chk pchk(a,en,chk); // Instantiate DUT
    endmodule
  prompt: Create a testbench `tst_pchk` applying stimulus for a parity checking module (`parity_chk`).

- code: |
    module parity(p,a,En); // Parity generator using a function
      input[7:0]a; // Data input
      input En; // Enable trigger
      output p; // Parity output
      reg p; // Output must be reg
      always @(posedge En) // Triggered by enable edge
      begin
        p = n1(a) % 2; // Calculate parity (odd parity if result is 1)
        $display("t=%0d, a = %b, en = %b, p = %b ",$time,a,En,p);
      end
      // Function to count number of '1's in input byte
      function integer n1 (input [7:0] a);
        integer i;
        begin
          n1 = 0; // Initialize count
          for(i=0; i<8; i=i+1) // Loop through bits
            if(a[i]) n1 = n1 + 1; // Increment if bit is 1
        end
      endfunction
    endmodule
  prompt: Implement a parity generator using a Verilog `function` to count set bits within an `always` block triggered by `posedge En`.

- code: |
    module parity_a(p,a,En); // Parity generator with function modifying input
      input[7:0]a;
      input En;
      output p;
      reg p;
      always @(posedge En) begin
        p = nn(a) % 2; // Calculate parity using function nn
        $display("t=%0d, a = %b, En = %b, p = %b ",$time,a,En,p);
      end
      // Function counts '1's but modifies input 'a' via shift (bad practice)
      function integer nn (input [7:0] a); // Input 'a' is copied here
        integer i;
        begin
          nn = 0; // Initialize count
          for(i=0; i<8; i=i+1) begin
            if(a[0]) nn = nn + 1; // Check LSB
            a = a >> 1; // Shift input (modifies local copy)
          end
        end
      endfunction
    endmodule
  prompt: Implement a parity generator using a Verilog `function` that counts set bits by destructively shifting its input argument (not recommended).

- code: |
    module tst_adder_fun; //testbench;
      reg [1:0] p,q; // 2-bit inputs
      reg En; // Enable
      wire [2:0] r; // 3-bit result (sum + carry)
      // adderfun aa(r,p,q,En); // Assumed instantiation of adder using function
      always #2 En=~En; // Toggle enable
      initial begin
        // Apply test vectors
        En=1'b0; p=2'b01; q=2'b00;
        #5 p=2'b10; q=2'b10;
        #4 p=2'b10; q=2'b11;
        #4 p=2'b11; q=2'b11;
        #4 p=2'b01; q=2'b01;
      end
      initial #30 $stop; // Stop simulation
      adderfun aa(r,p,q,En); // Instantiate DUT
    endmodule
  prompt: Create a testbench `tst_adder_fun` applying stimulus for a 2-bit adder implemented using Verilog functions (`adderfun`).

- code: |
    module tst_add32; //testbench;
      reg [31:0] p,q; // 32-bit inputs
      reg En; // Enable
      wire [32:0] r; // 33-bit result (sum + carry)
      // add32 aa(r,p,q,En); // Assumed instantiation of 32-bit adder
      always #2 En=~En; // Toggle enable
      initial begin
        #0 En = 1'b0; // Start disabled
        // Apply test vectors
        #3 p = 32'h1234; q = 32'h4321;
        #4 p = 32'h12345678; q = 32'h98765432;
        #4 p = 32'habcdef12; q = 32'hbbccddee;
        #4 p = 32'hfedcba39; q = 32'h13579bdf;
        #4 p = 32'h9876abcd; q = 32'hfedc8765;
        #4 p = 32'hf0e0d0c0; q = 32'h11020304;
      end
      initial #30 $stop; // Stop simulation
      add32 aa(r,p,q,En); // Instantiate DUT
    endmodule
  prompt: Create a testbench `tst_add32` applying stimulus for a 32-bit adder implemented using Verilog functions (`add32`).

- code: |
    module adderfunb(clk,r,p,q,En); // Clocked 2-bit behavioral adder using functions
      input[1:0] p,q; input En,clk; output [2:0] r;
      reg[2:0] r,c; // Result, Carry vector
      integer i;
      always@(posedge En) begin // Triggered by Enable edge
        for(i=0; i<2; i=i+1) begin // Loop through bits
          @(posedge clk) // Wait for clock edge inside loop
          if(i==0) c[i] = 1'b0; // Initialize carry for LSB on first clock
          // Call full adder function (fa) - definitions needed
          {c[i+1], r[i]} = fa(p[i], q[i], c[i]); // Use non-blocking <=
        end
        r[2] = c[2]; // Assign final carry
        $display(" t=%0d, clk = %b, En = %b, p = %b, q = %b, r = %b ",$time,clk,En,p,q,r);
      end
      // Half Adder function
      function[1:0] ha (input a,b);
        ha = {a&b, a^b}; // {carry, sum}
      endfunction
      // Full Adder function using ha function
      function [1:0] fa (input a,b,c);
        reg[1:0] a1, a2, aa2; // Changed a2 to reg for assignment
        begin
          a1 = ha(a,b); // First half add
          aa2 = ha(a1[0],c); // Second half add (sum1, cin)
          a2[1] = aa2[1] | a1[1]; // Combine carries
          a2[0] = aa2[0]; // Final sum
          fa = a2; // Return {carry, sum}
        end
      endfunction
    endmodule
  prompt: Implement a clocked 2-bit behavioral ripple-carry adder using nested Verilog `function` calls (`fa`, `ha`) within a `for` loop synchronized to `posedge clk` after `posedge En`.

- code: |
    module tst_adder_funb();
      reg [1:0] p,q; reg En,clk; wire [2:0] r;
      adderfunb bb(clk,r,p,q,En); // Instantiate the clocked adder
      always #2 clk=~clk; // Generate clock
      initial begin
        // Apply stimulus sequence with enable pulses
        clk=1'b0; En=1'b0; p=2'b01; q=2'b00;
        #1 En=1'b1; #6 En=1'b0; p=2'b01; q=2'b10;
        #1 En=1'b1; #7 En=1'b0; p=2'b01; q=2'b01;
        #1 En=1'b1; #7 En=1'b0; p=2'b10; q=2'b01;
        #1 En=1'b1; #7 En=1'b0; p=2'b10; q=2'b10;
        #1 En=1'b1; #7 En=1'b0; p=2'b10; q=2'b11;
        #1 En=1'b1; #7 En=1'b0; p=2'b11; q=2'b11;
        #1 En=1'b1; #7 En=1'b0;
      end
      initial #60 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_adder_funb` applying stimulus pulses on `En` for the clocked behavioral adder (`adderfunb`).

- code: |
    module tst_add32a(); // Testbench for clocked 32-bit adder
      reg [31:0] p,q; reg En,clk; wire [32:0] r;
      // add32_a bb(clk,r,p,q,En); // Assumed instantiation of clocked 32-bit adder
      always #1 clk=~clk; // Generate faster clock
      initial begin
        clk=1'b0; En=1'b0; // Initialize
        // Apply stimulus sequence with enable pulses
        p=32'h1234; q=32'h4321;
        #1 En=1'b1; #100 En=1'b0; // Enable for 100 time units
        p=32'h12345678; q=32'h98765432;
        #1 En=1'b1; #99 En=1'b0;
        p=32'habcdef12; q=32'hbbccddee;
        #1 En=1'b1; #99 En=1'b0;
        p=32'hfedcba39; q=32'h13579bdf;
        #1 En=1'b1; #99 En=1'b0;
        p=32'h9876abcd; q=32'hfedc8765;
        #1 En=1'b1; #99 En=1'b0;
        p=32'hf0e0d0c0; q=32'h11020304;
        #1 En=1'b1; #99 En=1'b0;
      end
      initial #900 $stop; // Stop simulation
      add32_a bb(clk,r,p,q,En); // Instantiate DUT
    endmodule
  prompt: Create a testbench `tst_add32a` applying stimulus pulses for a clocked 32-bit adder (`add32_a`).

- code: |
    module oness_counter; // Module using task to count ones
      reg [3:0] x; reg [2:0] y; // Input nibble, Output count
      // Call task whenever input x changes
      always @(x) onescounter(x, y);
      // Task definition to count set bits
      task onescounter;
        input [3:0] x; output [2:0] y; integer i;
        begin
          y = 3'b0; // Initialize count
          for(i=0; i<=3; i=i+1) // Loop through bits
            if (x[i]) y = y + 1; // Increment count if bit is set
        end
      endtask
      initial x=4'b0000; // Initialize input (Corrected width)
      always #3 x = x + 2'b11; // Change input periodically
      initial $monitor(" t=%0d, y= %d, x = %b ",$time,y,x); // Use %d for count
      initial #30 $stop; // Stop simulation
    endmodule
  prompt: Implement a module using a Verilog `task` to count the number of set bits ('1's) in a 4-bit input.

- code: |
    module clk_tst; // Module demonstrating clock divider task
      reg clk, sclk; reg [3:0] n, nn; // Master clock, Slow clock, Counter, Reload value
      always #2 clk=~clk; // Generate master clock
      // Task definition for clock division
      task sl_clk;
        input clk; input[3:0] nn; inout[3:0] n; // Use inout for counter 'n'
        output sclk; reg sclk; // Make sclk reg for assignment inside task
        begin
          if (n != 4'h0) begin // If counter not zero
            n = n - 1'b1; // Decrement counter
            sclk = 1'b0; // Keep slow clock low
          end else begin // If counter is zero
            n = nn; // Reload counter
            sclk = 1'b1; // Pulse slow clock high
          end
        end
      endtask
      // Call task on negedge of master clock
      always @(negedge clk) sl_clk(clk, nn, n, sclk); // Corrected arg order based on definition
      initial begin
        clk=1'b0; nn=4'h2; n=nn; // Initialize: divide by 3 (loads 2, counts 2,1,0)
        #45 $stop; // Stop simulation
      end
      initial $monitor($time, "n=%0d, clk=%0b, sclk=%0b",n,clk,sclk);
    endmodule
  prompt: Demonstrate implementing a clock divider using a Verilog `task` with `inout` arguments, called on the edge of a master clock.

- code: |
    module addertsk(r,p,q,En); // Behavioral adder using tasks
      input[1:0] p,q; input En; output [2:0] r;
      reg[2:0]r,c; integer i;
      always@(posedge En) // Triggered by enable edge
      begin
        for(i=0; i<2; i=i+1) begin // Loop through bits
          if(i==0) c[i] = 1'b0; // Initialize carry for LSB
          // Call full adder task 'fa'
          fa(p[i], q[i], c[i], {c[i+1'b1], r[i]});
        end
        r[2]=c[2]; // Assign final carry
        $display("t=%0d, En = %b, p = %b, q = %b, r = %b ",$time ,En,p,q,r);
      end
      // Half adder task
      task ha;
        input a,b; output[1:0] hfsum; // {carry, sum}
        hfsum = {a&b, a^b};
      endtask
      // Full adder task using ha task
      task fa;
        input a,b,c; output[1:0] a2; // {carry, sum}
        reg[1:0] a1, aa2; // Intermediate results from ha
        begin
          ha(a, b, a1); // Call ha task
          ha(a1[0], c, aa2); // Call ha task
          a2[1] = aa2[1] | a1[1]; // Combine carries
          a2[0] = aa2[0]; // Final sum
        end
      endtask
    endmodule
  prompt: Implement a 2-bit behavioral ripple-carry adder using nested Verilog `task` calls (`fa`, `ha`) within a `for` loop triggered by `posedge En`.

- code: |
    module addertskb(clk,r,p,q,En); // Clocked behavioral adder using tasks
      input[1:0] p,q; input En,clk; output [2:0] r;
      reg[2:0] r,c; integer i;
      always@(posedge En) begin // Triggered by enable
        for(i=0; i<2; i=i+1) begin // Loop through bits
          @(posedge clk) // Wait for clock edge inside loop
          if(i==0) c[i]=1'b0; // Initialize carry on first clock
          // Call full adder task 'fatsk'
          fatsk(p[i], q[i], c[i], {c[i+1'b1], r[i]}); // Use non-blocking <= in task?
        end
        r[2]=c[2]; // Assign final carry
        $display(" t=%0d, clk = %b, En = %b, p = %b, q = %b, r = %b ",$time,clk,En,p,q,r);
      end
      // Half adder task
      task hatsk;
        input a,b; output[1:0] ha; // {carry, sum}
        ha = {a&b, a^b};
      endtask
      // Full adder task using hatsk
      task fatsk;
        input a,b,c; output[1:0] a2; // {carry, sum}
        reg[1:0] a1, aa2; // Intermediate results
        begin
          hatsk(a, b, a1); // Call hatsk
          hatsk(a1[0], c, aa2); // Call hatsk
          a2[1] = aa2[1] | a1[1]; // Combine carries
          a2[0] = aa2[0]; // Final sum
        end
      endtask
    endmodule
  prompt: Implement a clocked 2-bit behavioral ripple-carry adder using nested Verilog `task` calls (`fatsk`, `hatsk`) within a `for` loop synchronized to `posedge clk` after `posedge En`.

- code: |
    module tst_udp_and();
      reg in1,in2; wire out;
      // udp_and uand(out,in1,in2); // Assumed instantiation of UDP AND gate
      initial begin in1=1'b0;in2=1'b0; end // Initialize
      always begin // Apply stimulus
        #2 in1=1'b0;in2=1'b1;
        #2 in1=1'b1;in2=1'b0;
        #2 in1=1'b1;in2=1'b1;
      end
      initial $monitor($time ,"in1 = %b ,in2 = %b ,out = %b ",in1,in2,out);
      initial #8 $stop; // Stop simulation
      udp_and uand(out,in1,in2); // Instantiate UDP
    endmodule
  prompt: Create a testbench `tst_udp_and` applying stimulus for a User-Defined Primitive (UDP) AND gate (`udp_and`).

- code: |
    module fa (car_o, sum_o, in1, in2, car_i); // Full Adder using UDPs
      input in1, in2, car_i;
      output car_o, sum_o;
      // Instantiate UDPs for carry and sum logic (definitions needed)
      udpcar aa(car_o, in1, in2, car_i); // UDP for carry
      udpsum bb(sum_o, in1, in2, car_i); // UDP for sum
    endmodule
  prompt: Implement a full adder structurally by instantiating User-Defined Primitives (UDPs) for carry (`udpcar`) and sum (`udpsum`) logic.

- code: |
    module fa_tst; // Testbench for UDP-based Full Adder
      reg [2:0] a; // Combined inputs {in1, in2, car_i}
      wire c,s; // Carry and Sum outputs
      integer i;
      fa cc(c, s, a[2], a[1], a[0]); // Corrected input mapping
      initial // Apply all input combinations
        for(i=0; i<8; i=i+1) begin // Iterate from 0 to 7
          a=i;
          #1 $display($time, " a=%b, c=%b, s=%b", a, c, s); // Display results
        end
      initial #10 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `fa_tst` that applies all possible input combinations to a UDP-based full adder (`fa`).

- code: |
    module dlatch_tst; // Testbench for D Latch UDP
      wire q; reg din,clk; // Output, Data input, Clock/Enable
      // dlatch ll(q,din,clk); // Assumed instantiation of UDP D Latch
      initial begin
        clk=1'b1; din=1'b0; // Start with latch enabled, D=0 -> Q=0
        repeat (2) begin #4 din=1'b1; #4 din=1'b0; end // Toggle D while enabled
        clk=1'b0; // Disable latch at t=1+8+8=17
        repeat (2) begin #4 din=1'b1; #4 din=1'b0; end // Toggle D while disabled
        $stop; // Stop after next toggle
      end
      initial $monitor($time ,"clk = %b, din = %b, q = %b ",clk,din,q);
      dlatch ll(q,din,clk); // Instantiate UDP
    endmodule
  prompt: Create a testbench `dlatch_tst` applying stimulus for a D Latch implemented as a User-Defined Primitive (UDP `dlatch`).

- code: |
    module dff_pos_tst; // Testbench for posedge DFF UDP with clear
      wire q;
      reg din,clk,clr; // Data, Clock, Clear inputs
      // dff_pos ll(q,din,clk,clr); // Assumed instantiation of UDP DFF
      initial begin
        clr=1'b0; din=1'b0; clk=1'b0; // Start with clear inactive
        #3 din=1'b1; // Change D before first edge
        repeat (2) begin #4 din=1'b1; #4 din=1'b0; end // Toggle D
        clr=1'b1; // Assert clear at t=3+8+8 = 19
        repeat (2) begin #4 din=1'b1; #4 din=1'b0; end // Toggle D while clear is active
        $stop;
      end
      always #2 clk=~clk; // Generate clock
      initial $monitor($time ,"clr=%b, clk = %b, din = %b, q = %b ",clr,clk,din,q);
      dff_pos ll(q,din,clk,clr); // Instantiate UDP
    endmodule
  prompt: Create a testbench `dff_pos_tst` applying stimulus including asynchronous clear for a positive-edge D Flip-Flop UDP (`dff_pos`).

- code: |
    module swt_aa (o1, o2, a1, a2, b1, b2, c1, c2); // Switch demo
      output o1, o2;
      input a1, a2, b1, b2, c1, c2;
      wire o2; // Output driven by weak switches
      tri1 o1; // Net driven by standard bufif1, defaults to pull1 if undriven
      // bufif1 switches driving o1 (standard strength)
      bufif1 ctt1(o1, a1, c1);
      bufif1 ctt2(o1, a2, c2);
      // bufif1 switches driving o2 with specified weak strength
      bufif1 (weak1, weak0) ctp1(o2, b1, c1);
      bufif1 (weak1, weak0) ctp2(o2, b2, c2);
      // Add pullup to o2
      pullup pp(o2); // Pulls o2 to 1 if not driven otherwise
    endmodule
  prompt: Demonstrate switch-level modeling using `bufif1` with and without strength specification (`weak1`, `weak0`), `tri1` net declaration, and a `pullup` primitive.

- code: |
    module npnor_2(out, in1, in2 ); // Structural NOR gate using NMOS/PMOS
      output out;
      input in1, in2;
      supply1 a; // Vdd
      supply0 c; // Gnd
      wire b; // Internal node
      // Pull-up network (series PMOS)
      pmos (b, a, in2); // Connects Vdd to b if in2=0
      pmos (out, b, in1); // Connects b to out if in1=0
      // Pull-down network (parallel NMOS)
      nmos (out, c, in1); // Connects out to Gnd if in1=1
      nmos (out, c, in2); // Connects out to Gnd if in2=1
    endmodule
  prompt: Implement a 2-input NOR gate structurally using `pmos` and `nmos` transistor primitives.

- code: |
    module NMOSinv(out,in); // NMOS Inverter
      output out; input in; supply0 a; // Ground
      pullup (out); // Pullup device on the output
      nmos(out, a, in); // NMOS connects output to ground when input is high
    endmodule
  prompt: Implement an NMOS inverter structurally using an `nmos` primitive and a `pullup` device.

- code: |
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      initial
        in =1'b1; // Start with input high -> output low
      always
        #3 in = ~in; // Toggle input every 3 time units
      initial $monitor($time , " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_nm_in` for the NMOS inverter module (`NMOSinv`).

- code: |
    module nor3NMOS(in1,in2,in3,b); // 3-input NMOS NOR
      output b;
      input in1,in2,in3;
      supply0 a; // Ground
      wire b; // Output wire (should be just output b;)
      // Parallel NMOS transistors connect output to ground
      nmos (b, a, in1);
      nmos (b, a, in2);
      nmos (b, a, in3);
      pullup (b); // Pullup device on the output
    endmodule
  prompt: Implement a 3-input NMOS NOR gate structurally using parallel `nmos` primitives and a `pullup` device.

- code: |
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      initial $monitor($time , "in1 = %b , in2 = %b , in3 = %b , output = %b ",in1,in2,in3,b); // Removed newline
      initial #24 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_nor3NMOS` for the 3-input NMOS NOR gate module (`nor3NMOS`).

- code: |
    module CMOSsw(out,in,n_ctr,p_ctr); // CMOS Switch primitive instantiation
      output out; input in,n_ctr,p_ctr; // Data, N-control, P-control
      // Instantiate NMOS and PMOS transistors
      nmos gn(out,in,n_ctr); // Passes 'in' to 'out' if n_ctr=1
      pmos gp(out,in,p_ctr); // Passes 'in' to 'out' if p_ctr=0
    endmodule
  prompt: Implement a CMOS transmission gate structurally using separate `nmos` and `pmos` transistor primitives.

- code: |
    module tst_CMOSsw();
      reg in,n_ctr,p_ctr; wire out;
      CMOSsw cmsw(out,in,n_ctr,p_ctr); // Instantiate CMOS switch
      initial begin in=1'b0; n_ctr=1'b1; p_ctr=~n_ctr; end // Start enabled
      always #5 in =~in; // Toggle data input
      always begin #3 n_ctr=~n_ctr; #0 p_ctr =~n_ctr; end // Toggle control signals
      initial $monitor($time , "in = %b , n_ctr = %b , p_ctr = %b , output = %b ",in,n_ctr,p_ctr,out); // Removed newline
      initial #30 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_CMOSsw` for the structural CMOS switch module (`CMOSsw`).

- code: |
    module CMOSsw1(out,in,con); // CMOS switch using 'cmos' primitive
      output out; input in,con; // Data, Control input
      wire p_ctr; // Internal inverted control
      not gn(p_ctr,con); // Generate inverted control
      cmos gc(out,in,con,p_ctr); // Instantiate 'cmos' switch primitive
    endmodule
  prompt: Implement a CMOS transmission gate using the Verilog `cmos` switch primitive and a `not` gate for control inversion.

- code: |
    module tst_CMOSsw1();
      reg in,con; wire out;
      CMOSsw1 cmsw(out,in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial $monitor($time , "in = %b , con = %b , output = %b " ,in,con,out);
      initial #20 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_CMOSsw1` for the CMOS switch implemented with the `cmos` primitive (`CMOSsw1`).

- code: |
    module ram_cell(do,din,wsb,rd); // Structural RAM Cell
      output do; input din,wsb,rd; // Data out, Data in, Write Strobe Bar, Read
      wire sb; // Internal inverted write strobe
      wire q, qb; // Internal storage nodes (Corrected qb typo: qq->qb)
      tri do; // Tristate data output
      // Instantiate CMOS switches (module 'csw' definition needed)
      csw sw1(q, din, wsb); // Write switch (enabled when wsb=1?)
      csw sw2(q, qb, sb); // Feedback switch for latch (enabled when wsb=0?)
      csw sw3(do, q, rd); // Read switch (enabled when rd=1)
      // Cross-coupled inverters forming the latch
      not n1(sb, wsb); // Invert write strobe
      not n2(qb, q);
      not n3(q, qb); // Corrected: q depends on qb
    endmodule
  prompt: Implement a structural RAM cell using CMOS switches (`csw`) and cross-coupled `not` gates to form a latch.

- code: |
    module csw(out,in,n_ctr); // CMOS Switch wrapper
      output out; input in,n_ctr; // Data in/out, N-control
      wire p_ctr;
      assign p_ctr =~n_ctr; // Generate P-control
      cmos csw(out,in,n_ctr,p_ctr); // Instantiate cmos primitive
    endmodule
  prompt: Create a wrapper module `csw` for the `cmos` switch primitive, taking a single n-control input.

- code: |
    module tst_ramcell();
      reg din,wsb,rd; wire do;
      ram_cell mc(do,din,wsb,rd); // Instantiate RAM cell
      initial begin din=1'b0; wsb=1'b0; rd=1'b0; end // Initialize
      always #10 din =~din; // Toggle data input
      always begin #3 wsb=1'b1; #8 wsb=1'b0; end // Pulse write strobe
      always begin #2 rd=1'b1; #5 rd =1'b0; end // Pulse read enable
      initial $monitor ($time," rd= %b ,wsb = %b ,din = %b ,do = %b ",rd,wsb,din,do);
      initial #40 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_ramcell` for the structural RAM cell module (`ram_cell`).

- code: |
    module ram1(do,din,wr,rd); // Alternate RAM cell
      output do; input din,wr,rd; // Data out, Data in, Write, Read
      wire qb, q; // Internal storage nodes
      tri do; // Tristate output
      // Instantiate CMOS switches (module 'scw' definition needed)
      scw sww(q, din, wr); // Write switch (enabled when wr=1)
      scw swr(do, q, rd); // Read switch (enabled when rd=1)
      // Cross-coupled inverters with pull strengths
      not(pull1, pull0) n1(qb, q);
      not(pull1, pull0) n2(q, qb); // Corrected: q depends on qb
    endmodule
  prompt: Implement an alternative structural RAM cell using CMOS switches (`scw`) and cross-coupled `not` gates with specified pull strengths.

- code: |
    module scw(out,in,n_ctr); // CMOS Switch wrapper (Similar to csw)
      output out; input in,n_ctr; wire p_ctr;
      assign p_ctr =~n_ctr; // Generate P-control
      cmos sw(out,in,n_ctr,p_ctr); // Instantiate cmos primitive
    endmodule
  prompt: Create a wrapper module `scw` for the `cmos` switch primitive, taking a single n-control input (similar to `csw`).

- code: |
    module tst_ram1();
      reg din,wr,rd; wire do;
      ram1 mm(do,din,wr,rd); // Instantiate RAM cell
      initial begin din=1'b0; wr=1'b0; rd=1'b0; end // Initialize
      always #10 din =~din; // Toggle input data
      always begin #3 wr=1'b1; #8 wr=1'b0; end // Pulse write enable
      always begin #2 rd=1'b1; #5 rd =1'b0; end // Pulse read enable
      initial $monitor ($time," rd= %b ,wr = %b ,din = %b ,do = %b ",rd,wr,din,do);
      initial #40 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_ram1` for the alternative structural RAM cell module (`ram1`).

- code: |
    module shreg1(dout,din,phi1); // Dynamic Shift Register (2-phase clock)
      output dout;
      input din, phi1; // Data in, Clock phase 1
      wire phi2; // Clock phase 2
      trireg[3:0] x, y; // Storage nodes for stages (capacitive)
      trireg dout; // Output storage node
      assign phi2 = ~phi1; // Generate phase 2 clock
      // Chain of CMOS switches and storage nodes
      cmos switch0(x[0], din, phi1, phi2); // Stage 0 input latch (on phi1 high)
      cmos switch1(y[0], x[0], phi2, phi1); // Stage 0 output latch (on phi2 high)
      cmos switch2(x[1], y[0], phi1, phi2); // Stage 1 input latch
      cmos switch3(y[1], x[1], phi2, phi1); // Stage 1 output latch
      cmos switch4(x[2], y[1], phi1, phi2); // Stage 2 input latch (Corrected: was x[2],y[1])
      cmos switch5(y[2], x[2], phi2, phi1); // Stage 2 output latch (Corrected: was x[3],y[2])
      cmos switch6(x[3], y[2], phi1, phi2); // Stage 3 input latch (Corrected: was dout,y[3])
      cmos switch7(y[3], x[3], phi2, phi1); // Stage 3 output latch
      cmos switch8(dout, y[3], phi1, phi2); // Output stage latch (Corrected logic needed)

      // Assumed 'cell' module provides buffering/inversion between stages?
      // cell cc0(y[0], x[0]); cell cc1(y[1], x[1]);
      // cell cc2(y[2], x[2]); cell cc3(y[3], x[3]);
    endmodule
  prompt: Implement a 4-bit dynamic shift register using `cmos` switches, `trireg` storage nodes, and a two-phase clock (phi1, phi2). Requires `cell` definition or alternative buffering. **Note:** Original code had errors in switch connections.

- code: |
    module tst_shreg1;
      reg din, phi1;
      wire dout;
      shreg1 shr(dout, din, phi1); // Instantiate shift register
      initial {din, phi1} = 2'b00; // Initialize
      always // Generate input data sequence
      begin
        #1 din=1'b1; #2 din=1'b1; #2 din=1'b0;
        #2 din=1'b0; #2 din=1'b0; #2 din=1'b1;
        #2 din=1'b1;
      end
      always #2 phi1=~phi1; // Generate clock phase 1
      initial $monitor($time," din= %b, dout= %b, phi1= %b", din,dout,phi1);
      initial #30 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_shreg1` for the dynamic shift register module (`shreg1`).

- code: |
    module bus_tran(a,b,c); // Bidirectional Bus Transceiver
      inout a,b; // Bidirectional ports
      input c; // Control signal
      // wire a,b,c; // Inputs/inouts should not be declared wire
      tranif1 gg (a, b, c); // Connects a and b if c=1
    endmodule
  prompt: Implement a simple bidirectional bus transceiver using the `tranif1` primitive controlled by signal `c`.

- code: |
    module bus_tst; // Testbench for bidirectional bus
      reg ar, br, ac, bc, c; // Regs for driving ports and controls
      wire a, b; // Wires connected to inout ports
      // Controlled buffers to drive ports a and b
      bufif1 swa(a, ar, ac); // Drive 'a' with 'ar' if 'ac'=1
      bufif1 swb(b, br, bc); // Drive 'b' with 'br' if 'bc'=1
      // Instantiate the bidirectional switch connecting a and b
      bus_tran bs(a, b, c);
      initial begin
        $display("t\tar\tac\ta\tc\tb\tbc\tbr"); // Header
        // Apply stimulus sequence
        #1 {ar,ac,c,bc,br}=5'b01100; repeat(3) #1 ar=~ar;
        #1 {ar,ac,c,bc,br}=5'b00110; repeat(3) #2 br=~br;
        #1 {ar,ac,c,bc,br}=5'b11010; repeat(3) #1 ar=~ar;
                                     repeat(3) #2 br=~br; // Drive b while a is floating
        #1 $stop;
      end
      initial $monitor("%0d\t%b\t%b\t%b\t%b\t%b\t%b\t%b",$time,ar,ac,a,c,b,bc,br);
    endmodule
  prompt: Create a testbench `bus_tst` demonstrating the use of a bidirectional switch (`bus_tran`) between two ports driven by controlled buffers (`bufif1`).

- code: |
    module ram_cell1(do,di,wr,rd,a_d); // RAM Cell with address enable?
      output do; input di,wr,rd,a_d; // Data out, data in, write, read, address?
      wire ddd, q, qb, wrb, rdb; // Internal nodes, inverted controls
      not(rdb,rd), (wrb,wr); // Invert controls
      not(pull1,pull0)(q,qb), (qb,q); // Cross-coupled inverter latch with strength
      tranif1 g3(ddd, q, a_d); // Switch controlled by a_d? Connects latch output to ddd
      cmos g4(ddd, di, wr, wrb); // Write switch (pass di to ddd if wr=1)
      cmos g5(do, ddd, rd, rdb); // Read switch (pass ddd to do if rd=1)
    endmodule
  prompt: Implement a structural RAM cell using `tranif1`, `cmos` switches, and cross-coupled `not` gates with strength, potentially gated by an address signal `a_d`.

- code: |
    module tst_ramcell1();
      reg din,wr,rd,a_d; wire do;
      ram_cell1 rmc1(do,din,wr,rd,a_d); // Instantiate RAM cell
      initial begin a_d=1'b0; din=1'b0; wr=1'b0; rd=1'b0; end // Initialize
      always #3 a_d=1'b1; // Assert address enable at t=3? Seems constant after that
      always #10 din =~din; // Toggle input data
      always begin #3 wr=1'b1; #8 wr=1'b0; end // Pulse write enable
      always begin #2 rd=1'b1; #5 rd =1'b0; end // Pulse read enable
      initial $monitor ($time," rd= %b ,wr = %b ,din = %b ,a_d = %b ,do = %b ",rd,wr,din,a_d,do);
      initial #40 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tst_ramcell1` for the structural RAM cell module (`ram_cell1`).

- code: |
    module demo_1; // Charge storage demonstration
      trireg(large) a3; // Large capacitance trireg
      trireg(small) a2; // Small capacitance trireg
      wire a1; // Standard wire driven by buffer
      reg c1, c2, b; // Switch controls and source value
      // Strong buffer driving wire a1
      buf(strong1, strong0) source1(a1, b);
      // Switches connecting nodes with different capacitances
      tranif1 sw1(a2, a1, c1); // Connects a1 to a2 (small cap) if c1=1
      tranif1 sw2(a3, a2, c2); // Connects a2 (small cap) to a3 (large cap) if c2=1
      initial begin
        $display("t\ta1\tc1\ta2\tc2\ta3"); // Header
        // Apply stimulus to observe charge sharing and decay effects
        #0 {c1,c2,b}=3'b111; #1 {c1,c2,b}=3'b011; #1 {c1,c2,b}=3'b001;
        #1 {c1,c2,b}=3'b000; #1 {c1,c2,b}=3'b100; #1 {c1,c2,b}=3'b000;
        #1 {c1,c2,b}=3'b010; #1 {c1,c2,b}=3'b000; #1 {c1,c2,b}=3'b100;
        #1 {c1,c2,b}=3'b000; #1 {c1,c2,b}=3'b010; #1 {c1,c2,b}=3'b000;
        #1 {c1,c2,b}=3'b001; #1 {c1,c2,b}=3'b101; #1 {c1,c2,b}=3'b111;
        #1 $stop;
      end
      initial $monitor("%0d\t%b\t%b\t%b\t%b\t%b",$time,a1,c1,a2,c2,a3);
    endmodule
  prompt: Demonstrate charge storage and sharing effects using `trireg` nets with different capacitances (`large`, `small`) connected by `tranif1` switches.

- code: |
    module ha_1(s,ca,a,b); // Half Adder with gate delays
      input a,b; output s,ca;
      // XOR gate with rise=1, fall=2 delay
      xor #(1,2) (s,a,b);
      // AND gate with rise=3, fall=4 delay
      and #(3,4) (ca,a,b);
    endmodule
  prompt: Implement a structural half adder specifying inertial rise and fall delays for the `xor` and `and` gate primitives.

- code: |
    module tstha_1();
      reg a,b; wire s,ca;
      ha_1 hh(s,ca,a,b); // Instantiate half adder with delays
      initial begin a=0; b=0; end // Initialize
      always begin // Apply stimulus sequence
        #5 a=1;b=0; // s=1 @ t=5+1=6, ca=0 @ t=5+4=9
        #5 a=0;b=1; // s=1 @ t=10+1=11, ca=0 @ t=10+4=14
        #5 a=1;b=1; // s=0 @ t=15+2=17, ca=1 @ t=15+3=18
        #5 a=0;b=0; // s=0 @ t=20+2=22, ca=0 @ t=20+4=24
      end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial #30 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tstha_1` for the half adder with specified gate delays (`ha_1`).

- code: |
    module ha_2(s,ca,a,b); // Half Adder with parameterized delays
      input a,b; output s,ca;
      // Define delay parameters with default values
      parameter dl1r=1, dl2f=2, dl3r=3, dl4f=4;
      // Instantiate gates using parameters for delays
      xor #(dl1r, dl2f) (s,a,b);
      and #(dl3r, dl4f) (ca,a,b);
    endmodule
  prompt: Implement a structural half adder using `parameter` definitions for specifying gate rise and fall delays, with default values.

- code: |
    module tstha_2();
      reg a,b; wire s,ca;
      ha_2 hh(s,ca,a,b); // Instantiate with default parameters
      initial begin a=0; b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
  prompt: Create a testbench `tstha_2` for the parameterized half adder (`ha_2`), using the default delay parameter values.

- code: |
    module ha_2(s,ca,a,b); // Duplicate: Half Adder with parameterized delays
      input a,b; output s,ca;
      parameter dl1r=1, dl2f=2, dl3r=3, dl4f=4;
      xor #(dl1r,dl2f) (s,a,b);
      and #(dl3r,dl4f) (ca,a,b);
    endmodule
  prompt: Implement a structural half adder using `parameter` definitions for specifying gate rise and fall delays (parameterized delays).

- code: |
    module tstha_3();
      reg a,b; wire s,ca;
      // Instantiate ha_2 overriding parameters by position
      ha_2 #(4,3,2,1) hh(s,ca,a,b); // dl1r=4, dl2f=3, dl3r=2, dl4f=1
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
  prompt: Create a testbench `tstha_3` that instantiates the parameterized half adder (`ha_2`) and overrides its delay parameters by position during instantiation.

- code: |
    module ha_2(s,ca,a,b); // Duplicate: Half Adder with parameterized delays
      input a,b; output s,ca;
      parameter dl1r=1, dl2f=2, dl3r=3, dl4f=4;
      xor #(dl1r,dl2f) (s,a,b);
      and #(dl3r,dl4f) (ca,a,b);
    endmodule
  prompt: Implement a structural half adder using `parameter` definitions for specifying gate rise and fall delays (parameterized delays).

- code: |
    module tstha_4();
      reg a,b; wire s,ca;
      // Instantiate ha_2 overriding only the first 3 parameters by position
      ha_2 #(4,3,2) hh(s,ca,a,b); // dl1r=4, dl2f=3, dl3r=2, dl4f uses default (4)
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
  prompt: Create a testbench `tstha_4` that instantiates the parameterized half adder (`ha_2`) and overrides only the first three delay parameters by position.

- code: |
    module ha_2(s,ca,a,b); // Duplicate: Half Adder with parameterized delays
      input a,b; output s,ca;
      parameter dl1r=1,dl2f=2,dl3r=3,dl4f=4;
      xor #(dl1r,dl2f) (s,a,b);
      and #(dl3r,dl4f) (ca,a,b);
    endmodule
  prompt: Implement a structural half adder using `parameter` definitions for specifying gate rise and fall delays (parameterized delays).

- code: |
    module tstha_5();
      reg a,b; wire s,ca;
      // Use defparam to override parameters by hierarchical name
      defparam hh.dl1r=4, hh.dl2f=3, hh.dl3r=2, hh.dl4f=1;
      // Instantiate ha_2 (parameters are overridden by defparam above)
      ha_2 hh(s,ca,a,b);
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
  prompt: Create a testbench `tstha_5` that instantiates the parameterized half adder (`ha_2`) and overrides its delay parameters using `defparam` statements.

- code: |
    module ha_6(s,ca,a,b); // Half Adder with dependent parameterized delays
      input a,b; output s,ca;
      // Define parameters where some depend on others
      parameter dl1r=1, dl2f=dl1r+1, dl3r=3, dl4f=dl2f*2;
      // Use parameters for gate delays
      xor #(dl1r,dl2f) (s,a,b); // Effective #(1, 2)
      and #(dl3r,dl4f) (ca,a,b); // Effective #(3, 4)
    endmodule
  prompt: Implement a structural half adder using `parameter` definitions where some delay parameters are defined based on expressions involving other parameters.

- code: |
    module tstha_6();
      reg a,b; wire s,ca;
      ha_6 hh(s,ca,a,b); // Instantiate with default parameters
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
  prompt: Create a testbench `tstha_6` for the half adder with dependent delay parameters (`ha_6`).

- code: |
    module ha_7(s,ca,a,b); // Half Adder with specify path delays
      input a,b; output s,ca;
      specify // Start specify block
        // Path delay from inputs a, b to output s is 1 (rise and fall)
        (a, b *> s) = 1;
        // Path delay from inputs a, b to output ca is 2 (rise and fall)
        (a, b *> ca) = 2;
      endspecify // End specify block
      // Structural implementation
      xor (s,a,b);
      and (ca,a,b);
    endmodule
  prompt: Implement a structural half adder specifying simple pin-to-pin path delays using a `specify` block.

- code: |
    module tstha_7();
      reg a,b; wire s,ca;
      ha_7 hh(s,ca,a,b); // Instantiate HA with path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
  prompt: Create a testbench `tstha_7` for the half adder with specified path delays (`ha_7`).

- code: |
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
  prompt: Implement a structural half adder specifying pin-to-pin path delays using `specparam` within a `specify` block.

- code: |
    module tstha_8();
      reg a,b; wire s,ca;
      ha_8 hh(s,ca,a,b); // Instantiate HA with specparam delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
  prompt: Create a testbench `tstha_8` for the half adder with `specparam` path delays (`ha_8`).

- code: |
    module ha_9(s,ca,a,b); // Half Adder with rise/fall path delays
      input a,b; output s,ca;
      specify
        // Specify rise, fall path delays from a,b to s
        (a, b *> s) = (1, 2); // rise=1, fall=2
        // Specify rise, fall path delays from a,b to ca
        (a, b *> ca) = (3, 4); // rise=3, fall=4
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
  prompt: Implement a structural half adder specifying separate rise and fall pin-to-pin path delays within a `specify` block.

- code: |
    module tstha_9();
      reg a,b; wire s,ca;
      ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
  prompt: Create a testbench `tstha_9` for the half adder with specified rise/fall path delays (`ha_9`).

- code: |
    module alu_1 (d, co, a, b, f, cci); // Dataflow ALU with path delay
      output [3:0] d; output co; wire[3:0]d; // Specify d as wire
      input cci; input [3 : 0 ] a, b; input [1 : 0] f;
      specify
        // Specify path delay from input 'a' to output 'd'
        (a => d) = 1; // Delay=1 for all bits of 'a' to all bits of 'd'
      endspecify
      // Dataflow assignment for ALU operations
      assign {co,d} = (f==2'b00) ? (a+b+cci) :
                       ( (f==2'b01) ? (a-b) :
                         ( (f==2'b10) ? {1'bz, a^b} : // Note: co becomes Z
                                       {1'bz, ~a} ) ); // Note: co becomes Z
    endmodule
  prompt: Implement a 4-bit dataflow ALU specifying a simple path delay from input `a` to output `d` using a `specify` block.

- code: |
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
        #2 cci =1'b0; f=2'b00; a=4'h1; b=4'h0;
        #2 cci =1'b1; f=2'b00; a=4'h8; b=4'hf;
        #2 cci =1'b1; f=2'b01; a=4'h2; b=4'h1;
        #2 cci =1'b0; f=2'b01; a=4'h3; b=4'h7;
        #2 cci =1'b1; f=2'b01; a=4'h3; b=4'h3; // Added missing assignment
        #2 cci =1'b1; f=2'b10; a=4'h3; b=4'h3;
        #2 cci =1'b1; f=2'b11; a=4'hf; b=4'hc;
      end
      initial $monitor($time, " cci = %b , a= %h ,b = %h ,f = %b ,d =%h ,co= %b ",cci ,a,b,f,d,co); // Use %h
    endmodule
  prompt: Create a testbench `tst_alu1` for the dataflow ALU with specified path delay (`alu_1`).

- code: |
    module alu_2 (d, co, a, b, f, cci); // Dataflow ALU with parallel path delay
      output [3:0] d; output co; wire[3:0]d;
      input cci; input [3 : 0 ] a, b; input [1 : 0] f;
      specify
        // Specify parallel path delay from inputs a,b to output d
        (a, b => d) = 1; // Delay=1 for a->d and b->d paths
      endspecify
      assign {co,d} = (f==2'b00) ? (a+b+cci) :
                       ( (f==2'b01) ? (a-b) :
                         ( (f==2'b10) ? {1'bz, a^b} :
                                       {1'bz, ~a} ) );
    endmodule
  prompt: Implement a 4-bit dataflow ALU specifying parallel path delay from inputs `a` and `b` to output `d` using a `specify` block.

- code: |
    module tst_alu2();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_2 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
        #2 cci =1'b0; f=2'b00; a=4'h1; b=4'h0;
        #2 cci =1'b1; f=2'b00; a=4'h8; b=4'hf;
        #2 cci =1'b1; f=2'b01; a=4'h2; b=4'h1;
        #2 cci =1'b0; f=2'b01; a=4'h3; b=4'h7;
        #2 cci =1'b1; f=2'b01; a=4'h3; b=4'h3; // Added missing assignment
        #2 cci =1'b1; f=2'b10; a=4'h3; b=4'h3;
        #2 cci =1'b1; f=2'b11; a=4'hf; b=4'hc;
      end
      initial $monitor($time, " cci = %b , a= %h ,b = %h ,f = %b ,d =%h ,co= %b ",cci ,a,b,f,d,co); // Use %h
    endmodule
  prompt: Create a testbench `tst_alu2` for the dataflow ALU with specified parallel path delay (`alu_2`).

- code: |
    module alu_3 (d, co, a, b, f, cci); // Dataflow ALU with rise/fall parallel path delay
      output [3:0] d; output co; wire[3:0]d;
      input cci; input [3 : 0 ] a, b; input [1 : 0] f;
      specify
        // Specify parallel path delay with rise=1, fall=2
        (a, b => d) = (1, 2);
      endspecify
      assign {co,d} = (f==2'b00) ? (a+b+cci) :
                       ( (f==2'b01) ? (a-b) :
                         ( (f==2'b10) ? {1'bz, a^b} :
                                       {1'bz, ~a} ) );
    endmodule
  prompt: Implement a 4-bit dataflow ALU specifying parallel path delay with distinct rise (1) and fall (2) times using a `specify` block.

- code: |
    module tst_alu3();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_3 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
        #3 cci =1'b0; f=2'b00; a=4'h1; b=4'h0;
        #3 cci =1'b1; f=2'b00; a=4'h8; b=4'hf;
        #3 cci =1'b1; f=2'b01; a=4'h2; b=4'h1;
        #3 cci =1'b0; f=2'b01; a=4'h3; b=4'h7;
        #3 cci =1'b1; f=2'b01; a=4'h3; b=4'h3; // Added missing assignment
        #3 cci =1'b1; f=2'b10; a=4'h3; b=4'h3;
        #3 cci =1'b1; f=2'b11; a=4'hf; b=4'hc;
      end
      initial $monitor($time, " cci = %b , a= %h ,b = %h ,f = %b ,d =%h ,co= %b ",cci ,a,b,f,d,co); // Use %h
    endmodule
  prompt: Create a testbench `tst_alu3` for the dataflow ALU with specified parallel rise/fall path delay (`alu_3`).

- code: |
    module alu_4 (d, co, a, b, f, cci); // Dataflow ALU with multiple path delays
      output [3:0] d; output co; wire[3:0]d;
      input cci; input [3 : 0 ] a, b; input [1 : 0] f;
      specify
        // Specify parallel path delay for d (rise=1, fall=2)
        (a, b => d) = (1, 2);
        // Specify full path delay for co (delay=1)
        (a, b, cci *> co) = 1;
      endspecify
      assign {co,d} = (f==2'b00) ? (a+b+cci) :
                       ( (f==2'b01) ? (a-b) :
                         ( (f==2'b10) ? {1'bz, a^b} :
                                       {1'bz, ~a} ) );
    endmodule
  prompt: Implement a 4-bit dataflow ALU specifying both parallel path delay for `d` and full path delay for `co` within a `specify` block.

- code: |
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
        #3 cci =1'b0; f=2'b00; a=4'h1; b=4'h0;
        #3 cci =1'b1; f=2'b00; a=4'h8; b=4'hf;
        #3 cci =1'b1; f=2'b01; a=4'h2; b=4'h1;
        #3 cci =1'b0; f=2'b01; a=4'h3; b=4'h7;
        #3 cci =1'b1; f=2'b01; a=4'h3; b=4'h3; // Added missing assignment
        #3 cci =1'b1; f=2'b10; a=4'h3; b=4'h3;
        #3 cci =1'b1; f=2'b11; a=4'hf; b=4'hc;
      end
      initial $monitor($time, " cci = %b , a= %h ,b = %h ,f = %b ,d =%h ,co= %b ",cci ,a,b,f,d,co); // Use %h
    endmodule
  prompt: Create a testbench `tst_alu4` for the dataflow ALU with multiple specified path delays (`alu_4`).

- code: |
    module alu_5 (d, co, a, b, f, cci); // Dataflow ALU with conditional path delays
      output [3:0] d; output co; wire[3:0]d;
      input cci; input [3 : 0 ] a, b; input [1 : 0] f;
      specify
        // Conditional path delay for a->d based on function code f
        if (f == 2'b00) (a => d) = 1;
        if (f > 2'b00) (a => d) = 2; // Use single condition or separate ifs if needed
        // Full path delay for b, cci -> co
        (b, cci *> co) = 1;
      endspecify
      assign {co,d} = (f==2'b00) ? (a+b+cci) :
                       ( (f==2'b01) ? (a-b) :
                         ( (f==2'b10) ? {1'bz, a^b} :
                                       {1'bz, ~a} ) );
    endmodule
    // test-bench included within the same file
    module tst_alu5();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_5 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
        #3 cci =1'b0; f=2'b00; a=4'h1; b=4'h0;
        #3 cci =1'b1; f=2'b00; a=4'h8; b=4'hf;
        #3 cci =1'b1; f=2'b01; a=4'h2; b=4'h1;
        #3 cci =1'b0; f=2'b01; a=4'h3; b=4'h7;
        #3 cci =1'b1; f=2'b01; a=4'h3; b=4'h3; // Added missing assignment
        #3 cci =1'b1; f=2'b10; a=4'h3; b=4'h3;
        #3 cci =1'b1; f=2'b11; a=4'hf; b=4'hc;
      end
      initial $monitor($time, " cci = %b , a= %h ,b = %h ,f = %b ,d =%h ,co= %b ",cci ,a,b,f,d,co); // Use %h
    endmodule
  prompt: Implement a 4-bit dataflow ALU specifying conditional path delays using `if` statements within a `specify` block. Includes embedded testbench.

- code: |
    module ha_a(s,ca,a,b); // Half Adder with parameters for rise delays only
      input a,b; output s,ca;
      parameter dl1r=1, dl3r=3; // Define only rise delay parameters
      // Instantiate gates using rise delays (fall delays default to rise delays)
      xor #(dl1r) (s,a,b);
      and #(dl3r) (ca,a,b);
    endmodule
  prompt: Implement a structural half adder using `parameter` definitions for rise delays only; fall delays default to the specified rise delays.

- code: |
    module tstha_a();
      reg a,b; wire s1, ca1, s2, ca2; // Outputs for two instances
      // Instantiate ha_a twice
      ha_a h1(s1, ca1, a, b); // Instance 1
      ha_a h2(s2, ca2, a, b); // Instance 2
      // Override parameters using defparam for both instances
      defparam
        h1.dl1r = 2, // Instance h1 delays
        h1.dl3r = 1,
        h2.dl1r = 2, // Instance h2 delays
        h2.dl3r = 2;
      initial begin a=0; b=0; end // Initialize
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end // Stimulus
      initial $monitor($time , " a=%b, b=%b, ca1=%b, s1=%b, ca2=%b, s2=%b " ,a,b,ca1,s1,ca2,s2); // Monitor both instances
      initial #30 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench `tstha_a` instantiating a parameterized half adder (`ha_a`) twice and overriding delay parameters differently for each instance using `defparam`.

- code: |
    module ha_c(s,ca,a,b); // Half Adder with min:typ:max path delays
      input a,b; output s,ca;
      specify
        // Specify rise delay (min:typ:max) and fall delay (min:typ:max) for s path
        (a, b *> s) = (1:2:3, 2:4:6);
        // Specify rise delay (min:typ:max) and fall delay (min:typ:max) for ca path
        (a, b *> ca) = (1:3:5, 5:7:9);
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
  prompt: Implement a structural half adder specifying pin-to-pin path delays using min:typ:max format for both rise and fall times within a `specify` block.

- code: |
    module tstha_c();
      reg a,b; wire s,ca;
      ha_c hh(s,ca,a,b); // Instantiate HA with min:typ:max delays
      initial begin a=0; b=0; #100 $stop; end // Initialize & stop
      always begin // Apply stimulus with longer period
        #15 a=1; b=0;
        #15 a=0; b=1;
        #15 a=1; b=1;
        #15 a=0; b=0;
      end
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
    endmodule
  prompt: Create a testbench `tstha_c` for the half adder with min:typ:max specified path delays (`ha_c`).

- code: |
    module dff_p(do,di,clk); // Behavioral DFF with path delay
      output do; input di,clk;
      specify
        // Specify delay from negedge clk to output do (using input di value)
        (negedge clk *> (do:di)) = 1; // State-dependent path delay
      endspecify
      reg do;
      initial do=1'b0; // Initialize
      always@(negedge clk) do <= di; // Use non-blocking assignment
    endmodule
  prompt: Implement a behavioral D flip-flop specifying a clock-to-output state-dependent path delay `(negedge clk *> (do:di))` using a `specify` block.

- code: |
    module tst_dff_pbeh();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
  prompt: Create a testbench `tst_dff_pbeh` for the behavioral D flip-flop with specified path delay (`dff_p`).

- code: |
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      assign qb=~q;
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr && !pr) (posedge clk *> (q:di)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b0; // Use non-blocking <=
        else if(pr) q <= 1'b1;
        else q <= di;
    endmodule
  prompt: Implement a behavioral D flip-flop with asynchronous preset/clear, specifying a conditional clock-to-output path delay active only when preset/clear are inactive using `if` within `specify`.

- code: |
    module ha_pt(s,ca,a,b); // Half Adder with Path Pulse filtering
      input a,b; output s,ca;
      specify
        (a, b *> s, ca) = 4; // Specify path delay
        specparam pathpulse$ = 3; // Ignore input pulses shorter than 3 time units
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
  prompt: Implement a structural half adder specifying input pulse filtering using `specparam pathpulse$ = limit` within a `specify` block.

- code: |
    module tstha_pt();
      reg a,b; wire s,ca;
      ha_pt hh(s,ca,a,b); // Instantiate HA with pulse filtering
      initial begin a=0;b=0; #50 $stop;end
      initial begin // Generate stimulus including narrow pulses
        #4 a=1;b=0; #4 a=0;b=0; #2 a=1;b=0; // a has pulse width 2 (<3), ignored
        #4 a=1;b=1; #1 a=1;b=0; // b has pulse width 1 (<3), ignored
        #4 a=1;b=1; #4 a=1;b=0; #1 a=1;b=0; // b has pulse width 1 (<3), ignored
        #4 a=0;b=0; #2 a=1;b=0; // a has pulse width 2 (<3), ignored
        #4 a=1;b=1; #3 a=1;b=0; // b has pulse width 3 (>=3), processed
        #4 a=1;b=1; #4 a=1;b=0; #1 a=1;b=0; // b has pulse width 1 (<3), ignored
      end
      initial $monitor($realtime , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
    endmodule
  prompt: Create a testbench `tstha_pt` generating narrow pulses to test the path pulse filtering specified in the `ha_pt` module.

- code: |
    module tstha_ptt(); // Testbench likely for ha_ptt (definition not provided)
      reg a,b; wire s,ca;
      // ha_ptt hh(s,ca,a,b); // Assumed instantiation
      initial begin a=0;b=0; #50 $stop;end
      initial begin // Stimulus similar to tstha_pt
        #4 a=1;b=0; #4 a=0;b=0; #2 a=1;b=0; #4 a=1;b=1; #1 a=1;b=0;
        #4 a=1;b=1; #4 a=1;b=0; #1 a=1;b=0; #4 a=0;b=0; #2 a=1;b=0;
        #4 a=1;b=1; #3 a=1;b=0; #4 a=1;b=1; #4 a=1;b=0; #1 a=1;b=0;
      end
      initial $monitor($realtime , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
    endmodule
  prompt: Create a testbench applying stimulus with narrow pulses, likely intended for a module with path pulse filtering (e.g., `ha_ptt`).

- code: |
    module alu_6 (d, co, a, b, f, cci); // Parameterized ALU with path delays
      parameter msb=3; // Parameter for MSB index (width = msb+1)
      output [msb:0] d; output co; wire[msb:0]d;
      input cci; input [msb : 0 ] a, b; input [1 : 0] f; // Corrected 'nput' to 'input'
      specify
        // Specify path delays using parameterized width
        (a, b => d) = (1, 2);
        (a, b, cci *> co) = 1;
      endspecify
      assign {co,d} = (f==2'b00) ? (a+b+cci) :
                       ( (f==2'b01) ? (a-b) :
                         ( (f==2'b10) ? {1'bz, a^b} :
                                       {1'bz, ~a} ) );
    endmodule
  prompt: Implement a parameterized dataflow ALU (`alu_6`) with specified path delays, where the data width is controlled by the `msb` parameter.

- code: |
    module alu_6 (d, co, a, b, f, cci); // Duplicate: Parameterized ALU with path delays
      parameter msb=3;
      output [msb:0] d; output co; wire[msb:0]d;
      input cci; input [msb : 0 ] a, b; input [1 : 0] f;
      specify
        (a, b => d) = (1, 2);
        (a, b, cci *> co) = 1;
      endspecify
      assign {co,d} = (f==2'b00) ? (a+b+cci) :
                       ( (f==2'b01) ? (a-b) :
                         ( (f==2'b10) ? {1'bz, a^b} :
                                       {1'bz, ~a} ) );
    endmodule
  prompt: Implement a parameterized dataflow ALU (`alu_6`) with specified path delays, where data width depends on the `msb` parameter.

- code: |
    module dff_p(do,di,clk); // Behavioral DFF with path delay and %m
      output do; input di,clk;
      specify
        (negedge clk *> (do:di)) = 1; // Clock-to-output delay
      endspecify
      reg do;
      initial do=1'b0;
      always @(negedge clk) do <= di; // Use non-blocking
      initial $display ("%m: Instantiated within design module"); // Display hierarchical name
    endmodule
  prompt: Implement a behavioral D flip-flop with specified path delay, including a `$display("%m")` statement to show its hierarchical instance name during simulation setup.

- code: |
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
  prompt: Create a testbench `tst_dff_p_b` for the `dff_p` module, demonstrating the use of `$display("%m")` in both the testbench and the DUT to show hierarchical names.

- code: |
    module dec3_8a(pp,q,enn); // Structural 3-to-8 Decoder
      output[7:0] pp; input[2:0] q; input enn;
      wire qq; wire[7:0] p;
      not(qq,q[2]); // Invert MSB
      // Instantiate two 2-to-4 decoders (module dec2_4a definition needed)
      dec2_4a g1(.a(p[3:0]), .b(q[1:0]), .en(qq));
      dec2_4a g2(.a(p[7:4]), .b(q[1:0]), .en(q[2]));
      // AND stage for enable
      and g3_8_7(pp[7],p[7],enn), g3_8_6(pp[6],p[6],enn),
      g3_8_5(pp[5],p[5],enn), g3_8_4(pp[4],p[4],enn), g3_8_3(pp[3],p[3],enn),
      g3_8_2(pp[2],p[2],enn), g3_8_1(pp[1],p[1],enn), g3_8_0(pp[0],p[0],enn);
    endmodule
  prompt: Implement a structural 3-to-8 decoder (`dec3_8a`) by instantiating a 2-to-4 decoder module (`dec2_4a`).

- code: |
    module dec2_4a (a,b,en); // Structural 2-to-4 Decoder with %m display
      output [3:0] a; input [1:0]b; input en; wire [1:0]bb;
      not(bb[1],b[1]),(bb[0],b[0]);
      and(a[0],en,bb[1],bb[0]),(a[1],en,bb[1],b[0]),
      (a[2],en,b[1],bb[0]),(a[3],en,b[1],b[0]); // Corrected a[3] logic: b[1]&b[0] needed
      initial $display ("Instantiated Decoder: %m"); // Display hierarchical name
    endmodule
  prompt: Implement a structural 2-to-4 decoder (`dec2_4a`) including an `initial $display("%m")` statement to show its hierarchical instance name.

- code: |
    module dec4_16_tba; // Testbench for 4-to-16 Decoder
      wire[15:0] m; // Decoder output
      // wire l,m,n; // Unused single-bit wires
      reg[3:0] n; // Decoder input
      // dec4_16a gg(m,n); // Assumed instantiation of 4-to-16 decoder
      // Testbench stimulus would go here...
      dec4_16a gg(m,n); // Instantiate DUT
    endmodule
  prompt: Define a testbench structure `dec4_16_tba` for a 4-to-16 decoder module (`dec4_16a`).

- code: |
    module strng_1(o,i1,i2); // Contention demo with different strengths
      input i1,i2; output o; // Output 'o' should be wire by default
      // Drive 'o' with buffers of different strengths
      buf(strong1, pull0) g1(o,i1); // Strong 1, Pull 0
      buf(pull1, pull0) g2(o,i2); // Pull 1, Pull 0
    endmodule
  prompt: Demonstrate contention resolution by driving a wire `o` with two buffers having different strengths, `(strong1, pull0)` vs `(pull1, pull0)`.

- code: |
    module tst_strng_1;
      reg i1,i2; wire o; // Declare o
      strng_1 cc(o,i1,i2); // Instantiate DUT
      initial begin i1 =0;i2 =0; #40 $stop; end // Initialize & stop
      always begin // Apply stimulus
        #4 i1 = 0; i2 = 1; // pull0 vs pull1 -> o=pull1
        #4 i1 = 1; i2 = 0; // strong1 vs pull0 -> o=strong1
        #4 i1 = 1; i2 = 1; // strong1 vs pull1 -> o=strong1
      end
      // Monitor output value and strength using %v
      initial $monitor($time ," i1 = %b ,i2 = %b ,o = %b (strength of o = %v) ",i1,i2,o,o);
    endmodule
  prompt: Create a testbench `tst_strng_1` for the strength demonstration module (`strng_1`), using `$monitor` with `%v` to display the resolved strength of the output.

- code: |
    module dff_c(do,di,clk); // Behavioral DFF with path delay (from Fig 7.27)
      output do; input di,clk;
      specify
        (negedge clk *> (do:di)) = 1; // Specify clock-to-output delay
      endspecify
      reg do;
      initial do=1'b0;
      always@(negedge clk) do <= di; // Use non-blocking
    endmodule
  prompt: Implement a behavioral D flip-flop (`dff_c`) specifying clock-to-output path delay using `specify`.

- code: |
    module tst_dff_cbeh();
      reg di,clk; wire do;
      dff_c d1(do,di,clk); // Instantiate DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      // Use $strobe to display values at the end of time step 9
      initial #9 $strobe (" Strobe @ t=%0t: di=%b, do=%b",$time, di, do);
    endmodule
  prompt: Create a testbench `tst_dff_cbeh` for the DFF module `dff_c`, demonstrating the use of the `$strobe` system task.

- code: |
    module ha_1(s,ca,a,b); // Half Adder with gate delays
      input a,b; output s,ca;
      xor #(1,2) (s,a,b); // Rise=1, Fall=2
      and #(3,4) (ca,a,b); // Rise=3, Fall=4
    endmodule
  prompt: Implement a structural half adder (`ha_1`) with specified inertial rise/fall delays on the `xor` and `and` gates.

- code: |
    module tstha_e();
      reg a,b; wire s,ca;
      ha_1 hh(s,ca,a,b); // Instantiate HA with delays
      initial begin a=0; b=0; #100 $stop; end // Initialize & stop
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end // Stimulus
      initial $monitor($time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      // Control monitoring intervals
      initial begin
        #30 $monitoroff; // Turn off monitoring at t=30
        #30 $monitoron; // Turn on monitoring at t=60
        #30 $monitoroff; // Turn off monitoring at t=90
      end
    endmodule
  prompt: Create a testbench `tstha_e` demonstrating the use of `$monitoron` and `$monitoroff` system tasks to control monitoring output during simulation.

- code: |
    module alu_8 (d, co, a, b, f, cci); // Dataflow ALU (likely 4-bit based on ports)
      output [3:0] d; output co; wire[3:0]d;
      input cci; input [3 : 0 ] a, b; input [1 : 0] f;
      // Dataflow assignment using conditional operator
      assign {co,d} = (f==2'b00) ? (a+b+cci) :
                       ( (f==2'b01) ? (a-b) :
                         ( (f==2'b10) ? {1'bz, a^b} :
                                       {1'bz, ~a} ) );
    endmodule
  prompt: Implement a 4-bit dataflow ALU (`alu_8`) performing add, subtract, XOR, and NOT based on function select `f`.

- code: |
    module tst_alu8();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_8 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus using $random
        #2 cci =1'b0; f=2'b00; {a,b}=$random(4); // Use seed 4 for first call
        #2 cci =1'b1; f=2'b00; {a,b}=$random;
        #2 cci =1'b1; f=2'b01; {a,b}=$random;
        #2 cci =1'b0; f=2'b01; {a,b}=$random;
        #2 cci =1'b1; f=2'b01; {a,b}=$random; // Added missing assignment
        #2 cci =1'b1; f=2'b10; {a,b}=$random;
        #2 cci =1'b1; f=2'b11; {a,b}=$random;
      end
      initial $monitor($time, " cci = %b , a= %h ,b = %h ,f = %b ,d =%h ,co= %b ",cci ,a,b,f,d,co); // Use %h
    endmodule
  prompt: Create a testbench `tst_alu8` for the dataflow ALU (`alu_8`), using the `$random` system function to generate input operands.

- code: |
    module ha_1(s,ca,a,b); // Half Adder with gate delays
      input a,b; output s,ca;
      xor #(1,2) (s,a,b);
      and #(3,4) (ca,a,b);
    endmodule
  prompt: Implement a structural half adder (`ha_1`) with specified gate delays.

- code: |
    module tstha_f();
      integer info; // File descriptor
      reg a,b; wire s,ca;
      ha_1 hh(s,ca,a,b); // Instantiate HA
      initial begin
        a=0; b=0;
        info = $fopen("ha_f_rslt.txt"); // Open file for writing
        if (info == 0) $display("Error opening file"); // Basic error check
      end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end // Stimulus
      // Monitor outputs to the opened file
      initial $fmonitor(info, $time , " a = %b , b = %b ,out carry = %b , outsum = %b ",a,b,ca,s);
      initial begin
         #30 $display("File descriptor: %0d", info); // Display file descriptor value
         #0 $fclose(info); // Close file explicitly before stopping
         $stop;
      end
    endmodule
  prompt: Create a testbench `tstha_f` demonstrating Verilog file I/O using `$fopen` and `$fmonitor` to log simulation results to "ha_f_rslt.txt".

- code: |
    module alu_a (d, co, a, b, f, cci); // Dataflow ALU using `define
      `define add 2'b00      // Define ADD opcode
      `define subtract 2'b01 // Define SUBTRACT opcode
      `define exor 2'b10      // Define XOR opcode
      // `define not 2'b11      // Define NOT opcode (missing in original)
      output [3:0] d; output co; // Corrected 'utput' typo
      wire[3:0]d;
      input cci; input [3 : 0 ] a, b; input [1 : 0] f;
      // Use defined macros in assignment
      assign {co,d} = (f == `add) ? (a+b+cci) :
                       ( (f == `subtract) ? (a-b) :
                         ( (f == `exor) ? {1'bz, a^b} :
                                         {1'bz, ~a} ) ); // Assumes f=11 is NOT
    endmodule
  prompt: Implement a 4-bit dataflow ALU using `` `define`` text macros to define symbolic names for function select codes.

- code: |
    module show_1; // Top module for timeformat demo
      reg ai, bi; wire ao, bo;
      show_2 aa(ao, ai); // Instantiate NOT gate with delay 2
      show_3 bb(bo, bi); // Instantiate NOT gate with delay 1.2
      // Set time format: units=-3(ms), precision=5, suffix="ms", min_field_width=12
      initial $timeformat(-3, 5, " ms", 12);
      initial $monitor("%m has ai=%b,ao=%b,bi=%b,bo=%b, at time %t",ai,ao,bi,bo,$realtime); // Use $realtime
      always begin // Stimulus
        #3 {ai,bi} =2'b00; #3 {ai,bi} =2'b01;
        #3 {ai,bi} =2'b10; #3 {ai,bi} =2'b11;
      end
      initial #12 $stop; // Stop simulation
    endmodule
  prompt: Demonstrate the `$timeformat` system task and compare `$time` vs `$realtime` by instantiating modules with different delays (`show_2`, `show_3`).

- code: |
    module show_3(bo,bi); // NOT gate with delay
      output bo; input bi; wire bo, bi;
      not #1.2 (bo,bi); // Delay of 1.2 time units
    endmodule
  prompt: Implement a simple NOT gate module (`show_3`) with a specified delay of 1.2 time units.

- code: |
    module show_2(ao,ai); // NOT gate with delay
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai); // Delay of 2 time units
    endmodule
  prompt: Implement a simple NOT gate module (`show_2`) with a specified delay of 2 time units.

- code: |
    module show_b(ao,ai); // Duplicate of show_2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
  prompt: Implement a simple NOT gate module (`show_b`) with a delay of 2 time units.

- code: |
    module show_c(bo,bi); // Duplicate of show_3
      output bo;
      input bi;
      wire bo, bi;
      not #1.2 (bo,bi);
    endmodule
  prompt: Implement a simple NOT gate module (`show_c`) with a delay of 1.2 time units.

- code: |
    module show_aatb; // Testbench demonstrating time formatting with $time
      reg ai, bi; wire ao, bo;
      show_aa aa1(ao, ai); // Instantiate NOT gate module show_aa
      show_bb bb1(bo, bi); // Instantiate NOT gate module show_bb
      initial $timeformat(-3, 5, " ms", 12); // Set time format
      initial $monitor("%m has ai=%b,ao=%b,bi=%b,bo=%b, at time %t",ai,ao,bi,bo,$time); // Use $time
      always begin // Stimulus
        #3 {ai,bi} =2'b00; #3 {ai,bi} =2'b01;
        #3 {ai,bi} =2'b10; #3 {ai,bi} =2'b11;
      end
      initial #12 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench demonstrating `$timeformat` and using `$time` for monitoring, instantiating modules `show_aa` and `show_bb`.

- code: |
    module show_bb(bo,bi); // NOT gate with delay 1.2
      output bo; input bi; wire bo, bi;
      not #1.2 (bo,bi);
    endmodule
  prompt: Implement a simple NOT gate module (`show_bb`) with a delay of 1.2 time units.

- code: |
    module show_aa(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
  prompt: Implement a simple NOT gate module (`show_aa`) with a delay of 2 time units.

- code: |
    module show_bbb; // Duplicate of show_1/show_aatb
      reg ai, bi; wire ao, bo;
      show_2 aa(ao, ai); // Instantiate NOT gate delay 2
      show_3 bb(bo, bi); // Instantiate NOT gate delay 1.2
      initial $timeformat(-3, 5, " ms", 12); // Set time format
      initial $monitor("%m has ai=%b,ao=%b,bi=%b,bo=%b, at time %t",ai,ao,bi,bo,$realtime); // Use $realtime
      always begin // Stimulus
        #3 {ai,bi} =2'b00; #3 {ai,bi} =2'b01;
        #3 {ai,bi} =2'b10; #3 {ai,bi} =2'b11;
      end
      initial #12 $stop; // Stop simulation
    endmodule
  prompt: Create a testbench demonstrating `$timeformat` and using `$realtime` for monitoring, instantiating modules `show_2` and `show_3`.

- code: |
    module show_3(bo,bi); // Duplicate: NOT gate delay 1.2
      output bo; input bi; wire bo, bi;
      not #1.2 (bo,bi);
    endmodule
  prompt: Implement a simple NOT gate module (`show_3`) with a delay of 1.2 time units.

- code: |
    module show_2(ao,ai); // Duplicate: NOT gate delay 2
      output ao;
      input ai;
      wire ao, ai;
      not #2 (ao,ai);
    endmodule
  prompt: Implement a simple NOT gate module (`show_2`) with a delay of 2 time units.

- code: |
    module hier_a; // Function call and hierarchical access demo
      integer aa, bb, cc, pp, qq, rr; // Module-level variables
      initial begin: alpha // Named initial block
        aa = 2; bb = 3;
        cc = fad(aa, bb); // Call function fad
        // Access function internal variables using hierarchical name (block_name.func_name.var_name)
        $display("alpha.fad.a = %0d, alpha.fad.b = %0d, alpha.fad.fad = %0d", alpha.fad.a, alpha.fad.b, alpha.fad.fad);
      end
      initial begin: beta // Second initial block
        pp = 4; qq = 6;
        rr = fad(pp, qq); // Call function fad again
        $display("beta.fad.a = %0d, beta.fad.b = %0d, beta.fad.fad = %0d", beta.fad.a, beta.fad.b, beta.fad.fad);
      end
      // Function definition for addition
      function integer fad (input [7:0] a, b); // Implicit range [7:0] assumed for integer function arguments? Should be input integer a, b;
        fad = a + b;
      endfunction
    endmodule
  prompt: Demonstrate calling a Verilog `function` from multiple `initial` blocks and accessing the function's internal variables using hierarchical names.

- code: |
    module hier_b; // Function call with internal display
      integer aa, bb, cc, pp, qq, rr;
      initial begin
        aa = 2; bb = 3;
        cc = fad(aa, bb); // Call function
        $display("hier_b.alpha.fad.a = %0d, ...", hier_b.alpha.fad.a); // Hierarchical access example
      end
      initial begin
        pp = 4; qq = 6;
        rr = fad(pp, qq); // Call function
        $display("hier_b.beta.fad.a = %0d, ...", hier_b.beta.fad.a);
      end
      // Function definition
      function integer fad (input [7:0] a, b); // Should be input integer a, b;
        begin
          fad = a + b;
          // Display internal values from within the function
          $display("Function fad: a = %0d, b = %0d, fad = %0d", a, b, fad);
        end
      endfunction
    endmodule
  prompt: Demonstrate calling a Verilog `function` that contains an internal `$display` statement to show its local variable values during execution.

- code: |
    module hier_c; // Function accessing parent module variables
      integer aa, bb, cc, pp, qq, rr;
      initial begin: alpha // Named block
        aa = 2; bb = 3;
        cc = fad(aa, bb); // Call function
        $display("alpha.fad.a = %0d, ...", alpha.fad.a);
      end
      initial begin: beta // Named block
        pp = 4; qq = 6;
        rr = fad(pp, qq); // Call function
        $display("beta.fad.a = %0d, ...", beta.fad.a);
      end
      // Function definition
      function integer fad (input [7:0] a, b); // Should be input integer a, b;
        begin
          fad = a + b;
          // Access variables from the parent module (hier_c) using hierarchical names
          $display("Parent context: hier_c.aa = %0d, hier_c.bb = %0d", hier_c.aa, hier_c.bb); // Only valid if called from initial block 'alpha' context? Scope is complex.
          $display("Function context: a = %0d, b = %0d, fad = %0d", a, b, fad);
        end
      endfunction
    endmodule
  prompt: Demonstrate accessing variables from the parent module scope within a Verilog `function` using full hierarchical names. **Note:** This relies on specific simulator behavior regarding scope during function calls.

- code: |
    module hier_d; // Task call and hierarchical access demo
      integer aa, bb, cc, pp, qq, rr;
      initial begin: alpha // Named initial block
        aa = 2; bb = 3;
        tad(aa, bb, cc); // Call task tad
        // Access task internal variables using hierarchical name (block_name.task_name.var_name)
        $display("alpha.tad.a = %0d, alpha.tad.b = %0d, alpha.tad.c = %0d", alpha.tad.a, alpha.tad.b, alpha.tad.c);
      end
      initial begin: beta // Second initial block
        pp = 4; qq = 6;
        tad(pp, qq, rr); // Call task tad again
        $display("beta.tad.a = %0d, beta.tad.b = %0d, beta.tad.c = %0d", beta.tad.a, beta.tad.b, beta.tad.c);
      end
      // Task definition for addition
      task tad;
        input a, b; output c; // Default type is reg for task arguments
        integer a, b, c; // Specify type as integer
        c = a + b;
      endtask
    endmodule
  prompt: Demonstrate calling a Verilog `task` from multiple `initial` blocks and accessing the task's internal variables using hierarchical names.

- code: |
    module hier_e; // Task call with internal display
      integer aa, bb, cc, pp, qq, rr;
      initial begin: alpha
        aa = 2; bb = 3;
        tad(aa, bb, cc); // Call task
        $display("alpha.tad.a = %0d, ...", alpha.tad.a);
      end
      initial begin: beta
        pp = 4; qq = 6;
        tad(pp, qq, rr); // Call task
        $display("beta.tad.a = %0d, ...", beta.tad.a);
      end
      // Task definition
      task tad;
        input a, b; output c;
        integer a, b, c;
        begin
          c = a + b;
          // Display internal values from within the task
          $display("Task tad: a = %0d, b = %0d, c = %0d", a, b, c);
        end
      endtask
    endmodule
  prompt: Demonstrate calling a Verilog `task` that contains an internal `$display` statement to show its local variable values during execution.

- code: |
    module hier_f; // Task accessing parent module variables
      integer aa, bb, cc, pp, qq, rr;
      initial begin: alpha // Named block
        aa = 2; bb = 3;
        tad(aa, bb, cc); // Call task
        $display("alpha.tad.a = %0d, ...", alpha.tad.a);
      end
      initial begin: beta // Named block
        pp = 4; qq = 6;
        tad(pp, qq, rr); // Call task
        $display("beta.tad.a = %0d, ...", beta.tad.a);
      end
      // Task definition
      task tad;
        input a, b; output c;
        integer a, b, c;
        begin
          c = a + b;
          $display("Task context: a = %0d, b = %0d, c = %0d", a, b, c);
          // Access variables from the parent module (hier_f) using hierarchical names
          $display("Parent context: hier_f.aa = %0d, hier_f.bb = %0d", hier_f.aa, hier_f.bb); // Access depends on call context
        end
      endtask
    endmodule
  prompt: Demonstrate accessing variables from the parent module scope within a Verilog `task` using full hierarchical names.

- code: |
    module hier_l(cc2,s2,s1,s0,a2,a1,a0,b2,b1,b0); // Hierarchical 3-bit Adder Top
      input a2,a1,a0,b2,b1,b0;
      output cc2,s2,s1,s0;
      wire cc1,cc0; // Internal carries
      // Instantiate submodules (ha, fa definitions needed)
      ha aaa(s0,cc0,a0,b0); // Instantiate Half Adder for LSB
      fa faa1(s1,cc1,a1,b1,cc0); // Instantiate Full Adder for middle bit
      fa faa2(s2,cc2,a2,b2,cc1); // Instantiate Full Adder for MSB
      //location 3 (Comment marker)
    endmodule
  prompt: Define the top-level module (`hier_l`) for a structural 3-bit ripple-carry adder, instantiating `ha` and `fa` submodules.

- code: |
    module ha(s,c,a,b); // Half Adder submodule
      input a,b;
      output s,c;
      // Dataflow implementation
      assign {c,s} = {a&b, a^b}; // Concatenated assignment for carry and sum
      //location 5 (Comment marker)
    endmodule
  prompt: Define a half adder submodule (`ha`) using dataflow assignment.

- code: |
    module fa(sf,cf,af,bf,ci); // Full Adder submodule
      input af,bf,ci;
      output sf,cf;
      wire sf1,cc1,cc2; // Internal sum and carries
      // Instantiate two half adders
      ha fha1(sf1,cc1,af,bf);
      ha fha2(sf,cc2,sf1,ci);
      //location 4 (Comment marker)
      or rr(cf,cc1,cc2); // OR gate for final carry
    endmodule
  prompt: Define a full adder submodule (`fa`) structurally by instantiating two half adder modules (`ha`) and an OR gate.

- code: |
    module hier_ltst; // Testbench for 3-bit adder
      reg a2,a1,a0,b2,b1,b0;
      wire cc2,s2,s1,s0;
      hier_l ddd(cc2,s2,s1,s0,a2,a1,a0,b2,b1,b0); // Instantiate adder
      initial begin
        #0 {a2,a1,a0,b2,b1,b0} = 6'o34; // Initialize inputs (Octal 3 and 4)
        $monitor("na = %0o, nb = %0o, ns = %0o", {a2,a1,a0}, {b2,b1,b0}, {cc2,s2,s1,s0}); // Monitor in octal
        #2 $stop; // Stop simulation
      end
      //location 1 (Comment marker)
      // Access internal signal using hierarchical path for display
      initial #1 $display("Internal sum bit (fha2.s) = %b, internal carry (fha2.c) = %b", ddd.faa2.fha2.s, ddd.faa2.fha2.c);
    endmodule
  prompt: Create a testbench (`hier_ltst`) for the 3-bit adder (`hier_l`), demonstrating hierarchical access to display internal signals of sub-submodules.

- code: |
    module hier_n(cc2,s2,s1,s0,a2,a1,a0,b2,b1,b0); // Duplicate: Hierarchical 3-bit Adder Top
      input a2,a1,a0,b2,b1,b0;
      output cc2,s2,s1,s0;
      wire cc1,cc0;
      ha aaa(s0,cc0,a0,b0);
      fa faa1(s1,cc1,a1,b1,cc0);
      fa faa2(s2,cc2,a2,b2,cc1);
    endmodule
  prompt: Define the top-level module (`hier_n`) for a structural 3-bit ripple-carry adder (similar to `hier_l`).

- code: |
    module ha(s,c,a,b); // Duplicate: Half Adder submodule
      input a,b;
      output s,c;
      assign {c,s} = {a&b, a^b};
    endmodule
  prompt: Define a half adder submodule (`ha`) using dataflow assignment.

- code: |
    module fa(sf,cf,af,bf,ci); // Duplicate: Full Adder submodule
      input af,bf,ci;
      output sf,cf;
      wire sf1,cc1,cc2;
      ha fha1(sf1,cc1,af,bf);
      ha fha2(sf,cc2,sf1,ci);
      or rr(cf,cc1,cc2);
    endmodule
  prompt: Define a full adder submodule (`fa`) structurally using `ha` instances and an `or` gate.

- code: |
    module hier_ntst;
      reg a2,a1,a0,b2,b1,b0;
      wire cc2,s2,s1,s0;
      hier_n ddd(cc2,s2,s1,s0,a2,a1,a0,b2,b1,b0); // Instantiate adder
      initial begin
        #0 {a2,a1,a0,b2,b1,b0} = 6'o34; // Initialize inputs
        $monitor("na = %0o, nb = %0o, ns = %0o", {a2,a1,a0}, {b2,b1,b0}, {cc2,s2,s1,s0});
        #2 $stop; // Stop simulation
      end
      initial begin: alpha // Named initial block
        //location1 (Comment marker)
        // Access internal signal using hierarchical path within named block
        #1 $display("sum = %b%b", ddd.faa2.fha2.s, ddd.faa2.fha2.c); // Corrected hier access: .s and .c needed
      end
    endmodule
  prompt: Create a testbench (`hier_ntst`) for the 3-bit adder (`hier_n`), demonstrating hierarchical access from within a named initial block (`alpha`).

- code: |
    module dem_qb; // Demonstrate Verilog Queue system tasks
      integer alpha, beta ,gama, i, n;
      initial begin
        // Initialize queue #1: start_addr=1, end_addr=1, size=10, status_var=alpha
        $q_initialize (1, 1, 10, alpha);
        n = $random(22); // Get random seed
        // Add items to queue
        for(i=1; i<8; i=i+1) begin
          beta = 50 + $random%50; // Generate random data
          $q_add (1, i, beta, alpha); // Add item 'i' with value 'beta' to queue 1
          $write ("%0d a %0d ",i,beta); // Display added item
        end
        $display; // Newline
        // Remove items from queue
        for(i=1; i<8; i=i+1) begin
          $q_remove (1, i, gama, alpha); // Remove item 'i' from queue 1, store value in 'gama'
          $write ("%0d r %0d ",i,gama); // Display removed item
        end
        $display; // Newline
        // Consider adding $q_full and $q_exam checks
      end
    endmodule
  prompt: Demonstrate the use of Verilog queue system tasks (`$q_initialize`, `$q_add`, `$q_remove`) for managing a FIFO queue.

- code: |
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Corrected output order?
      end
    endmodule
  prompt: Implement a 2x2 bit multiplier using Verilog PLA system tasks (`$async$and$array`, `$async$or$array`) with hardcoded AND/OR plane definitions.

- code: |
    module mltp_a_tst;
      reg a1,a0,b1,b0; reg[3:0] n; // Corrected size of n
      integer i; wire c4,c3,c2,c1;
      mltp_a mm(a1,a0,b1,b0,c1,c2,c3,c4); // Instantiate PLA multiplier
      always begin
        n=4'b0000;
        for(i=0; i<16; i=i+1) begin // Iterate through all 16 input combinations
          {a1,a0,b1,b0}=n; // Apply input combination
          #1 n=n+1'b1; // Increment for next iteration
        end
        #1 $stop; // Stop after loop
      end
      initial $monitor("%b\t%b\t%b",{a1,a0},{b1,b0},{c4,c3,c2,c1}); // Monitor inputs and outputs
      initial begin
        $display("a \tb\t a*b"); // Header
        // #15 $stop; // Redundant stop
      end
    endmodule
  prompt: Create a testbench `mltp_a_tst` that applies all 16 input combinations to the 2x2 PLA multiplier (`mltp_a`).

- code: |
    module test_a_seqmoorev(); // Testbench for Moore FSM
      reg clr,clk;
      wire w,x,y,z; // FSM outputs
      // a_seqmoorev vv(clr,clk,w,x,y,z); // Assumed instantiation of Moore FSM
      initial begin
        clk=1'b0; clr=1'b1; // Initialize clock, assert clear
        #3 clr =1'b0; // Deassert clear
        #50 $stop; // Stop simulation
      end
      always #2 clk = ~clk; // Generate clock
      a_seqmoorev vv(clr,clk,w,x,y,z); // Instantiate DUT
    endmodule
  prompt: Create a testbench `test_a_seqmoorev` applying clock and reset to a Moore FSM DUT (`a_seqmoorev`).

- code: |
    module seqmoorev2(clr,clk,w,x,y,z); // Behavioral Moore FSM
      input clr,clk;
      output w,x,y,z;
      reg w,x,y,z; // Outputs must be reg
      reg [2:0] present_state;
      // Assumes state parameters `s0`-`s7` are defined elsewhere (e.g., `define s0 3'b000)
      always@(posedge clk or posedge clr) begin // Sensitive to clock and clear
        if (clr)
          present_state = `s0; // Asynchronous reset to state s0
        else begin
          // State transition logic
          case(present_state)
            `s0: begin present_state = `s1; {w,x,y,z} = 4'b1000; end // Use non-blocking <=
            `s1: begin present_state = `s2; {w,x,y,z} = 4'b1100; end
            `s2: begin present_state = `s3; {w,x,y,z} = 4'b0100; end
            `s3: begin present_state = `s4; {w,x,y,z} = 4'b0110; end
            `s4: begin present_state = `s5; {w,x,y,z} = 4'b0010; end
            `s5: begin present_state = `s6; {w,x,y,z} = 4'b0011; end
            `s6: begin present_state = `s7; {w,x,y,z} = 4'b0001; end
            `s7: begin present_state = `s0; {w,x,y,z} = 4'b1001; end
            default: present_state = `s0;
          endcase
        end
      end
    endmodule
  prompt: Implement a behavioral Moore FSM using a `case` statement for state transitions and output assignments, with asynchronous reset. Assumes state parameters (`s0`-`s7`) are defined.

- code: |
    module test_seqmoorev2();
      reg clr,clk;
      wire w,x,y,z;
      seqmoorev2 vv(clr,clk,w,x,y,z); // Instantiate Moore FSM
      initial begin
        clk=1'b0; clr=1'b1; // Initialize clock, assert clear
        #3 clr = 1'b0; // Deassert clear
        #50 $stop; // Stop simulation
      end
      always #2 clk = ~clk; // Generate clock
    endmodule
  prompt: Create a testbench `test_seqmoorev2` applying clock and reset to the behavioral Moore FSM (`seqmoorev2`).

- code: |
    module p_tst_seqmealy(); // Testbench for Mealy FSM
      reg a, clk; // Input, Clock
      wire w,x,y,z; // Outputs
      wire [2:0] state; // State output from DUT
      // p_seqmealy sm (a,clk,w,x,y,z,state); // Assumed instantiation of Mealy FSM
      initial begin
        clk=1'b0; a=1'b0; // Initialize clock and input
        #150 $stop; // Stop simulation
      end
      always #2 clk = ~clk; // Generate clock
      always #60 a = ~a; // Toggle input 'a' every 60 time units
      p_seqmealy sm (a,clk,w,x,y,z,state); // Instantiate DUT
    endmodule
  prompt: Create a testbench `p_tst_seqmealy` applying clock and input stimulus to a Mealy FSM DUT (`p_seqmealy`) which outputs its internal state.

- code: |
    module endgenerate_example; // Placeholder module name
      // Example usage context:
      genvar i;
      generate
        if (1) begin : block1
          // statements for if condition
        end
        else begin : block2
          // statements for else condition
        end
      endgenerate // Termination of generate block
    endmodule
  prompt: Demonstrate the `endgenerate` keyword used to terminate a Verilog `generate` block.

