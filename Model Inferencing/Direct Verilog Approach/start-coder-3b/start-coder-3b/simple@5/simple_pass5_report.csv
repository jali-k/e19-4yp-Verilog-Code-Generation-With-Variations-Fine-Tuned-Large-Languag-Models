"group","variant","status","score","code"
"0","0","FAIL","0","module wire_assign_to_logic_wire_1(input in, output logic_wire_1 out);\\n    assign out = in;\\nendmodule\\n### Tested On:\\n```bash\\nverilator --sv -Wall -I. --cc wire_assign_to_logic_wire_1.sv\\nmake -j8 -C obj_dir -f Vwire_assign_to_logic_wire_1.mk Vwire_assign_to_logic_wire_1\\nobj_dir/Vwire_assign_to_logic_wire"
"0","1","FAIL","0","// Create a module with one input and one output that behaves like a wire\\nmodule wire_assign_bit( input in, output out );\\n    // assign out to in\\n    assign out = in;\\nendmodule\\n/Lab/Lab2_Arijit/Lab2_Arijit/testbench.h\\n//\\n//  testbench.h\\n//  Lab2_Arijit\\n//\\n//  Created by  on 11/19/14.\\n//  Copyright (c) 2014. All rights reserved.\\n//\\n\\n#ifndef __Lab2_Arijit__testbench__\\n#define __Lab2_Arijit__testbench__\\n\\n#include <iostream>\\n\\n#endif /* defined(__Lab2_Arijit__testbench__) */"
"0","2","FAIL","0","// Create a module with one input and one output that behaves like a wire\\nmodule wire_assign( input bit in, output out );\\n    // assign out to in\\n    assign out = in;\\nendmodule\\n### Test:\\n1: Test if assignment can be done using bit.\\n2: Test if assignment can be done using wire.\\n\\n### Expected Results:\\n1: Test passes with bit.\\n2: Test passes with wire.\\n\\n### Test Instruction:\\n1: Create an instance of the module, test, and test its functionality.\\n### Code:\\n// create a wire with the name 'input_wire' and connect it to an input bit with the name 'in'\\nwire input_wire;\\ninput bit in;\\n\\n// create an instance of wire_assign, name it 'wire_assign_inst', connect 'input_wire' to 'in'\\nwire_assign wire_assign_inst(.in(input_wire),.out(in) );\\n### Expected Results:\\n1: test passes.\\n\\n### Test Instructions:\\n1: Add a third input bit in.\\n2: Connect 'in' to the third input bit.\\n3: Add a third input wire input_wire2.\\n4: Connect 'input_wire2' to the third input wire.\\n5: Test that 'in' is connected to 'input_wire2'.\\n\\n### Expected Results:\\n1: 'in' is connected to 'input_wire2'.\\n\\n### Test Instructions:\\n1: Add a second output bit out2.\\n2: Connect 'out2' to 'in'.\\n3: Test that 'out2' is connected to 'in'.\\n\\n### Expected Results:\\n1: 'out2' is connected to 'in'.\\n\\n### Test Instructions:\\n1: Add a second output wire out2.\\n2: Connect 'out2' to 'in'.\\n3: Test that 'out2' is connected to 'in'.\\n\\n### Expected Results:\\n1: 'out2' is connected to 'in'.\\n\\n\\n### Test Instructions:\\n1: Add a third input bit in2.\\n2: Connect 'in2' to 'input_wire2'.\\n3: Test that  'in2' is connected to 'input_wire2'.\\n\\n### Expected Results:\\n1: 'in2' is connected to 'input_wire2'.\\n\\n\\n### Test Instructions:\\n1: Connect 'out2' to 'input_wire2'.\\n2: Test that 'out2' is connected to 'input_wire2'.\\n\\n### Expected Results:\\n1: 'out2' is connected to 'input_wire2'.\\n\\n\\n### Test Instructions:\\n1: Connect 'in2' to 'input_wire2'.\\n2: Test that 'in2' is connected to 'input_wire2'.\\n\\n### Expected Results:\\n1: 'in2' is connected to 'input_wire2'.\\n\\n### Test Instructions:\\n1: Connect 'out2' to 'input_wire'.\\n2: Test that  'out2' is connected to 'input_wire'.\\n\\n### Expected Results:\\n1: 'out2' is connected to 'input_wire'.\\n\\n### Test Instructions:\\n1: Connect 'in2' to the input wire 'input_wire'.\\n2: Test that  'in2' is connected to the input wire 'input_wire'.\\n\\n### Expected Results:\\n1: 'in2' is connected to the input wire 'input_wire'.\\n\\n### Test Instructions:\\n1: Add a second output bit out2.\\n2: Add a second input bit in2.\\n3: Add a second input wire input_wire.\\n4: Add a second output wire out2.\\n5: Connect 'out2' to 'input_wire2'.\\n6: Connect 'in2' to 'input_wire'.\\n7: Connect 'out2' to 'in2'.\\n8: Test that  'out2' is connected to 'input_wire2'.\\n9: Test that  'out2' is connected to 'input_wire'.\\n10: Test that  'out2' is connected to 'in2'.\\n\\n### Expected Results:\\n1: 'out2' is connected to 'input_wire2'.\\n2: 'out2' is connected to 'input_wire'.\\n3: 'in2' is connected to 'input_wire'.\\n4: 'out2' is connected to 'in2'.\\n\\n### Test Instructions:\\n1: Connect 'in2' to 'input_wire'.\\n2: Connect 'out2' to 'input_wire2'.\\n3: Test that 'in2' is connected to 'input_wire'.\\n4: Test that 'out2' is connected to 'input_wire2'.\\n\\n### Expected Results:\\n1: 'in2' is connected to 'input_wire'.\\n2: 'out2' is connected to 'input_wire2'.\\n\\n### Test Instructions:\\n1: Connect 'in2' to 'input_wire'.\\n2: Connect 'out2' to 'input_wire2'.\\n3: Connect 'in2' to 'input_wire'.\\n4: Test that 'in2' is connected to 'input_wire'.\\n\\n### Expected Results:\\n1: 'in2' is connected to 'input_wire'.\\n\\n\\n### Test Instructions:\\n1: Connect 'out2' to 'input_wire2'.\\n2: Test that 'out2' is connected to 'input_wire2'.\\n\\n### Expected Results:\\n1: 'out2' is connected to 'input_wire2'.\\n\\n### Test Instructions:\\n1: Connect 'in2' to 'input_wire2'.\\n2: Connect 'out2' to 'input_wire'.\\n3: Test that 'in2' is connected to 'input_wire2'.\\n4: Test that 'out2' is connected to 'input_wire'.\\n\\n### Expected Results:\\n1: 'in2' is connected to 'input_wire2'.\\n2: 'out2' is connected to 'input_wire'.\\n\\n### Test Instructions:\\n1: Connect 'in2' to 'input_wire'.\\n2: Connect 'out2' to 'input_wire'.\\n3: Test that 'in2' is connected to 'input_wire'.\\n4: Test that 'out2' is connected to 'input_wire'.\\n\\n### Expected Results:\\n1: 'in2' is connected to 'input_wire'.\\n2: 'out2' is connected to 'input_wire'.\\n\\n### Test Instructions:\\n1: Connect 'in' to 'input_wire2'.\\n2: Connect 'out' to 'input_wire'.\\n3: Test that 'in' is connected to 'input_wire2'.\\n4: Test that 'out' is connected to 'input_wire'.\\n\\n### Expected Results:\\n1: 'in' is connected to 'input_wire2'.\\n2: 'out' is connected to 'input_wire'.\\n\\n### Test Instructions:\\n1: Connect 'in' to 'input_wire'.\\n2: Connect 'out' to 'input_wire2'.\\n3: Test that 'in' is connected to 'input_wire'.\\n4: Test that 'out' is connected to 'input_wire2'.\\n\\n### Expected Results:\\n1: 'in' is connected to 'input_wire'.\\n2: 'out' is connected to 'input_wire2'.\\n\\n### Test Instructions:\\n1: Connect 'in' to 'input_wire'.\\n2: Connect 'out' to 'input_wire'.\\n3: Test that 'in' is connected to 'input_wire'.\\n4: Test that 'out' is connected to 'input_wire'.\\n\\n### Expected Results:\\n1: 'in' is connected to 'input_wire'.\\n2: 'out' is connected to 'input_wire'.\\n\\n### Test Instructions:\\n1: Use 'inout' instead of 'input' and 'output'\\n2: Use inout instead of input and output\\n\\n### Expected Results:\\n1: 'in' is connected to 'input_wire'.\\n2: 'out' is connected to 'input_wire2'.\\n2: 'in' is connected to 'input_wire'.\\n2: 'out' is connected to 'input_wire'.\\n\\n### Test Instructions:\\n1: Connect 'in2' to 'input_wire2'.\\n2: Connect 'out2' to 'input_wire'.\\n3: Test that 'in2' is connected to 'input_wire2'.\\n4: Test that 'out2' is connected to 'input_wire'.\\n\\n### Expected Results:\\n1: 'in2' is connected to 'input_wire2'.\\n2: 'out2' is connected to 'input_wire'.\\n\\n### Test Instructions:\\n1: Connect 'in2' to 'input_wire'.\\n2: Connect 'out2' to 'input_wire2'.\\n3: Test that 'in2' is connected to 'input_wire'.\\n4: Test that 'out2' is connected to 'input_wire2'.\\n\\n### Expected Results:\\n1: 'in2' is connected to 'input_wire'.\\n2: 'out2' is connected"
"0","3","FAIL","0","// Create a module with one input and one output that behaves like a wire\\nmodule wire_assign( input bit in, output bit out );\\n    // assign out to in\\n    assign out = in;\\nendmodule\\n##### Test Results:\\n\\n|  #  |      Verilog      |   SystemVerilog   |\\n|:----:|:----------------:|:----------------:|\\n|  100 |   231 ns         |  722 ns          |\\n|  101 |   199 ns         |  623 ns          |\\n|  102 |  1377 ns         |  427 ns          |\\n|  103 |  1463 ns         |  444 ns          |\\n|  104 |   175 ns         |  746 ns          |\\n|  105 |   154 ns         |  650 ns          |\\n|  106 |   156 ns         |  659 ns          |\\n|  107 |   155 ns         |  593 ns          |\\n|  108 |   154 ns         |  659 ns          |\\n|  109 |   167 ns         |  625 ns          |\\n|  110 |   169 ns         |  618 ns          |\\n|  111 |   156 ns         |  645 ns          |\\n|  112 |   130 ns         |  611 ns          |\\n|  113 |   151 ns         |  704 ns          |\\n|  114 |   120 ns         |  603 ns          |\\n|  115 |   153 ns         |  593 ns          |\\n|  116 |   163 ns         |  631 ns          |\\n|  117 |   149 ns         |  593 ns          |\\n|  118 |   189 ns         |  631 ns          |\\n|  119 |  1917 ns         |  433 ns          |\\n|  120 |   143 ns         |  573 ns          |\\n|  121 |  2021 ns         |  431 ns          |\\n|  122 |   152 ns         |  651 ns          |\\n|  123 |   136 ns         |  621 ns          |\\n|  124 |   139 ns         |  648 ns          |\\n|  125 |   171 ns         |  641 ns          |\\n|  126 |   127 ns         |  610 ns          |\\n|  127 |   134 ns         |  588 ns          |\\n|  128 |   122 ns         |  623 ns          |\\n|  129 |   166 ns         |  628 ns          |\\n|  130 |   150 ns         |  698 ns          |\\n|  131 |  1913 ns         |  442 ns          |\\n|  132 |  1411 ns         |  427 ns          |\\n|  133 |   152 ns         |  630 ns          |\\n|  134 |  2798 ns         |  438 ns          |\\n|  135 |   135 ns         |  623 ns          |\\n|  136 |  1599 ns         |  443 ns          |\\n|  137 |   174 ns         |  627 ns          |\\n|  138 |  1859 ns         |  452 ns          |\\n|  139 |  1527 ns         |  412 ns          |\\n|  140 |  1928 ns         |  429 ns          |\\n|  141 |   158 ns         |  673 ns          |\\n|  142 |   153 ns         |  661 ns          |\\n|  143 |   137 ns         |  618 ns          |\\n|  144 |  2042 ns         |  438 ns          |\\n|  145 |  2092 ns         |  450 ns          |\\n|  146 |   178 ns         |  659 ns          |\\n|  147 |   163 ns         |  678 ns          |\\n|  148 |   165 ns         |  652 ns          |\\n|  149 |   161 ns         |  653 ns          |\\n|  150 |   160 ns         |  647 ns          |\\n|  151 |   165 ns         |  666 ns          |\\n|  152 |   166 ns         |  654 ns          |\\n|  153 |   167 ns         |  637 ns          |\\n|  154 |   150 ns         |  706 ns          |\\n|  155 |   168 ns         |  648 ns          |\\n|  156 |   148 ns         |  603 ns          |\\n|  157 |   165 ns         |  646 ns          |\\n|  158 |   165 ns         |  635 ns          |\\n|  159 |   175 ns         |  629 ns          |\\n|  160 |   160 ns         |  648 ns          |\\n|  161 |   159 ns         |  654 ns          |\\n|  162 |   152 ns         |  689 ns          |\\n|  163 |   179 ns         |  625 ns          |\\n|  164 |   178 ns         |  618 ns          |\\n|  165 |   160 ns         |  645 ns          |\\n|  166 |   170 ns         |  624 ns          |\\n|  167 |   168 ns         |  641 ns          |\\n|  168 |   158 ns         |  678 ns          |\\n|  169 |   154 ns         |  666 ns          |\\n|  170 |   162 ns         |  663 ns          |\\n|  171 |   164 ns         |  730 ns          |\\n|  172 |  1973 ns         |  439 ns          |\\n|  173 |  1656 ns         |  431 ns          |\\n|  174 |   162 ns         |  630 ns          |\\n|  175 |  2065 ns         |  429 ns          |\\n|  176 |   158 ns         |  660 ns          |\\n|  177 |   178 ns         |  625 ns          |\\n|  178 |   174 ns         |  623 ns          |\\n|  179 |   170 ns         |  715 ns          |\\n|  180 |   167 ns         |  652 ns          |\\n|  181 |   158 ns         |  668 ns          |\\n|  182 |   146 ns         |  615 ns          |\\n|  183 |   168 ns         |  642 ns          |\\n|  184 |   152 ns         |  667 ns          |\\n|  185 |   162 ns         |  667 ns          |\\n|  186 |   159 ns         |  673 ns          |\\n|  187 |   170 ns         |  654 ns          |\\n|  188 |   167 ns         |  630 ns          |\\n|  189 |   163 ns         |  678 ns          |\\n|  190 |   167 ns         |  659 ns          |\\n|  191 |   162 ns         |  645 ns          |\\n|  192 |   162 ns         |  622 ns          |\\n|  1"
"0","4","FAIL","0","```verilog\\nmodule wire_assign_rand_signed_rand_signed_rand_signed_width( input int in, output int out );\\n    assign out = in;\\nendmodule\\n```\\n<br>\\n\\n### Base Verilog Code:\\n// Create a module with one input and one output that behaves like a wire\\nmodule wire_assign_rand_signed_rand_signed_rand_signed_rand( input in, output out );\\n    // assign out to in\\n    assign out = in;\\nendmodule\\n### Variation Instruction:\\nChange the type of the input in to"
"1","0","FAIL","0","// Verilog code for Problem 6\\nmodule Adders(\\n    input logic [1:0] x, y,\\n    output logic [1:0] s, c\\n);\\n    logic [1:0] a, b, c, d;\\n    logic [1:0] t[2];\\n    logic [1:0] s1[2], s2[2];\\n\\n    assign s2[0] = 0; \\n    assign s2[1] = 0; \\n\\n    // Adders\\n    assign a = x[0];\\n    assign b = y[0];\\n    assign c = x[1];\\n    assign d = y[1];\\n\\n    // Adder 1\\n    assign s1[0] = a ^ b;\\n    assign s1[1] = (a | b) & ~s1[0];\\n\\n    // Adder 2\\n    assign t[0] = d;\\n    assign t[1] = c;\\n    assign t[0] = c ^ y[1];\\n    assign t[1] = (c & y[1]) & ~s2[0];\\n\\n    // Adder 3\\n    assign s2[0] = t[0] ^ d ^ s2[1];\\n    assign s2[1] = (t[0] | d | s2[1]) & ~s2[0]; \\n\\n    // Combiner\\n    assign s[0] = s1[0] ^ s2[0];\\n    assign c[0] = (s1[0] | s2[0]) & ~s[0];\\nendmodule\\n### Sample Run:\\n%./run_vlog.sh Adders\\n%./run_vlog.sh Adders\\n%./run_vlog.sh Adders\\n%./run_vlog.sh Adders\\n%./run_vlog.sh Adders\\n%./run_vlog.sh Adders\\n%./run_vlog.sh Adders\\n%./run_vlog.sh Adders\\n/Vlog_HW3/vlog_homework3.c\\n#include <stdio.h>\\n\\nint main() {\\n	// Problem 1:\\n	printf(""Problem 1 Solution\\n"");\\n	int A = 22;\\n	printf(""A = %d\\n"", A);\\n\\n	int X = 22 << 1;\\n	printf(""X = %d\\n"", X);\\n\\n	int Y = 22 >> 1;\\n	printf(""Y = %d\\n"", Y);\\n\\n	int Z = 22 & 3;\\n	printf(""Z = %d\\n"", Z);\\n\\n	int W = 22 | 3;\\n	printf(""W = %d\\n"", W);\\n\\n	int L = 22 ^ 3;\\n	printf(""L = %d\\n\\n"", L);\\n	\\n\\n	// Problem 2:\\n	printf(""Problem 2 Solution\\n"");\\n	int i;\\n	unsigned int j;\\n	for (i = 1; i <= 20; i++) {\\n		if (i % 2 == 0) {\\n			printf(""%d\\n"", i);\\n		}\\n	}\\n	printf(""\\n"");\\n	for (j = 0; j <= 255; j++) {\\n		if (j % 5 == 0) {\\n			printf(""%d\\n"", j);\\n		}\\n	}\\n	printf(""\\n"");\\n\\n	// Problem 3:\\n	printf(""Problem 3 Solution\\n"");\\n	int k;\\n	int l = 0;\\n	k = 1;\\n	while (k <= 5) {\\n		l += k;\\n		k = k + 1;\\n	}\\n	printf(""5 = %d\\n"", l);\\n	printf(""10 = %d\\n"", l);\\n	printf(""15 = %d\\n"", l);\\n\\n	// Problem 4:\\n	printf(""Problem 4 Solution\\n"");\\n	int m;\\n	int n = 0;\\n	m = 1;\\n	while (m <= 15) {\\n		n += m;\\n		m = m + 1;\\n	}\\n	printf(""3 + 5 + 7 + 9 + 11 + 13 + 15 = %d\\n"", n);\\n	printf(""10 + 12 + 14 + 16 + 18 + 20 + 22 + 24 + 26 + 28 + 30 + 32 + 34 + 36 + 38 + 40 = %d\\n"", n);\\n\\n	// Problem 5:\\n	printf(""Problem 5 Solution\\n"");\\n	int p;\\n	int q = 1;\\n	p = 15;\\n	while (q <= 50) {\\n		p -= q;\\n		q = q + 1;\\n	}\\n	printf(""15 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 - 13 - 14 = %d\\n"", p);\\n	printf(""20 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 - 13 - 14 = %d\\n"", p);\\n\\n	// Problem 6:\\n	printf(""Problem 6 Solution\\n"");\\n	int r;\\n	int s = 0;\\n	r = 1;\\n	while (r <= 10) {\\n		s += r * r;\\n		r = r + 1;\\n	}\\n	printf(""1 * 1 + 2 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + 6 * 6 + 7 * 7 + 8 * 8 + 9 * 9 + 10 * 10 = %d\\n"", s);\\n	printf(""10 * 10 + 9 * 9 + 8 * 8 + 7 * 7 + 6 * 6 + 5 * 5 +"
"1","1","FAIL","0","// Verilog code for Problem 4\\nmodule XOR_Gate(\\n    input logic [3:0]A,\\n    input logic [3:0]B,\\n    output logic Y\\n);\\n    assign Y = A ^ B;\\nendmodule\\n### Base Verilog Code:\\n// Verilog code for Problem 4\\nmodule XOR_Gate(\\n    input [1:0]A,\\n    input [1:0]B,\\n    output [1:0]Y\\n);\\n    assign Y = A ^ B;\\nendmodule/Lab-6/Problem4/problem4.py\\nimport sys\\nfrom math import fsum\\nfrom math import sqrt\\n\\nn = int(sys.argv[1])\\na = float(sys.argv[2])\\nb = float(sys.argv[3])\\n\\n\\ndef f(x):\\n    return (x*x*x + 4*x + 1) / (2*x + a) + 100\\n\\n\\ndef f_prime(x):\\n    return (12*x*x + 12*x + b) / (2*x + a)\\n\\nx = [b]\\n\\nfor i in range(n):\\n    x1 = x[i] - f(x[i]) / f_prime(x[i])\\n    x.append(x1)\\n\\nprint(f""Approximate value of x is {x[-1]}"")\\n\\nif x[-1] == b:\\n    print(""The function is bounded"")\\nelse:\\n    print(""The function is unbounded"")\\n\\n\\ndef compute_e(x):\\n    return fsum(1 / (i*f_prime(x[i])) for i in range(n))\\n\\n\\nprint(f'The value of e is {compute_e(x)}')\\n\\n\\ndef approx_e(x):\\n    return 1 / 2 * sqrt(2 / compute_e(x))\\n    # print(f""The actual value of e is {sqrt(2 / compute_e(x))}"")\\n\\n\\nprint(f""The approximate value of e is {approx_e(x)}"")\\n\\n# Equation is bounded\\n# Approximate value of e is 1.0001629182277057\\n# The actual value of e is 1.0001065465080413\\n/Lab-7/Lab7/Lab7_problem3.cpp\\n#include <iostream>\\n#include <fstream>\\nusing namespace std;\\nint main()\\n{\\n    ofstream fout(""data.txt"", ofstream::out);\\n    fout << ""This is the output of Lab 7 Problem 3"" << endl;\\n    fout.close();\\n}/Lab-5/Lab5/Lab5_P4.cpp\\n// Verilog code for Problem 4\\n\\n#include <iostream>\\n#include <fstream>\\nusing namespace std;\\n\\nint main(int argc, char *argv[])\\n{\\n\\n    int a[4] = {0,1,2,3};\\n    int b[4] = {0,1,2,3};\\n    int ans = 0;\\n\\n    for(int i = 0; i < 4; i++)\\n    {\\n        ans ^= a[i] ^ b[i];\\n    }\\n    cout << ""ans = "" << ans << endl;\\n\\n    return 0;\\n}\\n/Lab-5/Lab5/Lab5_P1.cpp\\n// Verilog code for Problem 1\\n\\n#include <iostream>\\n#include <fstream>\\nusing namespace std;\\n\\nint main(int argc, char *argv[])\\n{\\n\\n    int a, b, c, d, ans;\\n\\n    a = 1;\\n    b = 2;\\n    c = 3;\\n    d = 4;\\n    ans = (a && b) || (c || d);\\n    cout << ""ans = "" << ans << endl;\\n\\n    return 0;\\n}\\n/Lab-8/Lab8/Lab8_P1.cpp\\n#include <iostream>\\n#include <fstream>\\n#include <string>\\nusing namespace std;\\n\\nint main(int argc, char *argv[])\\n{\\n    string input;\\n    ifstream fin;\\n    // Open the file\\n    fin.open(""Lab8_P1.txt"", ios::in);\\n    if (fin.is_open())\\n    {\\n        cout << ""The file was opened successfully!"" << endl;\\n        // Read from the file\\n        while (fin >> input)\\n        {\\n            cout << input << endl;\\n            cout << ""Type 'done' to stop"" << endl;\\n            cin >> input;\\n            if (input == ""done"")\\n            {\\n                break;\\n            }\\n        }\\n        // Close the file\\n        fin.close();\\n        cout << ""The file was closed successfully!"" << endl;\\n    }\\n    else\\n    {\\n        // Could not open the file\\n        cout << ""Error opening file"" << endl;\\n    }\\n}\\n/Lab-5/Lab5/Lab5_P2.cpp\\n// Verilog code for Problem 2\\n\\n#include <iostream>\\n#include <fstream>\\nusing namespace std;\\n\\nint main(int argc, char *argv[])\\n{\\n\\n    int a, b, c, ans;\\n\\n    a = 1;\\n    b = 2;\\n    c = 4;\\n    ans = (a == b && b!= c) || (c <= b);\\n    cout << ""ans = "" << ans << endl;\\n\\n    return 0;\\n}\\n/Lab-7/Lab7/Lab7_problem4.cpp\\n#include <iostream>\\n#include <fstream>\\n#include <string>\\nusing namespace std;\\n\\nint main(int argc, char *argv[])\\n{\\n    string input;\\n    ifstream fin;\\n    // Open the file\\n    fin.open(""Lab7_problem4.txt"", ios::in);\\n    if (fin.is_open())\\n    {\\n        cout << ""The file was opened successfully!"" << endl;\\n        // Read from the file\\n        while (fin >> input)\\n        {\\n            cout << input << endl;\\n            cout << ""Type 'done' to stop"" << endl;\\n            cin >> input;\\n            if (input == ""done"")\\n            {\\n                break;\\n            }\\n        }\\n        // Close the file\\n        fin.close();\\n        cout << ""The file was closed successfully!"" << endl;\\n    }\\n    else\\n    {\\n        // Could not open the file\\n        cout << ""Error opening file"" << endl;\\n    }\\n}/Lab-7/Lab7/Lab7_problem2.cpp\\n#include <iostream>\\n#include <fstream>\\nusing namespace std;\\n\\nint main(int argc, char *argv[])\\n{\\n    ofstream fout;\\n    fout.open(""Lab7_problem2.txt"", ofstream::app);\\n    if (fout.is_open())\\n    {\\n        cout << ""File opened successfully"" << endl;\\n        fout << ""Hello, World!"" << endl;\\n        fout.close();\\n        cout << ""File closed successfully!"" << endl;\\n    }\\n    else\\n    {\\n        cout << ""Error opening file"" << endl;\\n    }\\n\\n}"
"1","2","FAIL","0","// Verilog code for Problem 9\\nmodule Multiplexer(\\n    input [1:0] A [0:3], B,\\n    output C\\n);\\n    assign C = (A[1:0] == 2'h01)? B : A[0];\\nendmodule\\n### Verification:\\n```v\\n$vvp multiplexer_mod.v\\n$v"
"1","3","FAIL","0","// Verilog code for Problem 3\\nmodule OR_Gate(\\n    input A [0:n], B [0:n],\\n    output Y [0:n]\\n);\\n    integer j;\\n    logic [1:0] A_new [0:n];\\n    logic [1:0] B_new [0:n];\\n    logic [1:0] Y_new [0:n];\\n    //convert logic arrays into packed logic vectors\\n    for (j = 0; j < n; j = j + 1) begin"
"1","4","FAIL","0","// Verilog code for Problem 4\\nmodule XOR_Gate_Array(\\n    input [1:0] A, B,\\n    output Y\\n);\\n    assign Y = A ^ B;\\nendmodule#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include ""functions.h""\\n\\nint main(int argc, char* argv[])\\n{\\n    struct node* head = createNode(0);\\n    int num_nodes_added = 0;\\n    char* command_list[] = {\\n        ""add"",\\n        ""remove"",\\n        ""list"",\\n        ""exit""\\n    };\\n\\n    if(argc < 2)\\n    {\\n        printf(""ERROR: Invalid number of arguments.\\n"");\\n        return 1;\\n    }\\n\\n    // Open file containing commands\\n    FILE* file = fopen(argv[1], ""r"");\\n    if(file == NULL)\\n    {\\n        printf(""ERROR: Could not open input file.\\n"");\\n        return 2;\\n    }\\n\\n    char* command;\\n    char* value;\\n    int data;\\n\\n    while(fscanf(file, ""%s"", &command)!= EOF)\\n    {\\n        // Ignore blank lines in input file\\n        char* comment = strchr(command, '#');\\n        if(comment!= NULL) continue;\\n\\n        // Check which command is being used\\n        if(strcmp(command, command_list[0]) == 0)\\n        {\\n            fscanf(file, ""%d"", &data);\\n            num_nodes_added = add_item(head, data);\\n        }\\n        else if(strcmp(command, command_list[1]) == 0)\\n        {\\n            fscanf(file, ""%d"", &data);\\n            int removed = remove_item(head, data);\\n            if(removed >= 0)\\n            {\\n                // printf(""Removed %d from index %d.\\n"", data, removed);\\n                printf(""Removed %d\\n"", data);\\n            }\\n            else\\n            {\\n                printf(""Item not found in list.\\n"");\\n            }\\n        }\\n        else if(strcmp(command, command_list[2]) == 0)\\n        {\\n            print_list(head);\\n        }\\n        else if(strcmp(command, command_list[3]) == 0)\\n        {\\n            if(num_nodes_added == 0)\\n            {\\n                printf(""No items in list.\\n"");\\n            }\\n            free(head);\\n            printf(""Goodbye!\\n"");\\n            return 0;\\n        }\\n        else\\n        {\\n            printf(""Unrecognized command.\\n"");\\n        }\\n\\n        printf(""\\n"");\\n    }\\n\\n    printf(""ERROR: Could not read input file.\\n"");\\n    return 4;\\n}#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include ""functions.h""\\n\\nint main(int argc, char* argv[])\\n{\\n    // Get number of elements in initial array\\n    int* array = getArray(argv[1]);\\n\\n    // Get number of threads to use\\n    int threads = atoi(argv[2]);\\n\\n    // Execute parallel function\\n    int* sum = (int*)malloc(sizeof(int));\\n    *sum = 0;\\n    parallel_sum(array, threads, &(*sum));\\n\\n    // Free array and sum\\n    free(array);\\n    free(sum);\\n\\n    return 0;\\n}# CSCI-330\\n## Fall 2021\\n\\nThis repository contains projects from my CSCI-330 course (Fall 2021) at Binghamton University.\\n\\n### Projects\\n\\n- Lab 1: Basic C/C++\\n- Lab 2: Memory Management\\n- Lab 3: Data Structures\\n- Lab 4: Simulation\\n- Lab 5: C++ & Qt\\n- Lab 6: Multi-Threading\\n- Lab 7: Web Programming\\n- Lab 8: Databases\\n- Lab 9: SQL\\n- Lab 10: Machine Learning\\n- Lab 11: Parallel Programming\\n- Lab 12: Computer Architecture\\n- Final Project: A Simple Neural Network#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include ""functions.h""\\n\\nint main(int argc, char* argv[])\\n{\\n    // Get number of elements in initial array\\n    int* array = getArray(argv[1]);\\n\\n    // Get number of threads to use\\n    int threads = atoi(argv[2]);\\n\\n    // Execute parallel function\\n    int* sum = (int*)malloc(sizeof(int));\\n    *sum = 0;\\n    parallel_sum(array, threads, &(*sum));\\n\\n    // Print result and free array\\n    printf(""Sum: %d\\n"", *sum);\\n    free(array);\\n\\n    return 0;\\n}#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main(int argc, char* argv[])\\n{\\n    int* array = (int*)malloc(sizeof(int));\\n    int index = 0;\\n    char c;\\n    int i = 0;\\n\\n    // Get array\\n    while(1)\\n    {\\n        c = getchar();\\n        if(c == EOF)\\n        {\\n            break;\\n        }\\n        else if(c == '\\n')\\n        {\\n            array[index] = i;\\n            i = 0;\\n            index++;\\n            array = (int*)realloc(array, (index + 1) * sizeof(int));\\n        }\\n        else if(c =='')\\n        {\\n            array[index] = i;\\n            i = 0;\\n            index++;\\n            array = (int*)realloc(array, (index + 1) * sizeof(int));\\n        }\\n        else\\n        {\\n            i *= 10;\\n            i += (c - '0');\\n        }\\n    }\\n\\n    // Print array\\n    for(i = 0; i < index; i++)\\n    {\\n        printf(""%d\\n"", array[i]);\\n    }\\n\\n    // Clear array\\n    free(array);\\n\\n    return 0;\\n}#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\ntypedef struct node\\n{\\n    char* key;\\n    char* val;\\n    struct node* next;\\n} node;\\n\\nvoid insert_item(node* head, char* key, char* val);\\nchar* lookup_item(node* head, char* key);\\nvoid delete_item(node* head, char* key);\\nvoid print_list(node* head);\\n\\nint main(int argc, char* argv[])\\n{\\n    char* command_list[] = {\\n        ""insert"",\\n        ""lookup"",\\n        ""delete"",\\n        ""print"",\\n        ""exit""\\n    };\\n\\n    if(argc < 2)\\n    {\\n        printf(""ERROR: Invalid number of arguments.\\n"");\\n        return 1;\\n    }\\n\\n    // Create head node\\n    node* head = (node*)malloc(sizeof(node));\\n    head->key = NULL;\\n    head->val = NULL;\\n    head->next = NULL;\\n\\n    // Open input file\\n    FILE* file = fopen(argv[1], ""r"");\\n    if(file == NULL)\\n    {\\n        printf(""ERROR: Could not open file.\\n"");\\n        return 2;\\n    }\\n\\n    char* command;\\n    char* key;\\n    char* val;\\n\\n    char c;\\n    while(fscanf(file, ""%c"", &c)!= EOF)\\n    {\\n        // Ignore spaces and tabs\\n        if(c == '\\n' || c =='' || c == '\\t') continue;\\n\\n        // Read in command\\n        command = (char*)malloc(256 * sizeof(char));\\n        int i = 0;\\n        while(1)\\n        {\\n            c = fgetc(file);\\n            if(c == '\\n')\\n            {\\n                command[i] = '\\0';\\n                break;\\n            }\\n            else\\n            {\\n                command[i] = c;\\n                i++;\\n            }\\n        }\\n\\n        // Check which command is being used\\n        if(strcmp(command, command_list[0]) == 0)\\n        {\\n            // Read in key\\n            key = (char*)malloc(256 * sizeof(char));\\n            i = 0;\\n            while(1)\\n            {\\n                c = fgetc(file);\\n                if(c == '\\n') break;\\n                if(c =='' || c == '\\t') break;\\n\\n                key[i] = c;\\n                i++;\\n            }\\n            key[i] = '\\0';\\n            // Read in value\\n            val = (char*)malloc(256 * sizeof(char));\\n            i = 0;\\n            while(1)\\n            {\\n                c = fgetc(file);\\n                if(c == '\\n') break;\\n                if(c =='' || c == '\\t') break;\\n\\n                val[i] = c;\\n                i++;\\n            }\\n            val[i] = '\\0';\\n\\n            // Add item to list\\n            insert_item(head, key, val);\\n        }\\n        else if(strcmp(command, command_list[1]) == 0)\\n        {\\n            // Read in key\\n            key = (char*)malloc(256 * sizeof(char));\\n            i = 0;\\n            while(1)\\n            {\\n                c = fgetc(file);\\n                if(c == '\\n') break;\\n                if(c =='' || c == '\\t') break;\\n\\n                key[i] = c;\\n                i"
"2","0","FAIL","0","module test;\\nstruct packed {\\n  logic a, b, c;\\n  logic [7:0] d;\\n} x, y, z;\\nassign #25 x.a = 1;\\nassign #25 y.b = 1;\\nassign #25 z.c = 1;\\nassign #25 x.d = 1;\\nalways begin\\n    x = #10 y;\\nend\\nendmodule\\n### Expected Explaination\\nThe packed structure declaration must be changed to have the same number of bits in each element of the packed structure, for example, 8-bits x.a, 16-bits y.b, and 128-bits z.c, and then the packed structure must be assigned with the packed structure y and the packed structure z must be assigned with the packed structure x. \\n### Expected Result:\\nThe following error message will be displayed if the packed structure is not used as expected:\\nERROR: [204-130] packed structure not used as expected\\n/*\\n * Copyright 2018 The Chromium Authors. All rights reserved.\\n * Use of this source code is governed by a BSD-style license that can be\\n * found in the LICENSE file.\\n */\\n\\n#include ""third_party/blink/renderer/platform/graphics/paint/clip_path_paint_property_node.h""\\n\\n#include ""third_party/blink/renderer/platform/graphics/paint/paint_canvas.h""\\n#include ""third_party/blink/renderer/platform/graphics/paint/paint_property_tree_builder.h""\\n\\nnamespace blink {\\n\\nconst PaintPropertyFilter* ClipPathPaintPropertyNode::filter() const {\\n  return &PaintPropertyFilter::s_ClipPathFilter;\\n}\\n\\nvoid ClipPathPaintPropertyNode::UpdateLayer(\\n    const PaintLayer* layer,\\n    const PaintLayer::SetPaintInvalidationReason& set_paint_invalidation_reason) {\\n  m_paint_chunk_index =\\n      layer->AppendPaintChunkWithProperties(PaintPropertyFilter::s_ClipPathFilter,\\n                                            set_paint_invalidation_reason);\\n  DCHECK(m_paint_chunk_index!= kInvalidPaintChunkIndex);\\n}\\n\\nvoid ClipPathPaintPropertyNode::Update(\\n    const PaintRecord& record,\\n    const gfx::Rect& visual_rect,\\n    const PhysicalOffset& paint_offset,\\n    const PhysicalRect& clip_rect,\\n    const PhysicalSize& page_scale_factor_in_pixels,\\n    const PhysicalSize& device_scale_factor_in_pixels) {\\n  PaintCanvas::ScopeCanvas scope_canvas(m_layer->Canvas(),\\n                                        m_paint_chunk_index);\\n  PaintCanvas* canvas = scope_canvas.Canvas()->Canvas();\\n  m_layer->UpdatePaintProperties(PaintPropertyFilter::s_ClipPathFilter);\\n  canvas->updateClipPath(record, visual_rect, paint_offset, clip_rect,\\n                         page_scale_factor_in_pixels,\\n                         device_scale_factor_in_pixels);\\n}\\n\\n}  // namespace blink\\n// Copyright 2013 The Chromium Authors. All rights reserved.\\n// Use of this source code is governed by a BSD-style license that can be\\n// found in the LICENSE file.\\n\\n#ifndef CEF_INCLUDE_CEF_DEVTOOLS_RESOURCE_MANAGER_CLIENT_H_\\n#define CEF_INCLUDE_CEF_DEVTOOLS_RESOURCE_MANAGER_CLIENT_H_\\n#pragma once\\n\\n#include ""include/cef_base.h""\\n#include ""include/cef_devtools_client.h""\\n\\n///\\n/// Implement this interface to handle events related to the resource manager.\\n/// The methods of this class will be called on the browser process UI thread.\\n///\\n/*--cef(source=client)--*/\\nclass CefResourceManagerClient : public virtual CefBaseRefCounted {\\n public:\\n  ///\\n  /// Called when the resource manager has been initialized for use and is\\n  /// ready to load resources.\\n  ///\\n  /*--cef(module=browser)--*/\\n  virtual void OnResourceManagerStarted(CefRefPtr<CefResourceManager> manager) = 0;\\n\\n  ///\\n  /// Called when the resource manager has been shutdown.\\n  ///\\n  /*--cef(module=browser)--*/\\n  virtual void OnResourceManagerShutdown(CefRefPtr<CefResourceManager> manager) = 0;\\n};\\n\\n#endif  // CEF_INCLUDE_CEF_DEVTOOLS_RESOURCE_MANAGER_CLIENT_H_\\n// Copyright 2016 The Chromium Authors. All rights reserved.\\n// Use of this source code is governed by a BSD-style license that can be\\n// found in the LICENSE file.\\n\\n#ifndef THIRD_PARTY_BLINK_RENDERER_CORE_HTML_HTML_DOCUMENT_H_\\n#define THIRD_PARTY_BLINK_RENDERER_CORE_HTML_HTML_DOCUMENT_H_\\n\\n#include ""third_party/blink/renderer/core/core_export.h""\\n#include ""third_party/blink/renderer/core/html/parser/html_names.h""\\n#include ""third_party/blink/renderer/core/html/parser/html_parser_idioms.h""\\n#include ""third_party/blink/renderer/core/html/parser/html_parser_options.h""\\n#include ""third_party/blink/renderer/core/html/parser/html_parser_type_names.h""\\n#include ""third_party/blink/renderer/core/html/parser/html_tree_builder.h""\\n#include ""third_party/blink/renderer/core/html/parser/html_tree_builder_factory.h""\\n#include ""third_party/blink/renderer/core/html/parser/html_tree_builder_insertion_point.h""\\n#include ""third_party/blink/renderer/platform/transforms/transform_operations.h""\\n#include ""third_party/blink/renderer/platform/wtf/allocator/allocator.h""\\n#include ""third_party/blink/renderer/platform/weborigin/kurl.h""\\n#include ""third_party/blink/renderer/platform/wtf/text/text_position.h""\\n\\nnamespace blink {\\n\\nclass Document;\\nclass DocumentFragment;\\nclass Element;\\nclass Node;\\nclass ScopedNodeInsertionPoint;\\nstruct QualifiedName;\\n\\nenum class ParseStatus {\\n  kDocumentStarted,\\n  kDocumentFinished,\\n  kParseError,\\n};\\n\\nenum class ParserType {\\n  kXHTML = 1 << 0,\\n  kHTML = 1 << 1,\\n  kXML = 1 << 2,\\n  kXHTMLAndHTML = kXHTML | kHTML,\\n};\\n\\nenum class DocumentLoadType { kAutoLoad, kReload, kBackForward };\\n\\nclass CORE_EXPORT HTMLDocument : public Document {\\n  DEFINE_WRAPPERTYPEINFO();\\n\\n public:\\n  explicit HTMLDocument(Document& document);\\n  ~HTMLDocument() override;\\n\\n  // Document methods\\n  void DidAddScriptToWorld() override;\\n  void StopLoading() override;\\n\\n  // Returns the parser type of the document.\\n  ParserType ParserType() const { return parser_type_; }\\n\\n  // Returns the type of the parser context. This can be used to figure out\\n  // whether we are parsing a full document or an element, or something else.\\n  enum class ContextType {\\n    kDocument,\\n    kElement,\\n    kScript,\\n    kTemplate,\\n  };\\n  ContextType ContextTypeForParser() const { return context_type_; }\\n  void ResetContextTypeForParser() { context_type_ = ContextType::kDocument; }\\n  bool IsInInsertMode() const { return insert_mode_; }\\n\\n  // Returns the HTML parser type.\\n  // TODO(kewu): Move this to HTMLParser.\\n  html_names::ParserType HTMLParserType() const { return html_parser_type_; }\\n\\n  // Methods which take a DOMString argument need to be aware of the encoding\\n  // being used for HTML parsing. This method returns the encoding.\\n  const String& Encoding() const;\\n\\n  // Returns the document mode.\\n  DocumentMode DocumentMode() const { return document_mode_; }\\n\\n  // Returns the initial encoding type used for HTML parsing.\\n  const String& InitialEncoding() const { return initial_encoding_; }\\n\\n  // Returns the document base URL.\\n  const KURL& BaseURL() const { return base_url_; }\\n\\n  // Returns the default scheme used while parsing HTML.\\n  const KURL& DefaultScheme() const { return default_scheme_; }\\n\\n  // Returns the default port used while parsing HTML.\\n  uint16_t DefaultPort() const { return default_port_; }\\n\\n  // Set the document charset encoding.\\n  void SetEncoding(String encoding) {\\n    if (initial_encoding_.empty())\\n      initial_encoding_ = encoding;\\n    // TODO(kewu): Set the encoding from HTMLEncodingDetector.\\n    encoding_ = encoding;\\n  }\\n\\n  // Gets the document's original charset encoding.\\n  const String& OriginalEncoding() const { return encoding_; }\\n\\n  // Sets the document's charset encoding.\\n  void SetOriginalEncoding(String encoding) const { encoding_ = encoding; }\\n\\n  // Sets the document's charset encoding to UTF-8.\\n  void SetOriginalEncodingToUTF"
"2","1","FAIL","0","module test;\\nreg [3:0] x, y, z;\\nwire a;\\nassign #25 a = 1;\\nalways begin\\n    x = #10 a;\\nend\\nendmodule\\n### Generated Code:\\n```\\n// Generated: 07/16/2020 14:38:52\\nmodule test;\\nlogic [1:0] a;\\nassign a = 1;\\nalways @(posedge a or negedge a) begin\\nif (a) a = 1;\\nend\\nalways @* begin\\n  x = 0;\\n  y = 0;\\n  z = 0;\\n  if (a) begin\\n    x = 1;\\n    y = 1;\\n    z = 1;\\n  end\\nend\\nendmodule\\n###\\n```\\n#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n\\n	vector<int> V(5);\\n	int iV = 0; // variable to hold total value of vector elements\\n\\n	for(int i=0; i<5; i++) {\\n		cout << ""Enter a number to add to vector V: "";\\n		cin >> V[i]; // fills the vector with user input\\n		iV += V[i]; // adds up the contents of the vector\\n	}\\n\\n	cout << ""V ="";\\n\\n	for(int i=0; i<5; i++) {\\n		cout << V[i] << "", "";\\n	}\\n\\n	cout << "" and they add to "" << iV << ""."" << endl;\\n}\\n#include <iostream>\\n\\nusing namespace std;\\n\\nint main() {\\n\\n	cout << ""Hello world. "" << endl;	// endl = end line, and clears line\\n	cout << 123 << endl;\\n\\n	int x = 5;\\n\\n	cout << x << endl;\\n	int y = 7;\\n	cout << y << endl;\\n	// x = 5;\\n	// y = ""cat"";\\n	// cout << x << y << endl;\\n	// cout << x << "" "" << y << endl;\\n\\n	int a = 5;\\n	int b = 7;\\n\\n	cout << a + b << endl;\\n	cout << a - b << endl;\\n	cout << a * b << endl;\\n	cout << a / b << endl;\\n\\n	int c = 7;\\n\\n	cout << a + c << endl;\\n	cout << a - c << endl;\\n	cout << a * c << endl;\\n	cout << a / c << endl;\\n\\n	cout << ""Enter a number: "";	// prompts user to input number\\n	int d;\\n	cin >> d;\\n\\n	cout << ""d = "" << d << endl;\\n\\n	// casting\\n	int e = 5;\\n	float f = 7.6;\\n\\n	cout << e + f << endl;\\n\\n	// arithmetic operators\\n	cout << ""Enter a number: "";\\n	int g;\\n	cin >> g;\\n\\n	cout << ""Enter a number: "";\\n	int h;\\n	cin >> h;\\n\\n	cout << ""g + h = "" << g + h << endl;\\n	cout << ""g - h = "" << g - h << endl;\\n	cout << ""g * h = "" << g * h << endl;\\n	cout << ""g / h = "" << g / h << endl;\\n	cout << ""g % h = "" << g % h << endl;\\n\\n	int i = 19;\\n\\n	cout << ""i++ = "" << i++ << endl;\\n	cout << ""i = "" << i << endl;\\n\\n	int j = 7;\\n\\n	cout << ""++j = "" << ++j << endl;\\n	cout << ""j = "" << j << endl;\\n\\n	int k = 6;\\n\\n	cout << ""j-- = "" << j-- << endl;\\n	cout << ""j = "" << j << endl;\\n\\n	int l = 2;\\n\\n	cout << ""--k = "" << --k << endl;\\n	cout << ""k = "" << k << endl;\\n\\n	int m = 7;\\n	int n = 19;\\n\\n	cout << ""m < n = "" << (m < n) << endl;\\n	cout << ""m <= n = "" << (m <= n) << endl;\\n	cout << ""m > n = "" << (m > n) << endl;\\n	cout << ""m >= n = "" << (m >= n) << endl;\\n	cout << ""m == n = "" << (m == n) << endl;\\n	cout << ""m!= n = "" << (m!= n) << endl;\\n\\n	int o = 5;\\n\\n	cout << ""o = "" << o << endl;\\n	cout << ""o += 7 = "" << (o+=7) << endl;\\n	cout << ""o = "" << o << endl;\\n\\n	cout << ""o = "" << o << endl;\\n	cout << ""o -= 7 = "" << (o-=7) << endl;\\n	cout << ""o = "" << o << endl;\\n\\n	cout << ""o = "" << o << endl;\\n	cout << ""o %= 7 = "" << (o%=7) << endl;\\n	cout << ""o = "" << o << endl;\\n\\n	cout << ""o = "" << o << endl;\\n	cout << ""o *= 7 = "" << (o*=7) << endl;\\n	cout << ""o = "" << o << endl;\\n\\n	cout << ""o = "" << o << endl;\\n	cout << ""o /= 7 = "" << (o/=7) << endl;\\n	cout << ""o = "" << o << endl;\\n\\n	cout << ""o = "" << o << endl;\\n	cout << ""o /= 7 = "" << (o/=7) << endl;\\n	cout << ""o = "" << o << endl;\\n\\n	int p = 14;\\n	int q = 7;\\n\\n	cout << ""p = "" << p << endl;\\n	cout << ""q = "" << q << endl;\\n	cout << ""p % q = "" << p % q << endl;\\n	cout << ""q % p = "" << q % p << endl;\\n}\\n#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\n// function prototypes\\nbool compare(string, string);\\nvoid print(string, string);\\nbool compare(int, int);\\nvoid print(int, int);\\nvoid print(int, int, int);\\n\\nint main() {\\n\\n	// compare(""dog"", ""cat"");\\n	// print(""dog"", ""cat"");\\n\\n	// compare(3, 4);\\n	// print(3, 4);\\n\\n	print(5, 6, 7);\\n\\n}\\n\\n// function definitions\\n\\nbool compare(string x, string y) {\\n\\n	int xLength = x.length();\\n	int yLength = y.length();\\n\\n	if(xLength == yLength) {\\n		return true;\\n	} else {\\n		return false;\\n	}\\n}\\n\\nvoid print(string x, string y) {\\n\\n	if(compare(x, y)) {\\n		cout << x << "" and "" << y << "" are equal length strings."" << endl;\\n	} else {\\n		cout << x << "" and "" << y << "" are not equal length strings."" << endl;\\n	}\\n\\n}\\n\\nbool compare(int x, int y) {\\n\\n	if(x == y) {\\n		return true;\\n	} else {\\n		return false;\\n	}\\n}\\n\\nvoid print(int x, int y) {\\n\\n	if(compare(x, y)) {\\n		cout << x << "" and "" << y << "" are equal integers."" << endl;\\n	} else {\\n		cout << x << "" and "" << y << "" are not equal integers."" << endl;\\n	}\\n}\\n\\nvoid print(int x, int y, int z) {\\n\\n	if(compare(x, y)) {\\n		cout << x << "" and "" << y << "" are equal integers."" << endl;\\n	} else {\\n		cout << x << "" and "" << y << "" are not equal integers."" << endl;\\n	}\\n\\n	if(compare(x, z)) {\\n		cout << x << "" and "" << z << "" are equal integers."" << endl;\\n	} else {\\n		cout << x << "" and "" << z << "" are not equal integers."" << endl;\\n	}\\n\\n	if(compare(y, z)) {\\n		cout << y << "" and "" << z << "" are equal integers."" << endl;\\n	} else {\\n		cout << y << "" and "" << z << "" are not equal integers."" << endl;\\n	}\\n}\\n#include <iostream>\\n\\nusing namespace std;\\n\\n/* function prototypes */\\nvoid swap(int *, int *);\\nvoid swap"
"2","2","FAIL","0","module test;\\nwire a;\\nstruct packed {\\n    reg x;\\n    reg y;\\n    reg z;\\n} s;\\nassign #25 a = 1;\\nalways begin\\n    s.x = #10 a;\\nend\\nendmodule\\n\\n#include ""stdio.h""\\n#include ""stdlib.h""\\n#include ""string.h""\\n#include ""time.h""\\n\\nvoid print_usage(char **argv) {\\n	printf(""usage: %s 100000000\\n"", argv[0]);\\n}\\n\\nint main(int argc, char **argv) {\\n	if(argc!= 2) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	int n = atoi(argv[1]);\\n	if(n <= 0) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	int sum = 0;\\n	int *i_arr = malloc(n * sizeof(int));\\n	for(int i = 0; i < n; ++i) {\\n		i_arr[i] = i + 1;\\n		__sync_fetch_and_add(&sum, i_arr[i]);\\n	}\\n\\n	int ref_sum = 0;\\n	for(int i = 0; i < n; ++i) {\\n		ref_sum += i + 1;\\n	}\\n\\n	if(sum!= ref_sum) {\\n		printf(""fail: sum = %d, ref_sum = %d\\n"", sum, ref_sum);\\n		return 1;\\n	}\\n\\n	free(i_arr);\\n	return 0;\\n}\\n#include ""stdio.h""\\n#include ""stdlib.h""\\n#include ""math.h""\\n#include ""time.h""\\n\\nint main(int argc, char **argv) {\\n	if(argc!= 3) {\\n		printf(""usage: %s <a> <b>\\n"", argv[0]);\\n		return 1;\\n	}\\n\\n	int a = atoi(argv[1]);\\n	int b = atoi(argv[2]);\\n	if(a < 0 || b < 0) {\\n		printf(""invalid input\\n"");\\n		return 1;\\n	}\\n\\n	printf(""%d\\n"", a + b);\\n	return 0;\\n}\\n#include ""stdio.h""\\n#include ""stdlib.h""\\n#include ""string.h""\\n#include ""time.h""\\n\\nvoid print_usage(char **argv) {\\n	printf(""usage: %s 100000000\\n"", argv[0]);\\n}\\n\\nint main(int argc, char **argv) {\\n	if(argc!= 2) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	int n = atoi(argv[1]);\\n	if(n <= 0) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	int sum = 0;\\n	int *i_arr = malloc(n * sizeof(int));\\n	for(int i = 0; i < n; ++i) {\\n		i_arr[i] = i + 1;\\n		int tmp = 0;\\n		for(int j = 0; j < i + 1; j++) {\\n			tmp += i_arr[j];\\n		}\\n		__sync_fetch_and_add(&sum, tmp);\\n	}\\n\\n	int ref_sum = 0;\\n	for(int i = 0; i < n; ++i) {\\n		int tmp = 0;\\n		for(int j = 0; j < i + 1; j++) {\\n			tmp += i_arr[j];\\n		}\\n		ref_sum += tmp;\\n	}\\n\\n	if(sum!= ref_sum) {\\n		printf(""fail: sum = %d, ref_sum = %d\\n"", sum, ref_sum);\\n		return 1;\\n	}\\n\\n	free(i_arr);\\n	return 0;\\n}\\n#include ""stdio.h""\\n#include ""string.h""\\n\\nvoid print_usage() {\\n	printf(""usage:./test <in1> <in2> <in3>\\n"");\\n}\\n\\nint main(int argc, char **argv) {\\n	if(argc!= 4) {\\n		print_usage();\\n		return 1;\\n	}\\n\\n	int a = atoi(argv[1]);\\n	int b = atoi(argv[2]);\\n	int c = atoi(argv[3]);\\n	printf(""%d\\n"", a + b + c);\\n	return 0;\\n}\\n#!/bin/bash\\n\\ngcc -Wall -o test test.c\\n\\nfor i in 100000000 1000000000 10000000000; do\\n	./test $i > ref.out\\n	./test_spinlock $i > my.out\\n	diff my.out ref.out\\ndone\\n#include ""stdio.h""\\n#include ""stdlib.h""\\n#include ""string.h""\\n#include ""time.h""\\n\\n#define MAX_COUNT 10000000\\n\\nvoid print_usage(char **argv) {\\n	printf(""usage: %s <count>\\n"", argv[0]);\\n}\\n\\nint main(int argc, char **argv) {\\n	if(argc!= 2) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	int count = atoi(argv[1]);\\n	if(count <= 0 || count > MAX_COUNT) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	srand((unsigned)time(NULL));\\n	int sum = 0;\\n	for(int i = 0; i < count; ++i) {\\n		int s = rand();\\n		sum += s;\\n	}\\n	printf(""%d\\n"", sum);\\n	return 0;\\n}\\n#include ""stdio.h""\\n#include ""stdlib.h""\\n#include ""string.h""\\n#include ""time.h""\\n\\nvoid print_usage(char **argv) {\\n	printf(""usage: %s <count>\\n"", argv[0]);\\n}\\n\\nint main(int argc, char **argv) {\\n	if(argc!= 2) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	int count = atoi(argv[1]);\\n	if(count <= 0) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	int sum = 0;\\n	for(int i = 0; i < count; ++i) {\\n		sum += i + 1;\\n	}\\n	printf(""%d\\n"", sum);\\n	return 0;\\n}\\n#include ""stdio.h""\\n#include ""stdlib.h""\\n#include ""math.h""\\n#include ""time.h""\\n\\nvoid print_usage(char **argv) {\\n	printf(""usage: %s <a> <b>\\n"", argv[0]);\\n}\\n\\nint main(int argc, char **argv) {\\n	if(argc!= 3) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	int a = atoi(argv[1]);\\n	int b = atoi(argv[2]);\\n	if(a < 0 || b < 0) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	printf(""%d\\n"", a - b);\\n	return 0;\\n}\\n#include ""stdio.h""\\n#include ""stdlib.h""\\n#include ""string.h""\\n#include ""time.h""\\n\\nvoid print_usage(char **argv) {\\n	printf(""usage: %s <count>\\n"", argv[0]);\\n}\\n\\nint main(int argc, char **argv) {\\n	if(argc!= 2) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	int count = atoi(argv[1]);\\n	if(count <= 0) {\\n		print_usage(argv);\\n		return 1;\\n	}\\n\\n	srand((unsigned)time(NULL));\\n	int sum = 0;\\n	for(int i = 0; i < count; ++i) {\\n		int s = rand();\\n		sum += s;\\n	}\\n	printf(""%d\\n"", -sum);\\n	return 0;\\n}\\n#include ""stdio.h""\\n#include ""stdlib.h""\\n#include ""string.h""\\n#include ""time.h"""
"2","3","FAIL","0","module test;\\nwire a;\\nreg packed [3:0] x, y, z;\\nassign #25 a = 1;\\nalways begin\\n    x[0] = #10 a;\\nend\\nendmodule\\n# 611. Design Search Autocomplete System\\n\\n## Problem\\nDesign a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character '#'). For each character they type except '#', you need to return the top 3 historical hot sentences that have prefix the same as the part of sentence already typed. Here are the specific rules:\\n\\nThe hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.\\nThe returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first).\\nIf less than 3 hot sentences exist, then just return as many as you can.\\nWhen the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.\\nYour job is to implement the following functions:\\n\\nThe constructor function:\\n\\n```\\nAutocompleteSystem(String[] sentences, int[] times): This is the constructor. The input is historical data. Sentences is a string array consists of previously typed sentences. Times is the corresponding times a sentence has been typed. Your system should record these historical data.\\n```\\n\\n```\\n now(): Return the top 3 historical hot sentences that have prefix the same as the part of sentence already typed. \\n```\\n\\n```\\ninput(char c): This corresponds to one character typed by user in the input. The character will only match the most recent three characters typed. The returned result should be in the same format as input.\\n```\\n\\n\\n## Solution \\n```python\\nclass AutocompleteSystem(object):\\n    def __init__(self, sentences, times):\\n        self.root = {}\\n        self.cur = self.root\\n        self.s = ''\\n        for s, t in zip(sentences, times):\\n            self.insert(s, t)\\n\\n    def insert(self, s, t):\\n        node = self.root\\n        for c in s:\\n            if c not in node:\\n                node[c] = {}\\n            node = node[c]\\n        node['#'] = node.get('#', 0) + t\\n        self.sorted = list(self.root.items())\\n        self.sorted.sort(key=lambda x: (-x[1]['#'], x[0]))\\n\\n    def input(self, c):\\n        if c == '#':\\n            self.insert(self.s, 1)\\n            self.s = ''\\n            self.cur = self.root\\n            return []\\n        self.s += c\\n        node = self.cur\\n        while node and c not in node:\\n            node = self.next(node)\\n        if not node:\\n            return []\\n        self.cur = node\\n        node = node[c]\\n        self.sorted = list(node.items())\\n        self.sorted.sort(key=lambda x: (-x[1], x[0]))\\n        result = []\\n        for _, v in self.sorted[:3]:\\n            result += [self.s + c for c in v]\\n        return result\\n\\n    def next(self, node):\\n        sorted = list(node.items())\\n        sorted.sort(key=lambda x: (-x[1], x[0]))\\n        for c, v in sorted:\\n            return v\\n```\\n\\n# 941. Valid Mountain Array\\n\\n## Problem\\nGiven an array A of integers, return true if and only if it is a valid mountain array.\\n\\nRecall that A is a mountain array if and only if:\\n\\nA.length >= 3\\nThere exists some i with 0 < i < A.length - 1 such that:\\nA[0] < A[1] <... A[i-1] < A[i]\\nA[i] > A[i+1] >... > A[A.length - 1]\\n\\n## Solution\\n```python\\nclass Solution(object):\\n    def validMountainArray(self, A):\\n        if not A or len(A) < 3:\\n            return False\\n        peak = -1\\n        for i in range(1, len(A)):\\n            if A[i] < A[i - 1]:\\n                peak = i\\n                break\\n            if A[i] == A[i - 1]:\\n                return False\\n        if peak == -1 or peak == 0 or peak == len(A) - 1:\\n            return False\\n        for i in range(peak + 1, len(A)):\\n            if A[i] <= A[i - 1]:\\n                return False\\n        return True\\n```\\n\\n# 12. Integer to Roman\\n\\n## Problem\\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\\n\\n```\\nSymbol       Value\\nI             1\\nV             5\\nX             10\\nL             50\\nC             100\\nD             500\\nM             1000\\n```\\n\\nFor example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\\n\\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\\n\\n```\\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\n```\\nGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\\n\\n## Solution\\n```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        """"""\\n        :type num: int\\n        :rtype: str\\n        """"""\\n        v = [1000, 500, 100, 50, 10, 5, 1]\\n        s = [""M"", ""D"", ""C"", ""L"", ""X"", ""V"", ""I""]\\n        result = []\\n        for i in range(len(v)):\\n            while num >= v[i]:\\n                num -= v[i]\\n                result.append(s[i])\\n        return """".join(result)\\n```# 717. 1-bit and 2-bit Characters\\n\\n## Problem\\nWe have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).\\n\\nNow given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.\\n\\n## Solution\\n```python\\nclass Solution(object):\\n    def isOneBitCharacter(self, bits):\\n        """"""\\n        :type bits: List[int]\\n        :rtype: bool\\n        """"""\\n        n = len(bits)\\n        i = 0\\n        while i < n - 1:\\n            i += 1 + bits[i]\\n        return i == n - 1\\n```# 1051. Height Checker\\n\\n## Problem\\nStudents are asked to stand in non-decreasing order of heights for an annual photo.\\n\\nReturn the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)\\n\\n## Solution\\n```python\\nclass Solution(object):\\n    def heightChecker(self, heights):\\n        """"""\\n        :type heights: List[int]\\n        :rtype: int\\n        """"""\\n        if not heights:\\n            return 0\\n        sorted = list(heights)\\n        sorted.sort()\\n        return sum(h1!= h2 for h1, h2 in zip(heights, sorted))\\n```# 581. Shortest Subarray with Sum at Least K\\n\\n## Problem\\nReturn the length of the shortest, non-empty, contiguous subarray of A with sum at least K.\\n\\nIf there is no non-empty subarray with sum at least K, return -1.\\n\\n## Solution\\n```python\\nclass Solution(object):\\n    def shortestSubarray(self, A, K):\\n        """"""\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        """"""\\n        if len(A) == 0:\\n            return -1\\n        result = len(A) + 1\\n        sums = [0] * (len(A) + 1)"
"2","4","FAIL","0","module test;\\n\\ntypedef enum logic [0:0]\\n{\\n    A,\\n    B = 3,\\n    C\\n} test_enum;\\n\\nwire [0:0] a;\\nreg [0:0] b;\\nwire [0:0] c;\\nreg [0:0] d;\\nwire [0:0] e;\\nassign #25 e = A;\\n\\nendmodule\\nThe above code is an implementation of the above example.\\n\\nIn the above example, the enumerated types of type wire and reg are replaced with the enumerated types.\\n\\nThe type name of the enumerated type is test_enum.\\n\\nThe number of bits in the enumerated type are changed from 3 to 3.\\n\\nThe enumerated types allow multiple instances of the same type of signals to be packed into one.\\n\\n15.1.11 System Verilog\\nThe System Verilog synthesis and simulation tool is a powerful language that can be used to create and test hardware designs. It is often used to test the functionality of hardware components and is often used with the RTL synthesis and simulation tool. The System Verilog language is often used with the VCS simulator.\\n\\nSystem Verilog language is an extension of Verilog language. This means that it can be used along with Verilog. Verilog is a very low-level language, and it is used for creating hardware designs. System Verilog is a high-level language that can be used to create hardware designs. It is often used as a supplement to the Verilog language.\\n\\nThe System Verilog language is used to create and test hardware components. It is often used in conjunction with the VCS simulator.\\n\\nSystem Verilog supports all of the Verilog language features such as data types, operators, expressions, assignment statements, procedural statements, functions, and arrays.\\n\\nIt also supports all of the SystemC language features such as signals, data types, and methods.\\n\\n15.1.12 Verilog vs. System Verilog\\nVerilog language is a very low-level language that can be used for creating hardware designs. It is often used in conjunction with the RTL synthesis and simulation tool. System Verilog is a high-level language that can be used to create hardware designs. It is often used as a supplement to Verilog.\\n\\nThe System Verilog language is often used with the VCS simulator.\\n\\n15.2 Examples:\\n\\n15.2.1 Simple D Flip-Flop\\nThe following example shows how to create a simple D flip-flop.\\n\\n### Verilog Code:\\nmodule d_flipflop;\\n\\ninput clk;\\ninput d;\\noutput reg q;\\n\\nalways @ (posedge clk) begin\\n    if (d == 1) q <= 1;\\n    else if (d == 0) q <= 0;\\nend\\n\\nendmodule\\nIn the above example, the input and output signals of the D flip-flop component are defined. The input signal clk is defined to be the clock signal that is used to clock the flip-flop. The input signal d is defined to be the data signal that is used to load the data into the flip-flop. The output signal q is defined to be the output signal of the D flip-flop component.\\n\\nThe logic of the D flip-flop is implemented in the always @ (posedge clk) block. The data signal d is used to determine the value of the output signal q. If the data signal d has a value of 1, the output signal q has a value of 1. If the data signal d has a value of 0, the output signal q has a value of 0.\\n\\nThe D flip-flop is clocked with the clock signal of the input signal clk. When the clock signal of the input signal clk changes from low to high, the conditions that are specified in the always @ (posedge clk) block are checked. If the data signal of the input signal d has a"
"3","0","FAIL","0","module full_adder(i1, i2, cin, sum, cout);\\ninput i1, i2, cin;\\noutput logic sum, cout;\\nassign sum = i1 ^ i2 ^ cin;\\nassign cout = (i1 & i2) | (cin & (i1 | i2));\\nendmodule\\n### Verilog Code Tested in:\\nIcarus Verilog 11.5\\n### Testing Results:\\n\\n![1](https://github.com/Mokrusha/Computer-Architecture/blob/main/FullAdder/1.PNG)\\n\\n![2](https://github.com/Mokrusha/Computer-Architecture/blob/main/FullAdder/2.PNG)\\n\\n![3](https://github.com/Mokrusha/Computer-Architecture/blob/main/FullAdder/3.PNG)\\n\\n## Full Adder Code-2 (Binary to Decimal)\\n### Base Verilog Code:\\nmodule full_adder_dec(a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, c, x, carryout);\\ninput a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, c;\\noutput x, carryout;\\nwire x1,x2,x3,x4,x5,x6,x7,x8;\\nassign x7= a0 ^ a1 ^ a2 ^ a3 ^ a4 ^ a5 ^ b0 ^ b1 ^ b2 ^ b3 ^ b4 ^ b5 ^ c^1;\\nassign x6= (a0 & a1 & c ) | (a2 & a3 & c) | (a4 & a5 & c) | (b0 & b1 & c) | (b2 & b3 & c) | (b4 & b5 & c) | c;\\nassign x5= (a0 & a1 & a2 & a3 & b4 & b5 & c) | (a4 & a5 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & c);\\nassign x4= (a0 & a1 & a2 & a3 & a4 & b5 & b6 & c) | (a5 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & c);\\nassign x3= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & c) | (a4 & a5 & b6 & c);\\nassign x2= (a0 & a1 & a2 & a3 & a4 & a5 & b0 & b1 & b2 & b3 & b4 & b5 & c);\\nassign x1= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & b7 & c^1);\\nassign x8= (a0 & a1 & c ) | (a2 & a3 & c) | (a4 & a5 & c) | (b0 & b1 & c) | (b2 & b3 & c) | (b4 & b5 & c) | c;\\nassign x7= (a0 & a1 & a2 & a3 & b4 & b5 & c) | (a4 & a5 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & c);\\nassign x6= (a0 & a1 & a2 & a3 & a4 & b5 & b6 & c) | (a5 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & c);\\nassign x5= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & c) | (a4 & a5 & b6 & c);\\nassign x4= (a0 & a1 & a2 & a3 & a4 & a5 & b0 & b1 & b2 & b3 & b4 & b5 & c);\\nassign x3= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & b7 & c^1);\\nassign x2= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & c);\\nassign x1= (a0 & a1 & c ) | (a2 & a3 & c) | (a4 & a5 & c) | (b0 & b1 & c) | (b2 & b3 & c) | (b4 & b5 & c) | c;\\nassign x8= (a0 & a1 & c ) | (a2 & a3 & c) | (a4 & a5 & c) | (b0 & b1 & c) | (b2 & b3 & c) | (b4 & b5 & c) | c;\\nassign x7= (a0 & a1 & a2 & a3 & b4 & b5 & c) | (a4 & a5 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & c);\\nassign x6= (a0 & a1 & a2 & a3 & a4 & b5 & b6 & c) | (a5 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & c);\\nassign x5= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & c) | (a4 & a5 & b6 & c);\\nassign x4= (a0 & a1 & a2 & a3 & a4 & a5 & b0 & b1 & b2 & b3 & b4 & b5 & c);\\nassign x3= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & b7 & c^1);\\nassign x2= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & c);\\nassign x1= (a0 & c ) | (a2 & c) | (a4 & c) | (b0 & c) | (b2 & c) | (b4 & c) | c;\\nassign x8= (a0 & c ) | (a2 & c) | (a4 & c) | (b0 & c) | (b2 & c) | (b4 & c) | c;\\nassign x7= (a0 & a1 & b4 & b5 & c) | (a4 & a5 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & c);\\nassign x6= (a0 & a1 & a2 & a3 & a4 & b5 & b6 & c) | (a5 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & c);\\nassign x5= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & c) | (a4 & a5 & b6 & c);\\nassign x4= (a0 & a1 & a2 & a3 & a4 & a5 & b0 & b1 & b2 & b3 & b4 & b5 & c);\\nassign x3= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & b7 & c^1);\\nassign x2= (a0 & a1 & a2 & a3 & b0 & b1 & b2 & b3 & b4 & b5 & c);\\nassign x1= (a0 & c ) | (a2 & c) | (a4 & c) | (b0 & c) | (b2 & c) | (b4 & c) | c;\\nassign x8= (a0 & c ) | (a2 & c) | (a4 & c) | (b0 & c) | (b2 & c) | (b4 & c) | c;\\nassign x7= (a0 & a1 & b4 & b5 & c) | (a4 & a5 & b0 & b1 & b2 & b3 & b4 & b5 & b6 & c);\\nassign x6= (a0 & a1 & a2 & a3 & a"
"3","1","FAIL","0","module full_adder (I1, I2, CIN, S, COUT);\\ninput CIN, I1, I2;\\noutput logic S, COUT;\\nassign S = I1 ^ I2 ^ CIN;\\nassign COUT = (I1 & I2) | (CIN & (I1 | I2));\\nendmodule\\n### Verilog Code With Multiple Verilog Modules:\\nmodule d_counter(clk, rst, i, o, count, done);\\ninput clk, rst, i;\\noutput logic o, count, done;\\nwire clk_reg;\\nreg [8 : 0] count;\\nalways @(posedge clk) begin\\nif (rst) begin\\ncount <= 8'h00;\\nend\\nelse if (i) begin\\ncount <= count + 1'b1;\\nend\\nend\\nassign count[7] = count[8];\\nassign o = count[7];\\nassign count[7] = done? 8'b00000000 : count[7];\\nassign done = count == 8'b11111111;\\nendmodule\\nmodule full_adder(I1, I2, CIN, S, COUT);\\ninput CIN, I1, I2;\\noutput logic S, COUT;\\nassign S = I1 ^ I2 ^ CIN;\\nassign COUT = (I1 & I2) | (CIN & (I1 | I2));\\nendmodule\\nmodule d_flipflop(clk, rst, i, o, n);\\ninput clk, rst, i;\\noutput logic o, n;\\nwire clk_reg;\\nreg n;\\nalways @(posedge clk) begin\\nif (rst) begin\\nn <= 0;\\nend else if (i) begin\\nn <=!n;\\nend\\nend\\nassign o = n;\\nendmodule\\nmodule d_register(clk, rst, i, o);\\ninput clk, rst, i;\\noutput logic o;\\nwire clk_reg;\\nreg o;\\nalways @(posedge clk) begin\\nif(rst) begin\\no <= 0;\\nend\\nelse if(i) begin\\no <= i;\\nend\\nend\\nassign o = o;\\nendmodule\\nThe design:\\nmodule full_adder (I1, I2, CIN, S, COUT);\\ninput CIN, I1, I2;\\noutput logic S, COUT;\\nassign S = I1 ^ I2 ^ CIN;\\nassign COUT = (I1 & I2) | (CIN & (I1 | I2));\\nendmodule\\nmodule d_flipflop (CLK, RST, I, O, N);\\ninput CLK, RST, I;\\noutput logic O, N;\\nwire CLK_REG;\\nreg N;\\nalways @(posedge CLK) begin\\nif (RST) begin\\nN <= 0;\\nend\\nelse if (I) begin\\nN <=!N;\\nend\\nend\\nassign O = N;\\nendmodule\\nmodule d_counter(CLK, RST, I, O, CNT, DONE);\\ninput CLK, RST, I;\\noutput logic O, CNT, DONE;\\nwire CLK_REG;\\nreg [8 : 0] CNT;\\nalways @(posedge CLK) begin\\nif (RST) begin\\nCNT <= 8'h00;\\nend\\nelse if (I) begin\\nCNT <= CNT + 1'b1;\\nend\\nend\\nassign CNT[7] = CNT[8];\\nassign O = CNT[7];\\nassign CNT[7] = DONE? 8'b00000000 : CNT[7];\\nassign DONE = CNT == 8'b11111111;\\nendmodule\\nmodule d_register(CLK, RST, I, O);\\ninput CLK, RST, I;\\noutput logic O;\\nwire CLK_REG;\\nreg O;\\nalways @(posedge CLK) begin\\nif(RST) begin\\nO <= 0;\\nend\\nelse if(I) begin\\nO <= I;\\nend\\nend\\nassign O = O;\\nendmodule\\nThe output for each component:\\n\\nFull Adder:\\n\\nThe Flipflop:\\n\\nThe Counter:\\n\\nThe Register:\\n\\nThe circuit, in FPGA:\\n\\n### Verilog Code With Multiple Verilog Modules:\\nmodule d_counter(clk, rst, i, o, count, done);\\ninput clk, rst, i;\\noutput logic o, count, done;\\nwire clk_reg;\\nreg [8 : 0] count;\\nalways @(posedge clk) begin\\nif (rst) begin\\ncount <= 8'h00;\\nend\\nelse if (i) begin\\ncount <= count + 1'b1;\\nend\\nend\\nassign count[7] = count[8];\\nassign o = count[7];\\nassign count[7] = done? 8'b00000000 : count[7];\\nassign done = count == 8'b11111111;\\nendmodule\\nmodule full_adder(I1, I2, CIN, S, COUT);\\ninput CIN, I1, I2;\\noutput logic S, COUT;\\nassign S = I1 ^ I2 ^ CIN;\\nassign COUT = (I1 & I2) | (CIN & (I1 | I2));\\nendmodule\\nmodule d_flipflop(clk, rst, i, o, n);\\ninput clk, rst, i;\\noutput logic o, n;\\nwire clk_reg;\\nreg n;\\nalways @(posedge clk) begin\\nif (rst) begin\\nn <= 0;\\nend else if (i) begin\\nn <=!n;\\nend\\nend\\nassign o = n;\\nendmodule\\nmodule d_register(clk, rst, i, o);\\ninput clk, rst, i;\\noutput logic o;\\nwire clk_reg;\\nreg o;\\nalways @(posedge clk) begin\\nif(rst) begin\\no <= 0;\\nend\\nelse if(i) begin\\no <= i;\\nend\\nend\\nassign o = o;\\nendmodule\\nmodule d_counter(clk, rst, i, o, count, done);\\ninput clk, rst, i;\\noutput logic o, count, done;\\nwire clk_reg;\\nreg [8 : 0] count;\\nalways @(posedge clk) begin\\nif (rst) begin\\ncount <= 8'h00;\\nend\\nelse if (i) begin\\ncount <= count + 1'b1;\\nend\\nend\\nassign count[7] = count[8];\\nassign o = count[7];\\nassign count[7] = done? 8'b00000000 : count[7];\\nassign done = count == 8'b11111111;\\nendmodule\\nmodule full_adder(i1, i2, cin, sum, cout);\\ninput i1, i2, cin;\\noutput sum, cout;\\nassign sum = i1 ^ i2 ^ cin;\\nassign cout = (i1 & i2) | (cin & (i1 | i2));\\nendmodule\\nmodule full_adder (I1, I2, CIN, S, COUT);\\ninput CIN, I1, I2;\\noutput logic S, COUT;\\nassign S = I1 ^ I2 ^ CIN;\\nassign COUT = (I1 & I2) | (CIN & (I1 | I2));\\nendmodule\\nmodule d_flipflop (CLK, RST, I, O, N);\\ninput CLK, RST, I;\\noutput logic O, N;\\nwire CLK_REG;\\nreg N;\\nalways @(posedge CLK) begin\\nif (RST) begin\\nN <= 0;\\nend\\nelse if (I) begin\\nN <=!N;\\nend\\nend\\nassign O = N;\\nendmodule\\nmodule d_register(CLK, RST, I, O);\\ninput CLK, RST, I;\\noutput logic O;\\nwire CLK_REG;\\nreg O;\\nalways @(posedge CLK) begin\\nif(RST) begin\\nO <= 0;\\nend\\nelse if(I) begin\\nO <= I;\\nend\\nend\\nassign O = O;\\nendmodule\\nmodule d_counter(CLK, RST, I, O, CNT, DONE);\\ninput CLK, RST, I;\\noutput logic O, CNT, DONE;\\nwire CLK_REG;\\nreg [8 : 0] CNT;\\nalways @(posedge CLK) begin\\nif (RST) begin\\nCNT <= 8'h00;\\nend\\nelse if (I) begin\\nCNT <= CNT + 1'b1;\\nend\\nend\\nassign CNT[7] = CNT[8];\\nassign O = CNT[7];\\nassign CNT[7] ="
"3","2","FAIL","0","module full_adder(i1, i2, cin, sum, cout);\\ninput i1, i2, cin;\\noutput sum, cout;\\nassign sum = i1 ^ i2 ^ cin;\\nassign cout = (i1 & i2) | (cin & (i1 | i2));\\nendmodule\\n### Input:\\nInput file full_adder_v.dat contains 2^13-1=8191 combinations of input signals.\\n### Output:\\nThe output file full_adder_v.log contains the value of the output ""cout"" for each input combination.\\n### Testbench Code:\\nmodule test_full_adder(i1, i2, cin, sum, cout);\\ninput i1, i2, cin;\\noutput sum, cout;\\nreg sum, cout;\\ninitial begin\\n$readmemb(""full_adder.dat"", {i1, i2, cin, sum, cout});$dumpfile(""full_adder_v.log"");\\n$dumpvars(0, test_full_adder); forever begin#13i1 = 1'b0; #13i2 = 1'b0; #13cin = 1'b0; #13cout = 1'b0; #13wait(); #13i1 = 1'b0; #13i2 = 1'b0; #13cin = 1'b1; #13cout = 1'b0; #13wait(); #13i1 = 1'b0; #13i2 = 1'b1; #13cin = 1'b0; #13cout = 1'b1; #13wait(); #13i1 = 1'b0; #13i2 = 1'b1; #13cin = 1'b1; #13cout = 1'b1; #13wait(); #13i1 = 1'b1; #13i2 = 1'b0; #13cin = 1'b0; #13cout = 1'b1; #13wait(); #13i1 = 1'b1; #13i2 = 1'b0; #13cin = 1'b1; #13cout = 1'b1; #13wait(); #13i1 = 1'b1; #13i2 = 1'b1; #13cin = 1'b0; #13cout = 1'b0; #13wait(); #13i1 = 1'b1; #13i2 = 1'b1; #13cin = 1'b1; #13cout = 1'b1; #13wait(); #13end endmodule\\n\\nReferences\\n----------\\n*  and. **Digital Design Fundamentals.** Prentice-Hall, 2003.\\n* Xilinx. **Vivado Design Suite User Guide.** August 2016, Version 32.2.0.\\n*. **Elements of Programming.** Prentice-Hall, 1985. This book was the inspiration for this lab./lab2/lab2-c/lab2-c.md\\nLab 2-c\\n===================\\n\\nIntroduction\\n-----------\\n### Goal:\\nThis lab will teach you how to create a design flow using Vivado, create a design using Verilog, and use the simulation to verify the functional correctness of the design.\\n### Learning Objectives:\\n* Vivado HLS\\n* Verilog\\n* SystemVerilog\\n* Vivado simulation\\n\\nInstructions\\n-----------\\n### Setup:\\n* Install Vivado HLS\\n\\n### Design Requirements:\\nThe design of this lab will be the same as the previous lab. Please refer to the previous lab for details.\\n\\n### Vivado HLS Simulation:\\nThis lab will be using the same design used in the previous lab, except this lab will be using Vivado HLS simulation tools to run a simulation and then create an executable.\\n\\n### Simulation:\\n* Use the simulation tools to create an executable.\\n* Run the executable\\n* Open the ILA and use the ILA to view the simulation results.\\n* Examine the ILA and the simulation results.\\n\\n\\nRequired Resources:\\n-------------------\\n* Vivado HLS\\n* A 7-Series FPGA board\\n* An ECP5 UltraScale FPGA\\n\\n### Verilog Source Code:\\n```\\nmodule full_adder(i1, i2, cin, sum, cout);\\n    input i1, i2, cin;\\n    output sum, cout;\\n    assign sum = i1 ^ i2 ^ cin;\\n    assign cout = (i1 & i2) | (cin & (i1 | i2));\\nendmodule\\n```\\n\\n### Design File:\\n```\\nfull_adder.v\\n```\\n\\n### Simulation Source Code:\\n```\\n`timescale 1ns/1ps\\n\\nmodule test_full_adder(i1, i2, cin, sum, cout);\\n    input i1, i2, cin;\\n    output sum, cout;\\n    reg sum, cout;\\n    initial begin\\n        `$readmemb(""full_adder.dat"", {i1, i2, cin, sum, cout});\\n        `$dumpvars(0, test_full_adder);\\n        forever begin#13i1 = 1'b0; #13i2 = 1'b0; #13cin = 1'b0; #13cout = 1'b0; #13wait(); #13i1 = 1'b0; #13i2 = 1'b0; #13cin = 1'b1; #13cout = 1'b0; #13wait(); #13i1 = 1'b0; #13i2 = 1'b1; #13cin = 1'b0; #13cout = 1'b1; #13wait(); #13i1 = 1'b0; #13i2 = 1'b1; #13cin = 1'b1; #13cout = 1'b1; #13wait(); #13i1 = 1'b1; #13i2 = 1'b0; #13cin = 1'b0; #13cout = 1'b1; #13wait(); #13i1 = 1'b1; #13i2 = 1'b0; #13cin = 1'b1; #13cout = 1'b1; #13wait(); #13i1 = 1'b1; #13i2 = 1'b1; #13cin = 1'b0; #13cout = 1'b0; #13wait(); #13i1 = 1'b1; #13i2 = 1'b1; #13cin = 1'b1; #13cout = 1'b1; #13wait(); #13end\\n    endmodule\\n```\\n\\n### Simulation File:\\n```\\ntest_full_adder.sv\\n```\\n\\n### Simulation File:\\n```\\nfull_adder.dat\\n```\\n\\n### Executable File:\\n```\\ntop.exe\\n```\\n\\nReferences\\n----------\\n*  and. **Digital Design Fundamentals.** Prentice-Hall, 2003.\\n* Xilinx. **Vivado Design Suite User Guide.** August 2016, Version 32.2.0.\\n*. **Elements of Programming.** Prentice-Hall, 1985. This book was the inspiration for this lab.\\n*. **HLS C/C++ Integrated Development Environment.** December 2014, Version 2014.1.0.\\n*. **Intel FPGA Programmer's Reference.** February 2015, Version 14.1.\\n* Wikipedia contributors. (2017, June 7). CMOS inverter. In Wikipedia, The Free Encyclopedia. Retrieved 20:47, June 8, 2017, from https://en.wikipedia.org/w/index.php?title=CMOS_inverter&oldid=783393079\\n* Wikibooks contributors. (2017, June 7). Digital Logic. In Wikibooks, The Free ticle/details/27817639Book Project. Retrieved 20:47, June 8, 2017, from https://en.wikibooks.org/wiki/Digital_Logic\\n* HDL Coder. (2017, June 7). Tutorial: Verilog Basics. In"
"3","3","FAIL","0","module adder(A, B, Cin, Sum, Cout);\\ninput [3:0] A, B;\\ninput Cin;\\noutput [3:0] Sum;\\noutput Cout;\\nfull_adder fa_A0(.i1(A[0]),.i2(B[0]),.cin(Cin),.sum(Sum[0]),.cout(Cout[0]) );\\nfull_adder fa_A1(.i1(A[1]),.i2(B[1]),.cin(Cout[0]),.sum(Sum[1]),.cout(Cout[1]) );\\nfull_adder fa_A2(.i1(A[2]),.i2(B[2]),.cin(Cout[1]),.sum(Sum[2]),.cout(Cout[2]) );\\nfull_adder fa_A3(.i1(A[3]),.i2(B[3]),.cin(Cout[2]),.sum(Sum[3]),.cout(Cout[3]) );\\nendmodule\\n### Modified testbench code:\\nmodule adder_testbench();\\n// input/output wires\\nreg [3:0] A, B, Sum;\\nreg Cin;\\nreg [3:0] Cout;\\n\\n// module instances\\nadder adder1(.A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout));\\ninitial begin\\nA = 4'b0000;\\nB = 4'b0000;\\nCin = 0;\\nend\\n\\ninitial begin\\nA = 4'b1111;\\nB = 4'b1111;\\nCin = 0;\\nend\\n\\ninitial begin\\nA = 4'b0000;\\nB = 4'b1111;\\nCin = 1;\\nend\\n\\ninitial begin\\nA = 4'b1010;\\nB = 4'b0011;\\nCin = 1;\\nend\\n\\ninitial begin\\nA = 4'b1101;\\nB = 4'b1011;\\nCin = 1;\\nend\\n\\ninitial begin\\nA = 4'b0011;\\nB = 4'b0101;\\nCin = 1;\\nend\\n\\ninitial begin\\nA = 4'b0111;\\nB = 4'b1000;\\nCin = 1;\\nend\\n\\ninitial begin\\nA = 4'b1001;\\nB = 4'b1110;\\nCin = 1;\\nend\\n\\ninitial begin\\nA = 4'b1110;\\nB = 4'b1101;\\nCin = 1;\\nend\\n\\ninitial begin\\nA = 4'b1100;\\nB = 4'b0110;\\nCin = 1;\\nend\\n\\nalways begin\\nassert(Sum == 4'b0000);\\nassert(Cout == 0);\\nassert(A == 4'b1111);\\nassert(B == 4'b1111);\\nassert(Cin == 0);\\nassert(Sum == 4'b1111);\\nassert(Cout == 1);\\nassert(A == 4'b0000);\\nassert(B == 4'b1111);\\nassert(Cin == 1);\\nassert(Sum == 4'b1111);\\nassert(Cout == 1);\\nend\\ninitial begin\\nA = 4'b1010;\\nB = 4'b0011;\\nCin = 1;\\nend\\n\\nalways begin\\nassert(Sum == 4'b0011);\\nassert(Cout == 0);\\nassert(A == 4'b1010);\\nassert(B == 4'b0011);\\nassert(Cin == 1);\\nassert(Sum == 4'b1101);\\nassert(Cout == 1);\\nend\\ninitial begin\\nA = 4'b1101;\\nB = 4'b1011;\\nCin = 1;\\nend\\n\\nalways begin\\nassert(Sum == 4'b0110);\\nassert(Cout == 0);\\nassert(A == 4'b1101);\\nassert(B == 4'b1011);\\nassert(Cin == 1);\\nassert(Sum == 4'b1010);\\nassert(Cout == 1);\\nend\\ninitial begin\\nA = 4'b0011;\\nB = 4'b0101;\\nCin = 1;\\nend\\n\\nalways begin\\nassert(Sum == 4'b0110);\\nassert(Cout == 0);\\nassert(A == 4'b0011);\\nassert(B == 4'b0101);\\nassert(Cin == 1);\\nassert(Sum == 4'b1100);\\nassert(Cout == 1);\\nend\\ninitial begin\\nA = 4'b0111;\\nB = 4'b1000;\\nCin = 1;\\nend\\n\\nalways begin\\nassert(Sum == 4'b0000);\\nassert(Cout == 0);\\nassert(A == 4'b0111);\\nassert(B == 4'b1000);\\nassert(Cin == 1);\\nassert(Sum == 4'b1110);\\nassert(Cout == 1);\\nend\\ninitial begin\\nA = 4'b1001;\\nB = 4'b1110;\\nCin = 1;\\nend\\n\\nalways begin\\nassert(Sum == 4'b0100);\\nassert(Cout == 0);\\nassert(A == 4'b1001);\\nassert(B == 4'b1110);\\nassert(Cin == 1);\\nassert(Sum == 4'b1101);\\nassert(Cout == 1);\\nend\\ninitial begin"
"3","4","FAIL","0","module full_adder_3_inputs(i1, i2, cin, i3, sum, cout);\\ninput i1, i2, cin, i3;\\noutput logic[1:0] sum, cout;\\nassign sum = i1 ^ i2 ^ cin ^ i3;\\nassign cout = (i1 & i2 & i3) | (cin & (i1 | i2 | i3));\\nendmodule\\n### Output:\\n![FullAdder3Inputs](images/full_adder_3_inputs.PNG)\\n### Output Simulation:\\n![FullAdder3Inputs_Simulation](images/full_adder_3_inputs_simulation.PNG)\\n\\n\\n## Multiplexor\\n### Base Verilog Code:\\nmodule multiplexor(x, sel, y);\\ninput x, sel;\\noutput y;\\nassign y = x;\\nassign y = ~sel & (sel & x) | (~sel & x);\\nendmodule\\n### Output:\\n![Multiplexor](images/multiplexor.PNG)\\n### Output Simulation:\\n![Multiplexor_Simulation](images/multiplexor_simulation.PNG)\\n\\n\\n## Multiplexer\\n### Base Verilog Code:\\nmodule multiplexer(i0,i1,sel,out);\\ninput i0,i1;\\ninput sel;\\noutput out;\\nassign out = sel? i1 : i0;\\nendmodule\\n### Output:\\n![Multiplexer](images/multiplexer.PNG)\\n### Output Simulation:\\n![Multiplexer_Simulation](images/multiplexer_simulation.PNG)\\n\\n\\n## Encoder\\n### Base Verilog Code:\\nmodule encoder(in, out);\\ninput in;\\noutput [3:0] out;\\nassign out[3:0] = in;\\nendmodule\\n### Output:\\n![Encoder](images/encoder.PNG)\\n### Output Simulation:\\n![Encoder_Simulation](images/encoder_simulation.PNG)\\n\\n\\n## Decoder\\n### Base Verilog Code:\\nmodule decoder(in, out);\\ninput [3:0] in;\\noutput out;\\nassign out = in;\\nendmodule\\n### Output:\\n![Decoder](images/decoder.PNG)\\n### Output Simulation:\\n![Decoder_Simulation](images/decoder_simulation.PNG)\\n\\n\\n## Summing Module\\n### Base Verilog Code:\\nmodule summing_module(clk, a1, a2, a3, sum1, sum2, sum3, sum4, c1, c2, c3, c4);\\ninput clk;\\ninput [1:0] a1, a2, a3;\\noutput [1:0] sum1, sum2, sum3, sum4;\\noutput c1, c2, c3, c4;\\nwire sum1_in, sum2_in, sum3_in, sum4_in;\\nwire c1_in, c2_in, c3_in, c4_in;\\nfull_adder sum1_adder(a1[0], a2[0], a3[0], sum1[0], sum1_in[0]);\\nfull_adder sum2_adder(a1[1], a2[1], a3[1], sum2[1], sum2_in[0]);\\nfull_adder sum3_adder(a1[2], a2[2], a3[2], sum3[2], sum3_in[0]);\\nfull_adder sum4_adder(a1[3], a2[3], a3[3], sum4[3], sum4_in[0]);\\nfull_adder c1_adder(sum1_in[0], sum2_in[0], sum3_in[0], c1_in[0], c1[0]);\\nfull_adder c2_adder(sum1_in[1], sum2_in[1], sum3_in[1], c2_in[0], c2[0]);\\nfull_adder c3_adder(sum1_in[1], sum2_in[1], sum3_in[1], c3_in[0], c3[0]);\\nfull_adder c4_adder(sum1_in[1], sum2_in[1], sum3_in[1], c4_in[0], c4[0]);\\nendmodule\\n### Output:\\n![SummingModule](images/summing_module.PNG)\\n### Output Simulation:\\n![SummingModule_Simulation](images/summing_module_simulation.PNG)\\n\\n\\n## Shift Register\\n### Base Verilog Code:\\nmodule shift_register(clk, load, data, out);\\ninput clk;\\ninput load;\\ninput [7:0] data;\\noutput out;\\nreg [7:0] reg = 8'h0;\\nalways @(posedge clk or negedge load) begin\\nif (load == 1'b1)\\nreg <= data;\\nend\\nendmodule\\n### Output:\\n![ShiftRegister](images/shift_register.PNG)\\n### Output Simulation:\\n![ShiftRegister_Simulation](images/shift_register_simulation.PNG)\\n/README.md\\n# VHDL-Projects\\n\\n## Verilog Topics:\\n\\n### Data Type:\\n![Data Types](images/data_types.PNG)\\n\\n### Input, Output and Parameters:\\n![I/O and Parameters](images/io_and_parameters.PNG)\\n\\n### Multiple Inputs and Outputs:\\n![Multiple Inputs and Outputs](images/multiple_inputs_and_outputs.PNG)\\n\\n### Array:\\n![Array](images/array.PNG)\\n\\n### Combinational Circuit:\\n![CombinationalCircuit](images/combinational_circuit.PNG)\\n\\n### Synchronous Circuit:\\n![SynchronousCircuit](images/synchronous_circuit.PNG)\\n\\n### Combinational Logic:\\n![CombinationalLogic](images"
"4","0","FAIL","0","```\\n### Original Verilog Code:\\nmodule testbench ();\\nreg a, b;\\nb <= a;\\n### Base Verilog Code:\\nmodule testbench ();\\nreg a, b;\\nb <= a;\\n### Variation Instruction:\\nReplace the data construct with a struct containing a rand member to test"
"4","1","FAIL","0","module testbench ();\\ngenerate\\ngenerate struct test_struct (\\nrand int rand_1;\\n);\\nendgenerate\\nprocess data;\\nendprocess\\nendmodule\\n### Testbench Output:\\ntestbench.cpp:5:35: error: testbench is not declared in this scope\\nrand int rand_1;\\n^\\ntestbench.cpp:6:5: error: struct does not name a type\\nstruct test_struct (\\n^\\ntestbench.cpp:6:7: error: rand_1 was not declared in this scope\\nrand_1;\\n^\\ntestbench.cpp:6:9: error: rand was not declared in this scope\\nint rand_1;\\n^\\ntestbench.cpp:6:12: error: expected ; before rand_1\\nint rand_1;\\n^\\ntestbench.cpp:6:14: error: expected ; before ( token\\nint rand_1;\\n^\\ntestbench.cpp: At global scope:\\ntestbench.cpp:6:14: error: expected primary-expression before ) token\\nint rand_1;\\n^\\ntestbench.cpp:6:14: error: expected ) before ; token\\nint rand_1;\\n^\\ntestbench.cpp:6:14: error: expected ; before ) token\\nint rand_1;\\n^\\ntestbench.cpp:6:26: error: expected ) before ) token\\nint rand_1;\\n^\\ntestbench.cpp: At global scope:\\ntestbench.cpp:6:26: error: expected ) before ) token\\nint rand_1;\\n^\\ntestbench.cpp:6:26: error: expected primary-expression before ) token\\nint rand_1;\\n^\\ntestbench.cpp:6:42: error: expected ; before ( token\\nint rand_1;\\n^\\ntestbench.cpp:6:43: error: expected primary-expression before ; token\\nint rand_1;\\n^\\ntestbench.cpp:6:43: error: expected ; before ) token\\nint rand_1;\\n^\\ntestbench.cpp:6:43: error: expected ; before ( token\\nint rand_1;\\n^\\ntestbench.cpp:6:68: error: expected primary-expression before ; token\\nint rand_1;\\n^\\ntestbench.cpp:6:68: error: expected ; before ) token\\nint rand_1;\\n^\\n21 errors generated.\\n### Verilog Test Output:\\nVerilog syntax check failed\\n\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 160 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]: Variable 64 found, but not used\\n[Warning 191]:"
"4","2","FAIL","0","module testbench ();\\ngenerate var_data;\\nprocess data;\\nendmodule\\n\\n## Sources\\nhttps://www.edaboard.com/discourse-topic/verilog-random-number-in-struct-or-array-87944.html\\n\\n\\n## TODOs\\n\\n/docs/_posts/2020-08-11-ECE453-Lecture6_11-8-2020.md\\n---\\ntitle: ""ECE453-Lecutre 6 : 11-8-2020""\\nauthor: """"\\ndate: ""11/8/2020""\\n---\\n\\n## Verilog Testbench Overview\\n\\nVerilog testbench is a set of instructions that helps with testing the functions of a complex Verilog module. It's a good idea to add a testbench for every module. It is a good idea to document your testbench along with the module, and then when you come back to the testbench, your code will be more readable.\\n\\nA testbench is a module that is responsible for generating a stimulus, running it through the system under test (SUT), and verifying the expected outputs.\\n\\n## Code Example of Equation for Area of a Rectangle\\n\\n```verilog\\nmodule area_rect ();\\n\\n  //Declare all variables\\n  reg [31:0] rect_width;\\n  reg [31:0] rect_height;\\n  reg [31:0] rect_area;\\n\\n  // Define the inputs and the outputs of this module\\n  input wire [31:0] width;\\n  output wire [31:0] area;\\n\\n  // Create a process called calc_area that calculates the area and stores it in rect_area\\n  always @* begin\\n    rect_area <= width * height;\\n  end\\n\\n  // Create a process called store that takes the output of calc_area and stores it in area\\n  always @* begin\\n    area <= rect_area;\\n  end\\n\\n  // Instantiate the process\\n  always @* begin\\n    calc_area;\\n    store;\\n  end\\nendmodule\\n```\\n\\n## Testbench Example\\n```verilog\\nmodule area_rect_tb;\\n\\n  // Define all module inputs/outputs\\n  reg [31:0] width;\\n _width;\\n    assign area = rect_area;\\n  end\\nendmodule\\n```\\n\\n\\n## Simulating Verilog Testbench\\n\\n- When writing a testbench, it is good practice to make sure that the testbench does not affect the behavior of the module under test.\\n- To simulate a testbench, first compile the module without the testbench. Then, place the testbench module in between the module under test and the testbench as shown below.\\n```verilog\\nmodule testbench;\\n	// Declare all modules to be tested\\n	module module_under_test;\\n		// Testbench module\\n		module testbench;\\n			// Instantiate the module under test\\n			module module_under_test;\\n			// Instantiate the testbench\\n			module testbench;\\n		endmodule\\n	endmodule\\nendmodule\\n\\n\\n\\n```\\n\\n\\n## TODOs\\n\\n reg [31:0] height;\\n  reg [31:0] area;\\n\\n  // Define testbench inputs\\n  initial begin\\n    width <= 5;\\n    height <= 4;\\n  end\\n\\n  // Instantiate the area_rect module\\n  area_rect area_rect_top;\\n\\n  // Define testbench outputs\\n  initial begin\\n    area <= area_rect_top.area; // Read area from module\\n  end\\nendmodule\\n```\\n\\n## Testbench Example\\n```verilog\\nmodule area_rect_tb;\\n\\n  // Define all module inputs/outputs\\n  reg [31:0] width;\\n  reg [31:0] height;\\n  wire [31:0] area;\\n\\n  // Define testbench inputs\\n  initial begin\\n    width <= 5;\\n    height <= 4;\\n  end\\n\\n  // Instantiate the area_rect module\\n  area_rect area_rect_top;\\n\\n  // Define testbench outputs\\n  initial begin\\n    area <= area_rect_top.area; // Read area from module\\n  end\\nendmodule\\n```\\n\\n## Testbench Example\\n```verilog\\nmodule area_rect_tb;\\n  // Define all module inputs/outputs\\n  reg [31:0] width;\\n  reg [31:0] height;\\n  wire [31:0] area;\\n\\n  // Instantiate the area_rect module\\n  area_rect area_rect_top;\\n\\n  // Define testbench inputs\\n  initial begin\\n    width <= 5;\\n    height <= 4;\\n  end\\n\\n  // Define testbench outputs\\n  initial begin\\n    area <= area_rect_top.area; // Read area from module\\n  end\\nendmodule\\n```\\n\\n## Testbench Example (With process)\\n```verilog\\nmodule area_rect_tb;\\n\\n  // Define all module inputs/outputs\\n  reg [31:0] width;\\n  reg [31:0] height;\\n  wire [31:0] area;\\n\\n  // Instantiate the area_rect module\\n  area_rect area_rect_top;\\n\\n  // Define testbench inputs\\n  initial begin\\n    width <= 5;\\n    height <= 4;\\n  end\\n\\n  // Define testbench outputs\\n  initial begin\\n    area <= area_rect_top.area; // Read area from module\\n  end\\n\\n  // Define a process called test that verifies the results\\n  always begin\\n    if (area_rect_top.rect_area!= width * height) begin\\n      $display(""Area should be %d, actual is %d"", width * height, area);\\n      $finish;\\n    end\\n  end\\nendmodule\\n```\\n\\n## Other Testbench Examples\\n\\n- Input and output can be specified with in and out or input and output.\\n- A testbench consists of an initial block that sets testbench inputs and then connects outputs from the module under test to the testbench outputs.\\n- The testbench usually includes a process called test that verifies the behavior of the module under test.\\n- The testbench usually consists of multiple processes so that it can be more readable and modular.\\n\\n## Testbench Example\\n```verilog\\nmodule area_rect_tb;\\n\\n  // Define all module inputs/outputs\\n  reg [31:0] width;\\n  reg [31:0] height;\\n  wire [31:0] area;\\n\\n  // Instantiate the area_rect module\\n  area_rect area_rect_top;\\n\\n  // Define testbench inputs\\n  initial begin\\n    width <= 5;\\n    height <= 4;\\n  end\\n\\n  // Define the testbench outputs\\n  initial begin\\n    area <= area_rect_top.area; // Read area from module\\n  end\\n\\n  // Define a process called test that verifies the results\\n  always begin\\n    if (area_rect_top.rect_area!= width * height) begin\\n      $display(""Area should be %d, actual is %d"", width * height, area);\\n      $finish;\\n    end\\n  end\\nendmodule\\n```\\n\\n## Testbench Example\\n```verilog\\nmodule area_rect_tb;\\n\\n  // Define all module inputs/outputs\\n  reg [31:0] width;\\n  reg [31:0] height;\\n  wire [31:0] area;\\n\\n  // Instantiate the area_rect module\\n  area_rect area_rect_top;\\n\\n  // Define testbench inputs\\n  initial begin\\n    width <= 5;\\n    height <= 4;\\n  end\\n\\n  // Define the testbench outputs\\n  initial begin\\n    area <= area_rect_top.area; // Read area from module\\n  end\\n\\n  // Define a process called test that verifies the results\\n  always begin\\n    if (area_rect_top.rect_area!= width * height) begin\\n      $display(""Area should be %d, actual is %d"", width * height, area);\\n      $finish;\\n    end\\n  end\\n\\n  // Define a process called stim that stimulates the test\\n  always begin\\n    $display(""Width: %d Height: %d"", width, height);\\n    area_rect_top.rect/docs/_posts/2020-09-30-ECE453-Lab6_30-9-2020.md\\n---\\ntitle: ""ECE453-Lab 6 : 30-9-2020""\\nauthor: """"\\ndate: ""30/9/2020""\\n---\\n\\n## Design Example\\n\\n![Design Example](/assets/img/lab6/design_example.JPG)\\n<br>\\n\\n## Task 1: Creating the Verilog Design\\n\\n```verilog\\nmodule alu_tb;\\n  	reg [3:0] a;\\n  	reg [3:0] b;\\n  	reg [4:0] r;\\n\\n  	wire [3:0] a_out;\\n  	wire [3:0] b_out;\\n  	wire [4:0] r_out;\\n  	wire [4:0] control_out;\\n  	wire [3:0] result;\\n\\n  	always @(a or b) begin\\n  		a_out <= a;\\n  		b_out <= b;\\n  	end\\n\\n  	reg [1:0] control;\\n  	always begin\\n  		control <= 2'b10;\\n  	end\\n\\n  	alu my_alu (\\n  	  .a(a_out),\\n  	  .b"
"4","3","FAIL","0","#module testbench ();\\n#generate data;\\n#process data;\\n#endmodule\\n#\\n```\\n\\n* The test bench is generated from the top module from which the data will be extracted.\\n\\n## Test Case Generation\\n\\n### Command:\\n```\\n./make_test_cases.sh <Test bench file> <number of test cases>\\n```\\n\\n### Example:\\n```\\n./make_test_cases.sh testbench 10\\n```\\n\\n### Variation:\\n\\nThe test case generation is based on the following assumptions:\\n\\n* Each function input is used once.\\n* The test cases are generated randomly and uniformly.\\n\\n## Test Bench Generation\\n\\n### Command:\\n```\\n./make_test_bench.sh <Test bench file> <Test case file> <number of test cases>\\n```\\n\\n### Example:\\n```\\n./make_test_bench.sh testbench testcases 10\\n```\\n\\n### Variation:\\n\\nThe test bench is generated from the top module from which the data will be extracted.\\n\\n## Test Case and Test Bench Correlation\\n\\n### Command:\\n```\\n./correlate.sh <Test bench file> <Test case file> <number of test cases>\\n```\\n\\n### Example:\\n```\\n./correlate.sh testbench testcases 10\\n```\\n\\n### Variation:\\n\\nThe test bench and test case files must be generated using the same number of test cases.\\n\\n* The first parameter is the test bench file.\\n* The second parameter is the test case file.\\n* The third parameter is the number of test cases.\\n\\n## Run Test Bench\\n\\n### Command:\\n```\\n./run_test_bench.sh <Test bench file>\\n```\\n\\n### Example:\\n```\\n./run_test_bench.sh testbench\\n```\\n\\n### Variation:\\n\\nThe test bench file must be used as the test bench.\\n\\n## Run Test Case\\n\\n### Command:\\n```\\n./run_test_case.sh <Test case file> <number of test cases>\\n```\\n\\n### Example:\\n```\\n./run_test_case.sh testcases 10\\n```\\n\\n### Variation:\\n\\nThe test case must be run with the number of test cases specified as the third parameter.\\n\\n* The first parameter is the test case file.\\n* The second parameter is the number of test cases.\\n\\n## Test Case Correlation\\n\\n### Command:\\n```\\n./correlation.sh <Test case file>\\n```\\n\\n### Example:\\n```\\n./correlation.sh testcases\\n```\\n\\n### Variation:\\n\\nThe test case file must be used as the test case.\\n\\n## Run Test Bench and Test Case\\n\\n### Command:\\n```\\n./run.sh <Test bench file> <Test case file>\\n```\\n\\n### Example:\\n```\\n./run.sh testbench testcase\\n```\\n\\n### Variation:\\n\\nThe test bench and test case must be used as the test bench and test case.\\n/run.sh\\n#!/bin/bash\\n\\n#./run.sh <Test bench file> <Test case file>\\n\\n./run_test_bench.sh $1\\n./run_test_case.sh $2"
"4","4","FAIL","0","module testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n\\n# 4. Verification\\n\\nThe design and implementation of the variation 3.2.1 to the design of the variation 3.2.4 are performed only on the base verilog code and are as follows:\\n\\n## 4.1.1 Design of Variation 3.2.1\\n\\n### Base Verilog Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n### Variation Instruction:\\nReplace the data construct with a rand member in a data structure to test randomization inside a structure.\\n\\n### Variation Modified Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n\\n## 4.1.2 Design of Variation 3.2.2\\n\\n### Base Verilog Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n### Variation Instruction:\\nReplace the data construct with a rand member in a data structure to test randomization inside a structure.\\n\\n### Variation Modified Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n\\n## 4.1.3 Design of Variation 3.2.3\\n\\n### Base Verilog Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n### Variation Instruction:\\nReplace the data construct with a struct containing a rand member to test randomization inside a structure.\\n\\n### Variation Modified Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n\\n## 4.1.4 Design of Variation 3.2.4\\n\\n### Base Verilog Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n### Variation Instruction:\\nReplace the data construct with a struct containing a rand member to test randomization inside a structure.\\n\\n### Variation Modified Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n\\n## 4.2.1 Design of Variation 3.2.1\\n\\n### Base Verilog Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n### Variation Instruction:\\nReplace the data construct with a rand member in a data structure to test randomization inside a structure.\\n\\n### Variation Modified Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n\\n## 4.2.2 Design of Variation 3.2.2\\n\\n### Base Verilog Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n### Variation Instruction:\\nReplace the data construct with a rand member in a data structure to test randomization inside a structure.\\n\\n### Variation Modified Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n\\n## 4.2.3 Design of Variation 3.2.3\\n\\n### Base Verilog Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n### Variation Instruction:\\nReplace the data construct with a struct containing a rand member to test randomization inside a structure.\\n\\n### Variation Modified Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n\\n## 4.2.4 Design of Variation 3.2.4\\n\\n### Base Verilog Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n### Variation Instruction:\\nReplace the data construct with a struct containing a rand member to test randomization inside a structure.\\n\\n### Variation Modified Code:\\nmodule testbench ();\\ngenerate data;\\nprocess data;\\nendmodule\\n\\n# 5. Summary\\n\\nThis paper aims to demonstrate the usage of a testbench to test randomization inside a structure. The process of the modification of the base verilog code to the variation is performed by generating a set of base verilog codes with the variation in each file and then performing the verification on these variations. The results are presented in Tables 5.1 and 5.2, the first table summarizes the results obtained for the variations of each testbench, and the second table summarizes the results obtained for the set of variations performed.\\n\\n# 6. Conclusion\\n\\nThis paper presented a testbench to test randomization inside a structure. The testbench was implemented for the base verilog code, and the design of the variations were also performed. The results were presented in tables 6.1 and 6.2. The results obtained were in line with the expectations, in that the randomization within the structure was not tested, therefore, it makes sense that the randomization was not tested. The results also match the expectations, since the variations were performed in the testbench, if the randomization was performed inside the module, the testbench would fail, since randomization was not implemented inside the testbench.\\n\\n# 7. References\\n\\n[1], Verilog and VHDL,  & Sons, 2012.\\n\\n# 8. Appendix\\n\\nThe code that was used to generate the set of testbench code variations is presented in the appendix.\\n\\n## 8.1. Generate Set of Testbench Variations\\n\\nThis code generates a set of variations for a file that has the same filename with the.v extension.\\n\\n### Usage:\\n\\n$python 8_set_of_testbench_variations.py <filename> ### Code: import sys from string import Template def remove_ext(filename): return filename[:-2] def replace_ext(filename, new_ext): return filename[:-2] + new_ext  def generate_variations(filename): templates = [] filename_without_ext = remove_ext(filename) with open(filename_without_ext + "".v"", ""r"") as f: data = f.read() for i in range(1, len(data) + 1): for j in range(i+1, len(data) + 1): templates.append((data[:i] + ""$1, "" + data[j:], (""testbench_"" + filename_without_ext + ""_data_"" + str(i) + ""_"" + str(j) + "".v"", """", templates)))\\n\\n\\n# Table 1.\\n\\n## 5.1. Results of Base Verilog Code\\n\\nBase Verilog Code\\n\\n| Testbench | Pass/Fail |\\n| --- | --- |\\n| testbench_basic_operations.v | 2 |\\n| testbench_basic_operations_data_1_4.v | 0 |\\n| testbench_basic_operations_data_2_5.v | 0 |\\n| testbench_basic_operations_data_3_6.v | 0 |\\n| testbench_basic_operation_data_1_2.v | 2 |\\n\\n# Table 2.\\n\\n## 5.2. Results of Variation 1\\n\\nVariation 1\\n\\n| Testbench | Pass/Fail |\\n| --- | --- |\\n| testbench_basic_operations.v | 2 |\\n| testbench_basic_operations_data_1_4.v | 0 |\\n| testbench_basic_operations_data_2_5.v | 0 |\\n| testbench_basic_operations_data_3_6.v | 0 |\\n| testbench_basic_operation_data_1_2.v | 2 |\\n\\n# Table 3.\\n\\n## 5.3. Results of Variation 2\\n\\nVariation 2\\n\\n| Testbench | Pass/Fail |\\n| --- | --- |\\n| testbench_basic_operations.v | 2 |\\n| testbench_basic_operations_data_1_4.v | 0 |\\n| testbench_basic_operations_data_2_5.v | 0 |\\n| testbench_basic_operations_data_3_6.v | 0 |\\n| testbench_basic_operation_data_1_2.v | 2 |\\n\\n# Table 4.\\n\\n## 5.4. Results of Variation 3\\n\\nVariation 3\\n\\n| Testbench | Pass/Fail |\\n| --- | --- |\\n| testbench_basic_operations.v | 2 |\\n| testbench_basic_operations_data_1_4.v | 2 |\\n| testbench_basic_operations_data_2_5.v | 0"
"5","0","FAIL","0","module tst_dff_pbeh();\\n  logic di,clk; logic [1:0]do;\\n  dff_p d1(do,di,clk); // Instantiate DFF with path delay\\n  initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop\\n  always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)\\n  always #5 di=~di; // Toggle data\\n  initial $monitor($time,""clk=%b, di=%b, do=%b"",clk,di,do);\\nendmodule\\n### Compile:\\n```\\ncd verilog\\n>iverilog -o tst_dff_pbeh tst_dff_pbeh.v\\n>vvp tst_dff_pbeh\\n```\\n##### Simulation:\\n```\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=1 do=1\\nclk=1 di=1 do=0\\nclk=0 di=1 do=1\\nclk=1 di=1 do=0\\nclk=0 di=1 do=1\\nclk=1 di=1 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=1 do=1\\nclk=1 di=1 do=0\\nclk=0 di=1 do=1\\nclk=1 di=1 do=0\\nclk=0 di=1 do=1\\nclk=1 di=1 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0\\nclk=1 di=0 do=0\\nclk=0 di=0 do=0 (0ns)\\nclk=1 di=0 do=0 (12ns)\\nclk=0 di=0 do=0 (24ns)\\nclk=1 di=0 do=0 (36ns)\\nclk=0 di=0 do=0 (48ns)\\nclk=1 di=0 do=0 (60ns)\\nclk=0 di=1 do=1 (72ns)\\nclk=1 di=1 do=0 (84ns)\\nclk=0 di=1 do=1 (96ns)\\nclk=1 di=1 do=0 (108ns)\\nclk=0 di=1 do=1 (120ns)\\nclk=1 di=1 do=0 (132ns)\\nclk=0 di=0 do=0 (144ns)\\nclk=1 di=0 do=0 (156ns)\\nclk=0 di=0 do=0 (168ns)\\nclk=1 di=0 do=0 (180ns)\\nclk=0 di=0 do=0 (192ns)\\nclk=1 di=0 do=0 (204ns)\\nclk=0 di=0 do=0 (216ns)\\nclk=1 di=0 do=0 (228ns)\\nclk=0 di=0 do=0 (240ns)\\nclk=1 di=0 do=0 (252ns)\\nclk=0 di=0 do=0 (264ns)\\nclk=1 di=0 do=0 (276ns)\\nclk=0 di=0 do=0 (288ns)\\nclk=1 di=0 do=0 (300ns)\\nclk=0 di=0 do=0 (312ns)\\nclk=1 di=0 do=0 (324ns)\\nclk=0 di=0 do=0 (336ns)\\nclk=1 di=0 do=0 (348ns)\\nclk=0 di=0 do=0 (360ns)\\nclk=1 di=0 do=0 (372ns)\\nclk=0 di=0 do=0 (384ns)\\nclk=1 di=0 do=0 (396ns)\\nclk=0 di=0 do=0 (408ns)\\nclk=1 di=0 do=0 (420ns)\\nclk=0 di=0 do=0 (432ns)\\nclk=1 di=0 do=0 (444ns)\\nclk=0 di=0 do=0 (456ns)\\nclk=1 di=0 do=0 (468ns)\\nclk=0 di=0 do=0 (480ns)\\nclk=1 di=0 do=0 (492ns)\\nclk=0 di=0 do=0 (504ns)\\nclk=1 di=0 do=0 (516ns)\\nclk=0 di=0 do=0 (528ns)\\nclk=1 di=0 do=0 (540ns)\\nclk=0 di=0 do=0 (552ns)\\nclk=1 di=0 do=0 (564ns)\\nclk=0 di=0 do=0 (576ns)\\nclk=1 di=0 do=0 (588ns)\\nclk=0 di=0 do=0 (600ns)\\nclk=1 di=0 do=0 (612ns)\\nclk=0 di=0 do=0 (624ns)\\nclk=1 di=0 do=0 (636ns)\\nclk=0 di=0 do=0 (648ns)\\nclk=1 di=0 do=0 (660ns)\\nclk=0 di=0 do=0 (672ns)\\nclk=1 di=0 do=0 (684ns)\\nclk=0 di=0 do=0 (696ns)\\nclk=1 di=0 do=0 (708ns)\\nclk=0 di=0 do=0 (720ns)\\nclk=1 di=0 do=0 (732ns)\\nclk=0 di=0 do=0 (744ns)\\nclk=1 di=0 do=0 (756ns)\\nclk=0 di=0 do=0 (768ns)\\nclk=1 di="
"5","1","FAIL","0","module tst_dff_s_n();\\n      logic data_in,clock,out;\\n      dff_s_n d1(out,clock,data_in);\\n      initial begin data_in=0; clock=0; #6 $stop end\\n      always #5 data_in=~data_in;\\n      always #6 clock=~clock;\\n      initial $monitor($time, ""data_in=%b, clock=%b, out=$bits(out)"",data_in,clock,out);\\nendmodule\\n\\n### Notes:\\n```\\n```\\n\\n## 23. dff_s_posedge\\n### Code:\\nmodule dff_s_posedge(output out,input clock,input data_in);\\n      reg out_reg;\\n      always @(posedge clock) out_reg <= data_in;\\n      out <= out_reg;\\nendmodule\\n### Base Verilog Code:\\nmodule tst_dff_s_posedge();\\n      reg data_in,clock,out;\\n      dff_s_posedge d1(out,clock,data_in);\\n      initial begin data_in=0; clock=0; #6 $stop end\\n      always #5 data_in=~data_in;\\n      always #6 clock=~clock;\\n      initial $monitor($time, ""data_in=%b, clock=%b, out=%b"",data_in,clock"
"5","2","FAIL","0","module tst_dff_p();\\n  logic di,clk; logic [1:0] do;\\n  udff_p d1(do,di,clk); // Instantiate DFF with path delay\\n  initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop\\n  always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)\\n  always #5 di=~di; // Toggle data\\n  initial $monitor($time,""clk=%b, di=%b, do=%b"",clk,di,do);\\nendmodule\\n\\n## dff/dff_p/udff_"
"5","3","FAIL","0","module dff_p(output do, input di, wire clk);\\n  reg do;\\n  assign do = do;\\n  always @(posedge clk) begin\\n    if(di == 0) begin\\n      do <= {do[1],do[0]};\\n    end else begin\\n      do <= { do[0], ~do[0] };\\n    end\\n  end\\nendmodule\\n### Results:\\nWhen compiling with the modified code, the following error is shown:\\n```\\nError--ParserError:./dff_p.v(9): Identifier ""clk"" not declared.\\n```\\nThis indicates that the Verilog parser does not recognize wire as a type. In order to correctly compile the Verilog code with the SystemVerilog modifications, the type of the variable clk must be modified to be wire.\\n\\n### Verilog Code:\\n```\\nmodule dff_p(output do, input di, input clk);\\n  reg do;\\n  assign do = do;\\n  always @(posedge clk) begin\\n    if(di == 0) begin\\n      do <= {do[1],do[0]};\\n    end else begin\\n      do <= { do[0], ~do[0] };\\n    end\\n  end\\nendmodule\\n```/Vivado_Projects/Vivado_Projects_Shared_Files/Module_Libraries/Adder_32_to_64/vhdl/README.md\\n# Adder 32-to-64:\\n\\n## Files Included:\\n- `adder_32_to_64.vhdl`\\n- `tb_adder_32_to_64.vhd`\\n- `run_adder_32_to_64_tb.tcl`\\n\\n## Vivado Files Included:\\n- `adder_32_to_64.vh`\\n- `tb_adder_32_to_64.v`\\n\\n## Functionality:\\nThe adder_32_to_64 block is responsible for adding two 32-bit numbers and putting the result in a 64-bit register. The block supports signed and unsigned addition.\\nThe block is connected to two 32-bit input registers and one 64-bit output register. The two 32-bit input registers are connected to the input ports `b` and `a`. The 64-bit output register is connected to the output port `f`.\\nThe `f` output is a 64-bit register that holds the sum of adding the `a` and `b` inputs.\\n\\n## Running the Testbench:\\nLaunch Vivado and create a project.\\nAdd the `adder_32_to_64.v` file and the `tb_adder_32_to_64.v` file to the project.\\nAdd the `run_adder_32_to_64_tb.tcl` file to the project and run the TCL script.\\nThis will add the `adder_32_to_64.vh` and the `tb_adder_32_to_64.vhd` files to the project.\\nThe block must be configured before the testbench can be run. The `adder_32_to_64.vh` file contains the configuration blocks for the block. The configuration block for this block is located in the `tb_adder_32_to_64.vhd` file.\\nThe testbench simulates the block by connecting the block to an external clock. To connect the block to the clock, add a `clk` port to the block instance and connect it to a clock signal. The `clk` value must be set to a constant value greater than 1. An example `adder_32_to_64` block is shown below:\\n```vhdl\\n-- adder_32_to_64 block\\nadder_32_to_64#2000 adder_32_to_64 (\\n.input_a(a),\\n.input_b(b),\\n.output_f(f),\\n.clk_period(6));\\n```\\nThe `clk_period` value must be set to the desired clock period in ns. An example `adder_32_to_64` block with an `clk` port is shown below:\\n```vhdl\\nadder_32_to_64#2000 adder_32_to_64 (\\n.input_a(a),\\n.input_b(b),\\n.output_f(f),\\n.clk(clk));\\n```\\nThe `clk` value must be set to the clock signal that connects the block to the external clock. The clk value must be set to a signal, not a constant value (since the constant `0` will represent a `0` value for the clock).\\nAfter the block is configured and the testbench is added to the project, the project is initialized and synthesized.\\nThe default configuration of the block is with a `clk` signal connected to the block. The default `clk_period` value is set to 6 ns.\\nTo run the testbench, the project must be set to be run in simulation mode by selecting the `run` menu and then selecting the `simulation` option.\\nBefore running the testbench, the `tb_adder_32_to_64` must be set to the top level of the block hierarchy. After the block is connected to the external clock, the testbench can be run.\\nAn example run of the testbench is shown below:\\n```\\n[root@hsdk-linux-x86-64 /opt/Xilinx/Vivado/2022.1]# vivado -mode tcl\\nVivado Tcl Shell version 2022.1 (64-bit)\\n(C) Copyright 1991-2022 Xilinx, Inc. All Rights Reserved.\\n\\nXilinx Design Software and Documentation Disclaimers:\\n(C) Copyright 2022 Xilinx, Inc.\\nLicense Agreement:\\n  Xilinx xrun command:\\n    This software and documentation is owned by Xilinx and/or its\\n    licensors. These materials may be used/distributed under the\\n    terms of the GNU GENERAL PUBLIC LICENSE Version 2.0 (the ""GPL""),\\n    included in the LICENSE file of this  to 64-bit register. This register holds the result of adding the two 32-bit inputs.\\n\\n### Verilog Code:\\n```\\nmodule adder_32_to_64(\\n  input wire [31:0] a,\\n  input wire [31:0] b,\\n  output wire [63:0] f,\\n  input wire clk\\n);\\n  reg [63:0] f;\\n  always@(posedge clk) begin \\n    f <= a+b;\\n  end\\nendmodule\\n```binary.  The GPL is also\\n    available at https://www.gnu.org/licenses/gpl.html.\\n  Xilinx run command:\\n    This license is for non-commercial use only.\\n\\n    You are"
"5","4","FAIL","0","module tst_dff_pbeh();\\n  logic di,clk; logic[1:0] do;\\n  dff_p d1(do,di,clk); // Instantiate DFF with path delay\\n  initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop\\n  always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)\\n  always #5 di=~di; // Toggle data\\n  initial $monitor($time,""clk=%b, di=%b, do=%b"",clk,di,do);\\nendmodule\\n/codeblocks/examples/basic_testing/Makefile\\n#\\n#\\n#\\n\\nall: tst_dff_pbeh\\n\\ninclude../../makefiles/verilator_makefile\\n/codeblocks/examples/basic_testing/tst_dff_pbeh.h\\n//\\n//  tst_dff_pbeh.h\\n//  codeblocks/examples/basic_testing\\n//\\n//  Created by  on 12/7/12.\\n//  Copyright (c) 2012 __MyCompanyName__. All rights reserved.\\n//\\n\\n#ifndef codeblocks_examples_basic_testing_tst_dff_pbeh_h\\n#define codeblocks_examples_basic_testing_tst_dff_pbeh_h\\n\\n#define time_resolution 1.0e-9\\n#define time_scale 1.0e9\\n#define time_units s\\n\\n#define clk period\\n#define clk_period 20.0e-6\\n\\n#endif\\n/codeblocks/examples/basic_testing/tst_dff_pbeh.cpp\\n//\\n//  main.c\\n//\\n//  main.c\\n//  codeblocks/examples/basic_testing\\n//\\n//  Created by  on 12/7/12.\\n//  Copyright (c) 2012 __MyCompanyName__. All rights reserved.\\n//\\n\\n//#include ""tst_dff_pbeh.h""\\n#include <iostream>\\nusing namespace std;\\n#include <verilated.h>\\n\\n#include ""Vtst_dff_pbeh.h""\\n#include ""Vtst_dff_pbeh__Syms.h""\\n\\n#include ""tst_dff_pbeh.h""\\n#include ""test_lib.h""\\n\\n//\\n//\\n//\\n\\n// Define clock period in seconds and frequency in Hz\\n// Note that the frequency is used to set the testbench time.\\nconst double clk_period = time_period;\\n\\n// Verilator includes\\n#include ""verilated.h"" // Verilator C++ interface\\n#include ""verilated_vcd_c.h"" // Verilator VCD tracing\\n\\nVtst_dff_pbeh *vl;\\n\\nbool test_done = false;\\n\\nvluint64_t main_time = 123456789; // Current simulation time\\n// This is a 64-bit integer to reduce wrap over issues and\\n// allow modulus.  You can also use a double, if you wish.\\n\\n// main time-advance function\\ndouble global_timeadvance() {\\n    double _rval = 0.0; // Assume nothing happens\\n    if (!test_done) {\\n        vl->clk =!vl->clk;\\n        _rval = clk_period;\\n    }\\n    return _rval;\\n} // end global_timeadvance\\n\\n// Functions to call before/after every time step\\nvoid global_pretimestep() {\\n    vl->eval(); // Evaluate model\\n    if (vl->trace()) { // If verilator is tracing signals, do so\\n        Verilated::traceEverOn(true);\\n        vl->trace(VcdC::tfp(), 99);\\n        vl->trace(VcdC::tfp(), 0);\\n    }\\n}\\n\\nvoid global_posttimestep() {\\n}\\n\\n//\\n//\\n//\\n\\nint main(int argc, char **argv, char **env) {\\n    // Initializing Verilator\\n    Verilated::commandArgs(argc, argv); // Remember args\\n    Verilated::traceEverOn(true); // Verilator trace\\n\\n//    // Initialization of Verilator model\\n//    Verilated::randReset(2); // Random reset\\n//    while (!Verilated::gotFinish()) { // Run until finish\\n//        global_timeadvance();\\n//        global_pretimestep();\\n//        global_posttimestep();\\n//    }\\n\\n    // Verilator simulation\\n	vl = new Vtst_dff_pbeh;\\n    vl->clk = 0;\\n    vl->eval(); // Evaluate model\\n\\n//    // Verilator simulation timing\\n    VL_PRINTF(""Testing %s\\n"", vl->name());\\n    vl->clk = 1;\\n    vl->eval(); // Evaluate model\\n\\n    test_done = 0; // Test is not done yet\\n\\n    // Initialization of Verilator model\\n    Verilated::randReset(2); // Random reset\\n\\n    // Initialize testbench\\n    while (!Verilated::gotFinish()) {\\n        // Advance time\\n        global_timeadvance();\\n        // Call before time step\\n        global_pretimestep();\\n        // Call after time step\\n        global_posttimestep();\\n\\n        // Do testbench stuff\\n        test_dff_pbeh(vl);\\n\\n        // Finish if test is done\\n        if (test_done) break;\\n    }\\n\\n    // Close any open files and finish\\n    vl->final(); // Destructor will perform cleanup\\n    return 0;\\n}"
"6","0","FAIL","0","module ALU3 ( input [7:0] a, b, input pass, add,\\noutput reg [7:0] alu_out );\\n// Simple combinational ALU\\nalways @(a or b or pass or add)\\nif (pass) alu_out = a;       // Pass input 'a'\\nelse if (add) alu_out = a + b; // Add inputs 'a' and 'b'\\nelse alu_out = 0;           // Default output is 0\\nendmodule\\n### Results:\\nThis code has been optimized a bit, since the default value of alu_out is set in the module definition."
"6","1","FAIL","0","module ALU ( input [7:0] a, b, input pass, add,\\noutput logic [7:0] alu_out );\\n// Simple combinational ALU\\nalways @(a or b or pass or add)\\nif (pass) alu_out = a;       // Pass input 'a'\\nelse if (add) alu_out = a + b; // Add inputs 'a' and 'b'\\nelse alu_out = 0;           // Default"
"6","2","FAIL","0","module Bin_to_Hex ( input [7:0] bin, output [3:0] hex );\\n// Simple Bin to Hex converter\\nalways @(bin)\\ncase (bin)\\n16'h0000: hex = 16'h0;\\n16'h0001: hex = 16'h1;\\n16'h0010: hex = 16'h2;\\n16'h0011: hex = 16'h3;\\n16'h0100: hex = 16'h4;\\n16'h0101: hex = 16'h5;\\n16'h0110: hex = 16'h6;\\n16'h0111: hex = 16'h7;\\n16'h"
"6","3","FAIL","0","module ALU (\\ninput [7:0] a, b, input pass, add,\\noutput logic [7:0] alu_out );\\n// Simple combinational ALU\\nalways @(a or b or pass or add)\\nif (pass) alu_out = a;       // Pass input 'a'\\nelse if (add) alu_out = a + b; // Add inputs 'a' and 'b'\\nelse alu_out = 0;           // Default output is 0\\nendmodule\\n\\n\\n### Base Verilog Code:\\nmodule ALU ( input [7:0] a, b, input pass, add,\\noutput reg[7:0]"
"6","4","FAIL","0","module ALU ( input [7:0] a, b, input pass, add,\\noutput logic [7:0] alu_out );\\n// Simple combinational ALU\\nalways @(a or b or pass or add)\\nif (pass) alu_out = a;       // Pass input 'a'\\nelse if (add) alu_out = a + b; // Add inputs 'a' and 'b'\\nelse alu_out = 0;           // Default output is 0\\nendmodule\\n### Output:\\nPassing ALU signals to register inputs will yield register contents.\\n### Schematics:\\nSchematics dont change and are the same as the previous example.\\n### PCB:\\nSchematics dont change and are the same as the previous example."
"7","0","FAIL","0","module AndOr (output X, Y, input A, B, C);\\nbit [A:0] X;\\nbit [3:0] Y;\\nassign X = B;\\nassign Y = B | C;\\nendmodule\\n\\n## Test Cases\\n\\nThe system tests the modified code to test the behavior of the code and check if the verilog is synthesizable. These tests are automated, so after making a change to the code you can re-run the tests and check if they are passed in a new branch.\\n\\n## System Design\\n\\nThere are two sections in the code to get the design working:\\n\\n1. The SystemVerilog code that will be tested.\\n2. The modified code that will be used to test the SystemVerilog code.\\n\\n### SystemVerilog Code\\n\\nThe SystemVerilog code is to be tested. The testbench is generated from the SystemVerilog code and runs through the SystemVerilog code.\\n\\n### Modified Code\\n\\nThe modified code is to be used to test the SystemVerilog code. The testbench is generated from the modified code and runs through the modified code. This modified code will be used to test both the SystemVerilog code and the modified SystemVerilog code.\\n\\n## Instructions for Using the Script\\n\\nTo use the script:\\n\\n* Add the testbench template to your repository.\\n* Write the SystemVerilog code.\\n* Write the modified code.\\n* Modify the test script to suit your code.\\n* Modify the test script to pass in your repository name and the test bench.\\n* Run the script.\\n# SystemVerilog Test Bench\\n\\nA test script that can be used to test the SystemVerilog code.\\n\\n## Test Bench Template\\n\\n* [test_template](test_template.sv)\\n\\n## Test Bench\\n\\nThe template is used to generate a testbench for the SystemVerilog code. The testbench will test the SystemVerilog code and the modified code.\\n\\n## Usage\\n\\nThis script will test two different versions of the modified code. The two versions are the modified code and the modified SystemVerilog code.\\n\\nThe script can be run from the command-line.\\n\\nThe script takes four command-line arguments:\\n\\n* **repo_name**   : The name of the repository.\\n* **repo_url**    : The URL of the repository.\\n* **test_bench**  : The name of the test bench.\\n* **system_bench** : The name of the SystemVerilog test bench.\\n\\nThe script will test two versions of the modified code.\\n\\n### Test Bench\\n\\nThe test bench will test the SystemVerilog code and the modified code.\\n\\n### SystemVerilog Test Bench\\n\\nThe SystemVerilog test bench will test the modified code and the modified SystemVerilog code.\\n\\n## Instructions for Using the Script\\n\\nTo use the script:\\n\\n* Add the test_template.sv to your repository.\\n* Write the SystemVerilog code.\\n* Write the modified code.\\n* Modify the test.sh to suit your code.\\n* Modify the test.sh to pass in your repository name, the test bench, and the SystemVerilog test bench.\\n* Run the script.\\n# SystemVerilog\\n\\nA repository to learn about SystemVerilog.\\n\\n## Test Bench\\n\\n* [test_bench](test_bench/)\\n\\n## System Design Example\\n\\n* [design_example](design_example/)\\n\\n## Test Case Example\\n\\n* [test_case_example](test_case_example/)\\n\\n## Test\\n\\n* [test](test/README.md)\\n\\n## SystemVerilog Tutorial\\n\\n* [SystemVerilog Tutorial](https://www.educative.io/courses/systemverilog-fundamentals)\\n\\n## Test Bench Template\\n\\n* [test_template](test_template.sv)\\n\\n## Test Bench\\n\\nThe template is used to generate a testbench for the SystemVerilog code. The testbench will test the SystemVerilog code and the modified code.\\n\\n## Usage\\n\\nThis script will test two different versions of the modified code. The two versions are the modified code and the modified SystemVerilog code.\\n\\nThe script can be run from the command-line.\\n\\nThe script takes four command-line arguments:\\n\\n* **repo_name**   : The name of the repository.\\n* **repo_url**    : The URL of the repository.\\n* **test_bench**  : The name of the test bench.\\n*"
"7","1","FAIL","0","module AndOr (output X, Y, input A, B, C);\\nlocalparam N = 8;\\nreg [N-1:0] a, b, c;\\nalways_ff @(posedge clk)\\nbegin\\nfor(int i = 0; i < N; i++)\\nbegin\\nX[i] <= a[i] & b[i];\\nY[i] <= b[i] | c[i];\\nend\\nend\\nendmodule\\n\\n### Testbench Code:\\n`testbench andor_tb\\n\\nalways_ff @(posedge clk)\\nbegin\\ninput <= 8'b01010101;\\nend\\n\\ninitial\\nbegin\\n\\nend\\n\\ninitial\\nbegin\\n\\nend\\n\\ninitial\\nbegin\\n\\nend\\n\\ninitial\\nbegin\\n\\nend\\n\\ninitial\\nbegin\\n\\nend`\\n#include ""include.h""\\n#include ""driverlib/rom_map.h""\\n#include ""driverlib/gpio.h""\\n#include <string.h>\\nstatic void UARTStdioIntHandler(void);\\n\\nstatic const uart_config_t uartConfig =\\n{\\n   .baudRate = 115200,\\n   .dataLength = UART_CONFIG_WLEN_8,\\n   .parityType = UART_CONFIG_PAR_NONE,\\n   .stopBits = UART_CONFIG_STOP_ONE\\n};\\n\\nstatic const uart_pin_config_t uartPinConfig =\\n{\\n   .txPin = GPIO_PIN_1,\\n   .rxPin = GPIO_PIN_0\\n};\\n\\n//static const EUSCI_UART_Config uartConfig =\\n//{\\n//    EUSCI_A_UART_CLOCKSOURCE_SMCLK,\\n//    8,\\n//    1,\\n//    EUSCI_A_UART_NO_PARITY,\\n//    EUSCI_A_UART_LSB_FIRST,\\n//    EUSCI_A_UART_ONE_STOP_BIT,\\n//    EUSCI_A_UART_MODE,\\n//    EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION\\n//};\\n\\n//static const eusci_a_uart_pin_config_t uartPinConfig =\\n//{\\n//    EUSCI_A_UART_INPUT_A,\\n//    EUSCI_A_UART_NO_REDIRECT_RXD\\n//};\\n\\nvoid initUART()\\n{\\n    MAP_UART_initModule(EUSCI_A2_BASE, &uartConfig);\\n    MAP_UART_enableModule(EUSCI_A2_BASE);\\n    MAP_UART_initRx(EUSCI_A2_BASE, &uartConfig);\\n    MAP_UART_initTx(EUSCI_A2_BASE, &uartConfig);\\n    MAP_UART_enableInterrupt(EUSCI_A2_BASE, EUSCI_A_UART_RECEIVE_INTERRUPT);\\n    MAP_UART_transmitData(EUSCI_A2_BASE, 'S');\\n    MAP_UART_enableInterrupt(EUSCI_A2_BASE, EUSCI_A_UART_RECEIVE_INTERRUPT);\\n    MAP_GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P2, GPIO_PIN1, GPIO_PRIMARY_MODULE_FUNCTION);\\n}\\n\\nvoid initGPIO()\\n{\\n    MAP_GPIO_setAsOutputPin(GPIO_PORT_P1, GPIO_PIN0);\\n    MAP_GPIO_setOutputLowOnPin(GPIO_PORT_P1, GPIO_PIN0);\\n\\n    MAP_GPIO_setAsOutputPin(GPIO_PORT_P1, GPIO_PIN6);\\n    MAP_GPIO_setOutputLowOnPin(GPIO_PORT_P1, GPIO_PIN6);\\n\\n    MAP_GPIO_setAsOutputPin(GPIO_PORT_P1, GPIO_PIN7);\\n    MAP_GPIO_setOutputHighOnPin(GPIO_PORT_P1, GPIO_PIN7);\\n\\n    MAP_GPIO_setAsOutputPin(GPIO_PORT_P2, GPIO_PIN5);\\n}\\n\\nvoid EUSCIA2_IRQHandler(void)\\n{\\n    uint8_t data;\\n\\n    switch (__even_in_range(MAP_UART_getInterruptStatus(EUSCI_A2_BASE, EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG), EUSCI_A_UART_RECEIVE_INTERRUPT))\\n    {\\n        case EUSCI_A_UART_RECEIVE_INTERRUPT:\\n        {\\n            MAP_UART_readData(EUSCI_A2_BASE, &data);\\n            MAP_UART_transmitData(EUSCI_A2_BASE, data);\\n            if(data == ';')\\n            {\\n                MAP_GPIO_setOutputLowOnPin(GPIO_PORT_P1, GPIO_PIN6);\\n            }\\n            else if(data == '#')\\n            {\\n                MAP_GPIO_setOutputHighOnPin(GPIO_PORT_P1, GPIO_PIN6);\\n            }\\n            break;\\n        }\\n        default:\\n            break;\\n    }\\n}\\n#ifndef __INCLUDE_H__\\n#define __INCLUDE_H__\\n\\n#include ""driverlib.h""\\n#include ""driverlib/uart.h""\\n\\n#include ""msp.h""\\n\\nvoid initGPIO();\\n\\nvoid initUART();\\n\\n#endif\\n#include <msp430.h>\\n\\nconst int N = 10;\\nconst int t_1 = 5000;\\nconst int t_2 = 10000;\\nconst int t_3 = 100;\\n\\nint main(void)\\n{\\n    int i = 0;\\n    WDTCTL = WDTPW | WDTHOLD;\\n    P1DIR |= 0x02;\\n    P2DIR |= 0x01;\\n    P1SEL1 |= 0x02;\\n    P1SEL0 |= 0x02;\\n\\n    P5DIR |= BIT0;\\n    P5SEL1 |= BIT0;\\n    P5SEL0 |= BIT0;\\n\\n    P4DIR |= BIT7;\\n    P4SEL0 |= BIT7;\\n    P4SEL1 |= BIT7;\\n\\n    PJDIR |= BIT6;\\n    PJOUT |= BIT6;\\n\\n    P6DIR |= BIT1;\\n    P6OUT |= BIT1;\\n\\n    TA0CCTL0 |= CCIE;\\n    TA0CCR0 = 1000;\\n    TA0CTL |= TASSEL_2 + MC_1 + ID_3;\\n\\n    __enable_interrupt();\\n\\n    for(;;)\\n    {\\n        if(i == N)\\n        {\\n            i = 0;\\n        }\\n\\n        if(i == 0)\\n        {\\n            P1OUT &= ~BIT0;\\n            P6OUT &= ~BIT1;\\n        }\\n        else if(i == 1)\\n        {\\n            P"
"7","2","FAIL","0","module AndOr (output X, Y, input A, B, C);\\nassign #10 X = A & B;\\nassign #10 Y = B | C;\\nendmodule\\n\\n/Project4/part2/part2.c\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <unistd.h>\\n#include <string.h>\\n#include <pthread.h>\\n\\n#define MAX_LINE_SIZE 200\\n\\nextern int errno;\\n\\ntypedef struct {\\n	int value;\\n	int threadId;\\n} buffer_element;\\n\\nvoid *func(void *arg);\\nbuffer_element *buffer;\\npthread_mutex_t myLock;\\nint num_of_elements;\\nint num_of_threads;\\nint num_of_iterations;\\nint num_of_writes;\\n\\nvoid buffer_init() {\\n	errno = 0;\\n	buffer = malloc(num_of_elements * sizeof(buffer_element));\\n\\n	for (int i = 0; i < num_of_elements; i++) {\\n		buffer[i].value = 0;\\n		buffer[i].threadId = 0;\\n	}\\n\\n	printf(""buffer initialized\\n"");\\n}\\n\\nvoid buffer_free() {\\n	free(buffer);\\n}\\n\\nvoid swap(buffer_element *a, buffer_element *b) {\\n	buffer_element temp = *a;\\n	*a = *b;\\n	*b = temp;\\n}\\n\\nvoid bubble_sort(buffer_element *array, int num_of_elements) {\\n	for (int i = 0; i < num_of_elements; i++) {\\n		for (int j = 0; j < num_of_elements - 1; j++) {\\n			if (array[j].value > array[j + 1].value) {\\n				swap(&array[j], &array[j + 1]);\\n			}\\n		}\\n	}\\n}\\n\\nvoid write_value(int pos) {\\n	int rand_value = rand() % 100;\\n	pthread_mutex_lock(&myLock);\\n	buffer[pos].threadId = pthread_self();\\n	buffer[pos].value = rand_value;\\n	printf(""thread %lu wrote %d\\n"", pthread_self(), rand_value);\\n	pthread_mutex_unlock(&myLock);\\n}\\n\\nvoid print_buffer() {\\n	pthread_mutex_lock(&myLock);\\n	printf(""buffer: <"");\\n	for (int i = 0; i < num_of_elements; i++) {\\n		if (buffer[i].value == 0) {\\n			printf(""__,"");\\n		} else {\\n			printf(""%d,"", buffer[i].value);\\n		}\\n	}\\n	printf("">\\n"");\\n	pthread_mutex_unlock(&myLock);\\n}\\n\\nvoid *func(void *arg) {\\n	buffer_element *array = (buffer_element *) arg;\\n	for (int i = 0; i < num_of_iterations; i++) {\\n		for (int j = 0; j < num_of_writes; j++) {\\n			write_value(rand() % num_of_elements);\\n		}\\n	}\\n	pthread_exit(NULL);\\n}\\n\\nint main(int argc, char **argv) {\\n	int num_of_threads = atoi(argv[1]);\\n	int num_of_elements = atoi(argv[2]);\\n	int num_of_iterations = atoi(argv[3]);\\n	int num_of_writes = atoi(argv[4]);\\n\\n	srand(time(NULL));\\n\\n	pthread_t *threads;\\n	threads = malloc(num_of_threads * sizeof(pthread_t));\\n\\n	printf(""num_of_threads: %d\\n"", num_of_threads);\\n	printf(""num_of_elements: %d\\n"", num_of_elements);\\n	printf(""num_of_iterations: %d\\n"", num_of_iterations);\\n	printf(""num_of_writes: %d\\n"", num_of_writes);\\n\\n	buffer_init();\\n	pthread_mutex_init(&myLock, NULL);\\n\\n	for (int i = 0; i < num_of_threads; i++) {\\n		pthread_create(&(threads[i]), NULL, &func, buffer);\\n	}\\n\\n	for (int i = 0; i < num_of_threads; i++) {\\n		pthread_join(threads[i], NULL);\\n	}\\n\\n	buffer_free();\\n\\n	return 0;\\n}\\n/Project3/part2/Makefile\\nall:\\n	iverilog -o part2 part2.v\\n	vvp part2\\nclean:\\n	rm -f part2\\n/Project2/Makefile\\nall:\\n	iverilog -o project2 project2.v\\n	vvp project2\\nclean:\\n	rm -f project2"
"7","3","FAIL","0","module AndOr (output X, Y, input A, B, C);\\nassign #10 X = A & B;\\nassign #10 Y = B | C;\\nendmodule\\n### Results:\\nThe following circuit schematics and waveform show that all the tests pass for both synthesizable and non-synthesizable designs.\\n![Test Results for 3-input AND & OR logic circuit](./images/3-input-results.png)\\n\\n\\n### Test Cases\\n\\nThe following 11 test cases were implemented for the full 3-input AND and OR logic circuit:\\n\\n1. `A | B | C`: Tests the 3-input OR case.\\n2. `A | B`: Tests the 2-input OR case.\\n3. `A & B`: Tests the 2-input AND case.\\n4. `A | B & C`: Tests the 3-input OR case when the OR part of the logic gate is ORing.\\n5. `A & B & C`: Tests the 3-input AND case.\\n6. `A & (B | C)`: Tests the 3-input AND case when the AND part of the logic gate is ANDing.\\n7. `A | B & C`: Tests the 3-input OR case when the AND part of the logic gate is ANDing.\\n8. `A & B | C`: Tests the 3-input AND case when the OR part of the logic gate is ORing.\\n9. `A ^ B ^ C`: Tests the 3-input XOR case when the XOR part is ORing.\\n10. `A ^ B`: Tests the 2-input XOR case when the XOR part is ORing.\\n11. `A ^ A`: Tests the 2-input XOR case when the XOR part is ANDing.\\n\\n#### Test Result:\\n![Test Results](./images/test-result.png)\\n#### Test Time:\\n![Test Results Time](./images/test-time.png)\\n\\n## Implementation Details\\n\\n### Design Overview\\n\\nMy design for the 3-input AND and OR logic circuit is shown in the following figure.\\n\\n![Full 3-input AND & OR logic circuit](./images/3-input-logic-circuit.png)\\n\\n### HDL Code\\n\\nThe full 3-input AND and OR logic circuit is shown below.\\n\\n```\\nmodule AndOr(\\n    output wire[1:0] X,\\n    output wire[1:0] Y,\\n    input wire A,\\n    input wire B,\\n    input wire C\\n);\\n    And2(\\n       .A(A),\\n       .B(B),\\n       .F(X[0])\\n    );\\n    Or2(\\n       .A(X[0]),\\n       .B(C),\\n       .F(X[1])\\n    );\\n    And2(\\n       .A(B),\\n       .B(C),\\n       .F(Y[0])\\n    );\\n    Or2(\\n       .A(Y[0]),\\n       .B(X[1]),\\n       .F(Y[1])\\n    );\\nendmodule\\n```\\n\\nIn my design I use two 2-input gates to form the full 3-input AND and OR logic circuit.  The 2-input gates are implemented with transistors and resistors and in 2-input NAND and NOR gates.  The output of the first 2-input NAND gate is then used as the input for the first 2-input NOR gate.  The 2 output of the last 2-input NOR gate are then the inputs for the 3-input NAND gate.  Lastly the 3-input NAND gate is then used to form the output X and Y of the 3-input AND and OR logic circuit.\\n\\n### HDL Code for 2-input NAND and NOR gates\\n\\nBelow is the HDL code for my 2-input NAND and NOR gates.\\n\\n```\\nmodule Nand2(\\n    output reg F,\\n    input A,\\n    input B\\n);\\n    assign F = ~A & ~B;\\nendmodule\\n\\nmodule Nor2(\\n    output reg F,\\n    input A,\\n    input B\\n);\\n    assign F = ~(A | B);\\nendmodule\\n```\\n\\n### HDL Code for 2-input AND and OR gates\\n\\nBelow is the HDL code for the 2-input AND and OR gates.\\n\\n```\\nmodule And2(\\n    output reg F,\\n    input A,\\n    input B\\n);\\n    Nand2 N1(.A(A),.B(B),.F(F));\\n    assign F = F;\\nendmodule\\n\\nmodule Or2(\\n    output reg F,\\n    input A,\\n    input B\\n);\\n    Nor2 N1(.A(A),.B(B),.F(F));\\n    assign F = F;\\nendmodule\\n```\\n\\n## Simulation Results\\n\\n### Test Results for 2-INPUT AND & OR logic circuit\\n\\nThe following circuit schematics and waveform show that all the tests pass for both synthesizable and non-synthesizable designs.\\n\\n![Test Results for 2-INPUT AND & OR logic circuit](./images/2-input-results.png)\\n\\n### Test Cases\\n\\nThe following 5 test cases were implemented for the 2-input AND and OR logic circuit:\\n\\n1. `A`: Tests the 2-input AND case.\\n2. `B`: Tests the 2-input OR case.\\n3. `A | B`: Tests the 2-input OR case.\\n4. `A & B`: Tests the 2-input AND case.\\n5. `A ^ B`: Tests the 2-input XOR case.\\n\\n#### Test Result:\\n![Test Results](./images/2-input-test-result.png)\\n![Test Results Time](./images/2-input-test-time.png)\\n\\n## Simulation Results for Full 3-input AND & OR logic circuit\\n### Test Results for 3-INPUT AND & OR logic circuit\\n\\nThe following circuit schematics and waveform show that all the tests pass for both synthesizable and non-synthesizable designs.\\n\\n![Test Results for 3-INPUT AND & OR logic circuit](./images/3-input-results.png)\\n\\n### Test Cases\\n\\nThe following 11 test cases were implemented for the full 3-input AND and OR logic circuit:\\n\\n1. `A | B | C`: Tests the 3-input OR case.\\n2. `A | B`: Tests the 2-input OR case.\\n3. `A & B`: Tests the 2-input AND case.\\n4. `A | B & C`: Tests the 3-input OR case when the OR part of the logic gate is ORing.\\n5. `A & B & C`: Tests the 3-input AND case.\\n6. `A & (B | C)`: Tests the 3-input AND case when the AND part of the logic gate is ANDing.\\n7. `A | B & C`: Tests the 3-input OR case when the AND part of the logic gate is ANDing.\\n8. `A & B | C`: Tests the 3-input AND case when the OR part of the logic gate is ORing.\\n9. `A ^ B ^ C`: Tests the 3-input XOR case when the XOR part is ORing.\\n10. `A ^ B`: Tests the 2-input XOR case when the XOR part is ORing.\\n11. `A ^ A`: Tests the 2-input XOR case when the XOR part is ANDing.\\n\\n#### Test Result:\\n![Test Results](./images/3-input-test-result.png)\\n![Test Results Time](./images/3-input-test-time.png)\\n\\n## Conclusion\\n\\nAll of my test cases for both 2-input AND and OR logic circuit pass with both synthesizable and non-synthesizable implementations.  The full 3-input AND and OR logic circuit tests all of the possible inputs for the AND and OR logic gates with both synthesizable and non-synthesizable designs.\\n\\n## References:\\n[1] https://www.electronics-tutorials.ws/wp-content/uploads/2016/06/nand-or.png\\n\\n[2] http://inst.eecs.berkeley.edu/~cs451/sp16/projects/project2.html\\n\\n[3] https://www.electronics-tutorials.ws/logic/logic_2.html\\n\\n[4] http://netlib.cs.umn.edu/netlib/people/bringmann/doc/ANDOR.html\\n\\n[5] https://en.wikipedia.org/wiki/NAND_logic\\n\\n[6] https://en.wikipedia.org/wiki/NOR_logic\\n\\n[7] https://en.wikipedia.org/wiki/XOR_logic\\n\\n[8] https://en.wikipedia.org/wiki/XNOR_logic\\n\\n[9] https://www.ece.kth.se/courses/09090/lecture1.pdf\\n\\n[10] https://www.ece.kth."
"7","4","FAIL","0","module AndOr (output X, Y, input short A, B, C);\\nassign X = A & B;\\nassign Y = B | C;"
"8","0","FAIL","0","module IR ( input [7:0] data_in, input load, clk, output reg [7:0] data_out );\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\n### Testbench Code:\\nmodule IR_tb;\\nparameter int width = 8;\\nlogic clk;\\nreg [7:0] data_in, data_out;\\nreg load = 1'b0;\\n\\ninitial clk = 1'b0;\\ninitial begin\\n#width 1 clk = 1'b1;\\n#width 1 clk = 1'b0;\\nend\\nIR (data_in, load, clk, data_out);\\nendmodule"
"8","1","FAIL","0","module IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\n### Verilog Code:\\nmodule IR ( input [7:0] data_in, input load, clk,\\noutput reg [7:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\n## 16.1.2.2.3. Packing Arrays\\n\\nThe packing rule above is a special form of array packing. Unlike the 1D packing rule, it can only be used at the top level of the packed array declaration. Its use should be obvious: arrays are not packed by default, so using a packed array is the only way to pack them.\\n\\nThe example below shows how to declare a 4D packed array. It is identical to the example in section 16.1.2.2.2, except that the packing rule has been changed to apply only to the top-level array declaration.\\n\\n module IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\n\\n## 16.1.2.2.4. Inside Operator\\n\\nThe inside operator is used to access packed array elements. The syntax is\\n\\ninside(array_name, n, m)\\n\\nwhere array_name is a 4D packed array, and n and m are indices for the 2D array subscripts.\\n\\nThe example below shows some examples of the inside operator. The first one is straightforward:\\n\\n module IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\n\\nThe inside operator can also be used to do multi-dimensional array access (as in section 16.1.2.2.2).\\n\\nThe inside operator can be used to access arrays packed in the same module (or even a different module) with different declarations. The declarations must have compatible vector types:\\n\\n module IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\n\\n## 16.1.2.2.5. Unpacking Arrays\\n\\nArrays packed in other modules (or themselves) can be unpacked in a 2D array, or a 4D packed array, or a 1D packed array. The unpacked representation is not packed. Packed arrays can be packed again. In all cases, the packing rule applies.\\n\\nThe unpacked representation of a packed array has the same dimensions as the packed array. The unpacked representation can be unpacked into a packed array if the dimensions are compatible. The unpacked representation can be unpacked into a 1D array. The unpacked representation can be packed into a 4D array.\\n\\nThe following example unpacks the array A into a 2D array, which is packed. The unpacked representation can be packed again into a 4D array.\\n\\n module Top_Level ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n\\nmodule IR ( input [1:0] data_in, input load, clk,  // Instruction Register\\noutput reg [1:0] data_out );\\n\\nmodule A ( input [1:0] a, input [1:0] b, // 2D array\\noutput reg [1:0] result );\\nassign result = a + b;\\nendmodule\\n\\nmodule IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\nendmodule // Top Level\\n\\nThe following example unpacks the array A into a 1D array, which is unpacked. The unpacked representation can be packed into a 4D array.\\n\\n module Top_Level ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n\\nmodule IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n\\nmodule A ( input [1:0] a, input [1:0] b,\\noutput reg [1:0] result );\\nassign result = a + b;\\nendmodule\\n\\nmodule IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\nendmodule // Top Level\\n\\n## 16.1.2.2.6. Using 1D Packed Arrays as Registers\\n\\nA 1D packed array can be used as a register, just like a 1D array. When it is loaded, the packed array is unpacked into an unpacked 1D array.\\n\\nThe following example uses 1D packed arrays as registers that are loaded on posedge clk:\\n\\n module Top_Level ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n\\nmodule IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n\\nmodule A ( input [1:0] a, input [1:0] b,\\noutput reg [1:0] result );\\nassign result = a + b;\\nendmodule\\n\\nmodule IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\nendmodule // Top Level\\n\\n## 16.1.2.2.7. Multiple Assignment\\n\\nMultiple assignment can be used to assign to packed arrays.\\n\\nThe following example assigns to packed arrays. The first assignment to the packed array is a multiple assignment. The second assignment is a single assignment.\\n\\n module IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\n\\n## 16.1.2.2.8. Packing with the inside Operator\\n\\nIf the inside operator is used to declare a packed array within a non-packed array, the packing rule applies to that declaration.\\n\\nThe following example uses the inside operator to declare a packed array within a 1D array.\\n\\n module Top_Level ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n\\nmodule IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n\\nmodule A ( input pack [1:0] a, input pack [1:0] b,\\noutput reg [1:0] result );\\nassign result = a + b;\\nendmodule\\n\\nmodule IR ( input [1:0] data_in, input load, clk,\\noutput reg [1:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nendmodule\\nendmodule // Top Level\\n\\n## 16.1.2.2.9. Packing with the inside Operator in a Submodule\\n\\nIf the inside operator is used to declare a packed array within a packed array, the packing rule applies to that declaration.\\n\\nThe following example uses the inside operator to declare a packed array within a packed array.\\n\\n module Top_Level ( input [1:0] data_in, input load, clk,"
"8","2","FAIL","0","module IR ( logic [1:0] A [0:3], input [7:0] data_in, input load, clk, output reg [7:0] data_out );\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in;\\nend\\nendmodule\\n#\\n### Simulation:\\nThe simulation will be run using the following testbench code:\\n### Testbench:\\nmodule irtb;\\nlogic clk;\\nlogic load;\\nlogic [7:0] data_in;\\nlogic [4:0] A;\\nlogic [7:0] data_out;\\n\\n# Generate inputs from a packed array\\nreg_A  = 0;\\nA = {A[3:2], A[1:0]};\\n\\ninitial\\n# 100ns delay\\nclk = 0;\\n# 100ns delay\\nload = 1;\\n# 100ns delay\\n# Run 5 cycles\\n# 50ns delay\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =!$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =$rose();\\nload = $rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 # 100ns delay clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n\\$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\n# 100ns delay\\n\\nend\\nendmodule\\n\\n\\n\\n# 10.9.2.5.1Simulating the FSM With the New IR Module\\n\\nTo finish the module, we add the following to the end of the IR module:\\n\\n## module IR( input [7:0] data_in, input load, clk,\\n## output reg [7:0] data_out );\\n##\\n## // Simple register (Instruction Register) loaded on posedge clk when load is high\\n## always @( posedge clk )\\n## if ( load ) data_out <= data_in;\\n##\\n\\n/*\\nThe clock signal does not need to be explicitly added to the module because the\\nmodule is already listed in the netlist.\\n*/\\nendmodule\\n\\n\\n## Simulating the FSM With the New IR Module\\n\\nThe simulation will be run using the following testbench code:\\n\\n### Testbench:\\nmodule irtb;\\nlogic clk;\\nlogic load;\\nlogic [7:0] data_in;\\nlogic [4:0] A;\\nlogic [7:0] data_out;\\n\\n# Generate inputs from a packed array\\nreg_A = 0;\\nA = {A[3:2], A[1:0]};\\n\\ninitial\\n# 100ns delay\\nclk = 0;\\n# 100ns delay\\nload = 1;\\n# 100ns delay\\n# Run 5 cycles\\n# 50ns delay\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =!$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 # 100ns delay clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 # 100ns delay clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nclk =!$rose(); load =$rose();\\n$display(""data_in = %x, data_out = %x"", data_in, data_out); data_in = 2, data_out = 2 # 100ns delay clk =$rose();\\nload =!$rose();$display(""data_in = %x, data_out = %x"", data_in, data_out);\\ndata_in = 2, data_out = 2\\nend\\nendmodule\\n\\n\\n\\n# 10.9.2.5.2Simulation Run Using Waveform Capture\\n\\nAfter the simulation is run, the waveform will be captured using the Waveform Capture utility to the following file\\n\\n### Waveform\\n\\nFigure"
"8","3","FAIL","0","module IR ( input [7:0] data_in, input load, clk,\\noutput reg [7:0] data_out );\\n// Simple register (Instruction Register) loaded on posedge clk when load is high\\nalways @( posedge clk )\\nif ( load ) data_out <= data_in; // 1D array\\ndata_out <= data_in; // 2D array\\ndata_out <= data_in[1]; // 3D array\\ndata_out <= data_in[1:3]; // 4D array\\nendmodule\\nTo test the variations, modify the top-level testbench module as follows:\\nmodule tb_IR ( );\\n... // Other testbench code...\\nreg [7:0] data_in;\\nreg load;\\nreg clk;\\nassign clk = 1'b0;\\ngenerate\\n// Single-Dimensional array (one-dimensional logic-vector)\\nfor ( data_in = 0; data_in <= 255; data_in++ )\\nbegin\\nassign data_in = data_in;\\nassign clk = 0;\\nassign load = 1;\\n// 2D array (two-dimensional logic-vector)\\nfor ( data_in = 0; data_in <= 511; data_in += 32 )\\nbegin\\nassign data_in = data_in;\\nassign clk = 0;\\nassign load = 1;\\n// 3D array (three-dimensional logic-vector)\\nfor ( data_in = 0; data_in <= 1023; data_in += 1024 )\\nbegin\\nassign data_in = data_in;\\nassign clk = 0;\\nassign load = 1;\\n// 4D array (four-dimensional logic-vector)\\nfor ( data_in = 0; data_in <= 2047; data_in += 2048 )\\nbegin\\nassign data_in = data_in;\\nassign clk = 0;\\nassign load = 1;\\nend\\nend\\nassign clk = 1;\\nassign load = 0;\\nend\\nend\\nendmodule\\nAfter running the testbench, use waveform viewer to verify the generated waveforms as follows:\\n141\\n142\\n143\\n144\\n145\\n146\\n147\\n148\\n149\\n150\\n151\\n152\\n153\\n154\\n155\\n156\\n157\\n158\\n159\\n160\\n161\\n162\\n163\\n164\\n165\\n166\\n167\\n168\\n169\\n170\\n171\\n172\\n173\\n174\\n175\\n176\\n177\\n178\\n179\\n180\\n181\\n182\\n183\\n184\\n185\\n186\\n187\\n188\\n189\\n190\\n191\\n192\\n193\\n194\\n195\\n196\\n197\\n198\\n199\\n200\\n201\\n202\\n203\\n204\\n205\\n206\\n207\\n208\\n209\\n210\\n211\\n212\\n213\\n214\\n215\\n216\\n217\\n218\\n219\\n220\\n221\\n222\\n223\\n224\\n225\\n226\\n227\\n228\\n229\\n230\\n231\\n232\\n233\\n234\\n235\\n236\\n237\\n238\\n239\\n240\\n241\\n242\\n243\\n244\\n245\\n246\\n247\\n248\\n249\\n250\\n251\\n252\\n253\\n254\\n255\\n256\\n257\\n258\\n259\\n260\\n261\\n262\\n263\\n264\\n265\\n266\\n267\\n268\\n269\\n270\\n271\\n272\\n273\\n274\\n275\\n276\\n277\\n278\\n279\\n280\\n281\\n282\\n283\\n284\\n285\\n286\\n287\\n288\\n289\\n290\\n291\\n292\\n293\\n294\\n295\\n296\\n297\\n298\\n299\\n300\\n301\\n302\\n303\\n304\\n305\\n306\\n307\\n2018  and \\n308\\n...\\n318\\n319\\n320\\n321\\n322\\n323\\n324\\n325\\n326\\n327\\n328\\n329\\n330\\n331\\n332\\n333\\n334\\n335\\n336\\n337\\n338\\n339\\n340\\n341\\n342\\n343\\n344\\n345\\n346\\n347\\n348\\n349\\n350\\n351\\n352\\n353\\n354\\n355\\n356\\n357\\n358\\n359\\n360\\n361\\n362\\n363\\n364\\n365\\n366\\n367\\n368\\n369\\n370\\n371\\n372\\n373\\n374\\n375\\n376\\n377\\n378\\n379\\n380\\n381\\n382\\n383\\n384\\n385\\n386\\n387\\n388\\n389\\n390\\n391\\n392\\n393\\n394\\n395\\n396\\n397\\n398\\n399\\n400\\n401\\n402\\n403\\n404\\n405\\n411\\n412\\n413\\n414\\n415\\n416\\n417\\n418\\n419\\n520\\n421\\n422\\n423\\n424\\n425\\n426\\n427\\n428\\n429\\n430\\n431\\n432\\n433\\n434\\n435\\n436\\n437\\n438\\n439\\n440\\n441\\n442\\n443\\n444\\n445\\n446\\n447\\n448\\n449\\n450\\n451\\n452\\n453\\n454\\n455\\n456\\n457\\n458\\n459\\n460\\n461\\n462\\n463\\n464\\n465\\n466\\n467\\n468\\n469\\n470\\n471\\n472\\n473\\n474\\n475\\n476\\n477\\n478\\n479\\n480\\n481\\n482\\n483\\n484\\n485\\n486\\n487\\n488\\n489\\n490\\n491\\n492\\n493\\n494\\n495\\n496\\n497\\n498\\n499\\n500\\n501\\n502\\n503\\n504\\n505\\n506\\n507\\n508\\n509\\n510\\n511\\n512\\n513\\n514\\n515\\n516\\n517\\n518\\n519\\n520\\n521\\n522\\n523\\n524\\n525\\n526\\n527\\n528\\n529\\n530\\n531\\n532\\n533\\n534\\n535\\n536\\n53"
"8","4","FAIL","0",""
"9","0","FAIL","0","module Problem13(input [3:0] a, b, output [3:0] x);\\n  wire [3:0] ham;\\n  assign ham = 4'd0;\\n  assign ham = a ^ b;\\n  assign ham = ~ham;\\n  assign x = 4'd0;\\n  assign x = ham[3:0];\\nendmodule\\n### Output:\\n4'h1\\n### Test Input:\\n4'h3 4'h1\\n### Expected Output:\\n4'h2\\n""""""\\n\\n\\ndef problemDesc(pNum):\\n    if(pNum == 1):\\n        return PROBLEM_1_DESC\\n    elif(pNum == 2):\\n        return PROBLEM_2_DESC\\n    elif(pNum == 3):\\n        return PROBLEM_3_DESC\\n    elif(pNum == 4):\\n        return PROBLEM_4_DESC\\n    elif(pNum == 5):\\n        return PROBLEM_5_DESC\\n    elif(pNum == 6):\\n        return PROBLEM_6_DESC\\n    elif(pNum == 7):\\n        return PROBLEM_7_DESC\\n    elif(pNum == 8):\\n        return PROBLEM_8_DESC\\n    elif(pNum == 9):\\n        return PROBLEM_9_DESC\\n    elif(pNum == 10):\\n        return PROBLEM_10_DESC\\n    elif(pNum == 11):\\n        return PROBLEM_11_DESC\\n    elif(pNum == 12):\\n        return PROBLEM_12_DESC\\n    elif(pNum == 13):\\n        return PROBLEM_13_DESC\\n    else: return None\\n\\n\\nif __name__ == ""__main__"":\\n    start = time.time()\\n    print(""Problem 1"")\\n    print(problemDesc(1))\\n    print(""Problem 2"")\\n    print(problemDesc(2))\\n    print(""Problem 3"")\\n    print(problemDesc(3))\\n    print(""Problem 4"")\\n    print(problemDesc(4))\\n    print(""Problem 5"")\\n    print(problemDesc(5))\\n    print(""Problem 6"")\\n    print(problemDesc(6))\\n    print(""Problem 7"")\\n    print(problemDesc(7))\\n    print(""Problem 8"")\\n    print(problemDesc(8))\\n    print(""Problem 9"")\\n    print(problemDesc(9))\\n    print(""Problem 10"")\\n    print(problemDesc(10))\\n    print(""Problem 11"")\\n    print(problemDesc(11))\\n    print(""Problem 12"")\\n    print(problemDesc(12))\\n    print(""Problem 13"")\\n    print(problemDesc(13))\\n    print(""Total Run time: "", time.time() - start)\\n/Problem_8/Problem8.py\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n""""""\\n@author: \\n\\n@description: Write a Verilog module to find the hamming distance between two 4-bit values and produce a 4-bit output value.\\n\\n@input: 4'h3 4'h1\\n@output: 4'h2\\n""""""\\nfrom __future__ import print_function\\n\\nPROBLEM_DESC = """"""\\n@author: \\n\\n@description: Write a Verilog module to find the hamming distance between two 4-bit values and produce a 4-bit output value.\\n\\n@input: 4'h3 4'h1\\n@output: 4'h2\\n"""""""
"9","1","FAIL","0","```\\nmodule Problem17(input [3:0] a, b, output [3:0] diff);\\n  reg [3:0] reg1, reg2, reg3;\\n  assign reg1 = a - b;\\n  assign reg2 = reg1 - a + b;\\n  assign reg3 = reg2 - reg1;\\n  assign"
"9","2","FAIL","0","module Problem8_1(input [3:0] a, b, output [3:0] diff);\\nreg [3:0] packedStruct;\\nassign packedStruct = {a, b};\\nassign diff = packedStruct[1] - packedStruct[2];\\nendmodule// \\n// 3/20/2020\\n// Lab3\\n// Problem 1\\n// Description:\\n// This program will take an input number, perform an operation with it and the output the result. the program will also keep track of the number of\\n// operations it has performed.\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include ""operations.h""\\n\\nint main() {\\n\\n    int inputNumber;\\n    char selection;\\n\\n    while (1) {\\n        printf(""Enter your selection: "");\\n        scanf(""%c"", &selection);\\n        printf(""\\n"");\\n\\n        switch (selection) {\\n            case '0':\\n                printf(""Program ended.\\n"");\\n                return 0;\\n            case '1':\\n                printf(""You selected add\\n"");\\n                printf(""Enter your number: "");\\n                scanf(""%d"", &inputNumber);\\n                printf(""The result of adding %d and 2 is %d\\n"", inputNumber, add(inputNumber));\\n                printf(""Number of operations performed: %d\\n"", getNumOps());\\n                break;\\n            case '2':\\n                printf(""You selected subtract\\n"");\\n                printf(""Enter your number: "");\\n                scanf(""%d"", &inputNumber);\\n                printf(""The result of subtracting %d and 2 is %d\\n"", inputNumber, subtract(inputNumber));\\n                printf(""Number of operations performed: %d\\n"", getNumOps());\\n                break;\\n            case '3':\\n                printf(""You selected multiply\\n"");\\n                printf(""Enter your number: "");\\n                scanf(""%d"", &inputNumber);\\n                printf(""The result of multiplying %d and 2 is %d\\n"", inputNumber, multiply(inputNumber));\\n                printf(""Number of operations performed: %d\\n"", getNumOps());\\n                break;\\n            case '4':\\n                printf(""You selected divide\\n"");\\n                printf(""Enter your number: "");\\n                scanf(""%d"", &inputNumber);\\n                printf(""The result of dividing %d and 2 is %d\\n"", inputNumber, divide(inputNumber));\\n                printf(""Number of operations performed: %d\\n"", getNumOps());\\n                break;\\n            default:\\n                printf(""Error, try again.\\n"");\\n                break;\\n        }\\n\\n    }\\n}\\n// \\n// 3/20/2020\\n// Lab3\\n// Problem 5\\n// Description:\\n// This program will take an input number, perform an operation with it and the output the result. the program will also keep track of the number of\\n// operations it has performed.\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <inttypes.h>\\n#include <string.h>\\n\\nvoid *myMalloc(size_t size) {\\n    void *ptr = malloc(size);\\n    if (ptr == NULL) {\\n        printf(""Error: malloc failed.\\n"");\\n        exit(0);\\n    }\\n    memset(ptr, 0, size);\\n    return ptr;\\n}\\n\\nint main(int argc, char *argv[]) {\\n    int *ptr;\\n    size_t size;\\n\\n    if (argc < 2) {\\n        printf(""Error: Incorrect usage, enter in the number of bytes to allocate.\\n"");\\n        exit(0);\\n    }\\n\\n    size = atoi(argv[1]);\\n    printf(""Allocating %zu bytes\\n"", size);\\n    ptr = myMalloc(size);\\n    printf(""Address: %p\\n"", ptr);\\n    free(ptr);\\n    return 0;\\n}\\n# Computer Architecture Labs\\n\\nThese are my lab assignments for CS303E\\n// \\n// 3/20/2020\\n// Lab3\\n// Problem 3\\n// Description:\\n// This program will print out all the numbers from 1 to 100 and then print out the numbers that are divisible by both 3 and 5.\\n// it will also print out the numbers that are divisible by 3 or 5.\\n\\n\\n#include <stdio.h>\\n\\nint main() {\\n\\n    printf(""Number multiples of 3 or 5 from 1 to 100:\\n"");\\n\\n    for (int i = 1; i <= 100; ++i) {\\n        if (i % 3 == 0 || i % 5 == 0) {\\n            printf(""%d\\n"", i);\\n        }\\n    }\\n\\n    printf(""Number multiples of 3 and 5 from 1 to 100:\\n"");\\n\\n    for (int i = 1; i <= 100; ++i) {\\n        if (i % 3 == 0 && i % 5 == 0) {\\n            printf(""%d\\n"", i);\\n        }\\n    }\\n    return 0;\\n}\\n// \\n// 3/14/2020\\n// Lab2\\n// Problem 1\\n// Description:\\n// This program will sum the user inputted numbers and print out the resulting value.\\n\\n#include <stdio.h>\\n\\nint main() {\\n    float inputNumber;\\n    float inputNumber2;\\n    float total;\\n\\n    printf(""Enter your first number: "");\\n    scanf(""%f"", &inputNumber);\\n    printf(""Enter your second number: "");\\n    scanf(""%f"", &inputNumber2);\\n\\n    total = inputNumber + inputNumber2;\\n\\n    printf(""Your result: %f\\n"", total);\\n\\n    return 0;\\n}\\n#define _POSIX_C_SOURCE 200112L\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <sys/types.h>\\n#include <sys/stat.h>\\n#include <unistd.h>\\n\\nint main (int argc, char **argv) {\\n    if (argc!= 4) {\\n        printf(""Incorrect number of arguments, enter the filename, the user id, and the group id\\n"");\\n        return -1;\\n    }\\n\\n    char *filename = argv[1];\\n    uid_t uid = atoi(argv[2]);\\n    gid_t group = atoi(argv[3]);\\n    if (uid < 0 || group < 0) {\\n        printf(""Invalid user id or group id, must be a positive or zero number\\n"");\\n        return -1;\\n    }\\n\\n    int result = chown(filename, uid, group);\\n    if (result < 0) {\\n        printf(""Failed to change ownership\\n"");\\n        return -1;\\n    }\\n\\n    return 0;\\n}\\n#include ""operations.h""\\n\\nstatic int numOps;\\n\\nvoid init() {\\n    numOps = 0;\\n}\\n\\nint add(int number) {\\n    init();\\n    numOps++;\\n    return number + 2;\\n}\\n\\nint subtract(int number) {\\n    init();\\n    numOps++;\\n    return number - 2;\\n}\\n\\nint multiply(int number) {\\n    init();\\n    numOps++;\\n    return number * 2;\\n}\\n\\nint divide(int number) {\\n    init();\\n    numOps++;\\n    return number / 2;\\n}\\n\\nint getNumOps() {\\n    return numOps;\\n}\\n// \\n// 3/20/2020\\n// Lab3\\n// Problem 4\\n// Description:\\n// This program will take an input number, perform an operation with it and the output the result. the program will also keep track of the number of\\n// operations it has performed.\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include ""operations.h""\\n\\nint main() {\\n\\n    int inputNumber;\\n    char selection;\\n\\n    while (1) {\\n        printf(""Enter your selection: "");\\n        scanf(""%c"", &selection);\\n        printf(""\\n"");\\n        int op = 0;\\n        switch (selection) {\\n            case '0':\\n                printf(""Program ended.\\n"");\\n                return 0;\\n            case '1':\\n                printf(""You selected add\\n"");\\n                printf(""Enter your number: "");\\n                scanf(""%d"", &inputNumber);\\n                op = add(inputNumber);\\n                printf(""The result of adding %d and 2 is %d\\n"", inputNumber, op);\\n                printf(""Number of operations performed: %d\\n"", getNumOps());\\n                break;\\n            case '2':\\n                printf(""You selected subtract\\n"");\\n                printf(""Enter your number: "");\\n                scanf(""%d"", &inputNumber);\\n                op = subtract(inputNumber);\\n                printf(""The result of subtracting %d and 2 is %d\\n"", inputNumber, op);\\n                printf(""Number of operations performed: %d\\n"", getNumOps());\\n                break;\\n            case '3':\\n                printf(""You selected multiply\\n"");\\n                printf(""Enter your number: "");\\n                scanf(""%d"", &inputNumber);\\n                op = multiply(inputNumber);\\n                printf(""The result of multiplying %d and 2 is %d\\n"", inputNumber, op);\\n                printf(""Number of operations performed: %d\\n"", getNumOps());\\n                break;\\n            case '4':\\n                printf("""
"9","3","FAIL","0","```\\nmodule Problem12(input [3:0] a, b, output [3:0] c);\\n  reg [3:0] temp;\\n  pack xy {\\n    reg [3:0] x;\\n    reg [3:0] y;\\n    reg [0:0] z;\\n  }\\n  assign temp = c;\\n  pack xy {\\n    xy.x = a;\\n    xy.y = b;\\n  }\\n  pack xy {\\n    c = xy.x + xy.y;\\n  }\\nendmodule\\n```\\n#ifndef __P_H_\\n#define __P_H_\\n\\n#define true 1\\n#define false 0\\n\\n#define AND(a, b) ((a) && (b))\\n#define NAND(a, b) (!((a) && (b)))\\n#define OR(a, b) ((a) || (b))\\n#define NOR(a, b) (!((a) || (b)))\\n#define XOR(a, b) ((a) ^ (b))\\n#define NXOR(a, b) (!(a ^ b))\\n\\n#define NOT(a) (!a)\\n\\n#define NOP() asm volatile(""nop"")\\n\\n#define BIT(bit) (1 << (bit))\\n\\nint bin_to_dec(int a);\\nint not_a(int a);\\nint not_b(int b, int a);\\nint and_a_b(int a, int b);\\nint or_a_b(int a, int b);\\nint not_a_and_b_or_c(int a, int b, int c);\\nint nor_a_b_and_c(int a, int b, int c);\\nint a_eq_b_or_neq_c_and_a_eq_b(int a, int b, int c);\\n\\n#endif\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdint.h>\\n\\n#include ""p.h""\\n\\nint bin_to_dec(uint8_t bin)\\n{\\n  int result = 0;\\n  int i;\\n\\n  for (i = 0; i < 8; i++) {\\n    int bit = (bin >> i) & 1;\\n    result += bit * BIT(7 - i);\\n  }\\n\\n  return result;\\n}\\n\\nint not_a(int a)\\n{\\n  return ~a;\\n}\\n\\nint not_b(int b, int a)\\n{\\n  return ~b & a;\\n}\\n\\nint and_a_b(int a, int b)\\n{\\n  return a & b;\\n}\\n\\nint or_a_b(int a, int b)\\n{\\n  return a | b;\\n}\\n\\nint not_a_and_b_or_c(int a, int b, int c)\\n{\\n  return not_a(a) & b & c;\\n}\\n\\nint nor_a_b_and_c(int a, int b, int c)\\n{\\n  return not_a(a) | b | c;\\n}\\n\\nint a_eq_b_or_neq_c_and_a_eq_b(int a, int b, int c)\\n{\\n  return a!= c & a == b | a == b;\\n}\\n\\nint main(int argc, char *argv[])\\n{\\n  int a = bin_to_dec(argv[1][0]);\\n  int b = bin_to_dec(argv[2][0]);\\n  int c = bin_to_dec(argv[3][0]);\\n\\n  printf(""a = %d, b = %d, c = %d\\n"", a, b, c);\\n\\n  printf(""NOT(a) = %d\\n"", not_a(a));\\n  printf(""NOT(b) = %d\\n"", not_a(b));\\n  printf(""NOT(a) & b = %d\\n"", not_a(a) & b);\\n  printf(""NOT(b) & a = %d\\n"", not_b(b, a));\\n  printf(""a & b = %d\\n"", and_a_b(a, b));\\n  printf(""b & a = %d\\n"", and_a_b(b, a));\\n  printf(""a | b = %d\\n"", or_a_b(a, b));\\n  printf(""b | a = %d\\n"", or_a_b(b, a));\\n  printf(""NOT(a) & b | c = %d\\n"", not_a(a) & b | c);\\n  printf(""NOT(a) | b & c = %d\\n"", not_a(a) | b & c);\\n  printf(""a!= c & a == b | a == b = %d\\n"", a_eq_b_or_neq_c_and_a_eq_b(a, b, c));\\n  printf(""NOT(a) | NOT(b) & NOT(c) = %d\\n"", not_a(a) | not_b(b, a) & not_b(c, b));\\n  printf(""NOT(NOT(a)) & NOT(NOT(b)) & NOT(NOT(c)) = %d\\n"", not_a(a) & not_b(b, a) & not_b(c, b));\\n\\n  return 0;\\n}\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdint"
"9","4","FAIL","0","module Problem11(input [3:0] a, b, output [3:0] diff);\\n  assign diff = substract_with_carry(a, b);\\nendmodule\\n\\nmodule substract_with_carry(input [3:0] a, b, output [3:0] diff, output [3:0] borrow);\\n  // Full adder\\n  wire [2:0] sum_a, sum_b, sum_c, borrow_out, carry_out;\\n  wire z = a ^ b;\\n  wire c_a = a & b;\\n  wire c_b = a ^ b;\\n  wire s = c_a ^ c_b;\\n  wire s2 = a & b;\\n  wire s3 = a ^ b;\\n  assign borrow_out[2] = s2;\\n  assign borrow_out[1] = s3;\\n  assign borrow_out[0] = ~s2 & ~s3;\\n  assign sum_a = borrow_out[2] | a;\\n  assign sum_b = borrow_out[1] | b;\\n  assign sum_c = borrow_out[0] | sum_a;\\n  assign diff = sum_c;\\n  assign carry_out = sum_c & sum_b;\\nendmodule\\n\\nmodule ripple_carry(input [3:0] a, output [3:0] s);\\n  wire [3:0] borrow_out;\\n  assign s = a;\\n  reg [3:0] borrow = 0;\\n  reg [3:0] carry = 0;\\n  carry_loop: for (int i = 2; i >= 0; i--){\\n    ripple_carry_loop: for (int j = 0; j <= 3; j++){\\n      assign borrow_out[i] = carry & a[j];\\n    }\\n    assign a = a[3:0] | s[3:0];\\n    assign s[i+1] = borrow_out[i] | s[i+1];\\n    assign carry = borrow_out[i] & s[i];\\n  }\\nendmodule\\n### End Verilog Code\\n/Lab8/Problem1.py\\n# Problem 1\\n# Implement a simple ALU using verilog\\n# a and b are inputs to the ALU\\n# output is the result of the operation\\n\\n# Base Verilog Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a + b;\\n#endmodule\\n\\n# Variation Instruction:\\n# Implement the subtraction operation in the ALU\\n# The subtraction operation is c = a - b\\n\\n# Modified Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a - b;\\n#endmodule\\n\\n# End Verilog Code\\n\\n# 2. \\n# Base Verilog Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a + b;\\n#endmodule\\n\\n# Variation Instruction:\\n# Implement the multiplication operation in the ALU\\n# The multiplication operation is c = a * b\\n\\n# Modified Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a * b;\\n#endmodule\\n\\n# End Verilog Code\\n\\n# 3. \\n# Base Verilog Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a + b;\\n#endmodule\\n\\n# Variation Instruction:\\n# Implement the 2-bit division operation in the ALU\\n# The division operation is c = a / b\\n\\n# Modified Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = (a + b) / 2;\\n#endmodule\\n\\n# End Verilog Code\\n\\n# 4. \\n# Base Verilog Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a + b;\\n#endmodule\\n\\n# Variation Instruction:\\n# Implement the left shift operation in the ALU\\n# The left shift operation is c = a << b\\n\\n# Modified Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a << b;\\n#endmodule\\n\\n# End Verilog Code\\n\\n# 5. \\n# Base Verilog Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a + b;\\n#endmodule\\n\\n# Variation Instruction:\\n# Implement the right shift operation in the ALU\\n# The right shift operation is c = a >> b\\n\\n# Modified Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a >> b;\\n#endmodule\\n\\n# End Verilog Code\\n\\n# 6. \\n# Base Verilog Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a + b;\\n#endmodule\\n\\n# Variation Instruction:\\n# Implement the AND operation in the ALU\\n# The AND operation is c = a & b\\n\\n# Modified Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a & b;\\n#endmodule\\n\\n# End Verilog Code\\n\\n# 7. \\n# Base Verilog Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a + b;\\n#endmodule\\n\\n# Variation Instruction:\\n# Implement the OR operation in the ALU\\n# The OR operation is c = a | b\\n\\n# Modified Code:\\n#module Problem1(input [3:0] a, b, output [3:0] c);\\n#  assign c = a | b;\\n#endmodule\\n\\n# End Verilog Code\\n\\n# 8"
"10","0","FAIL","0","Change the type of the output cout from wire to logic\\n### Riscy-Core with Verilator:\\n```\\n#source /home/kay/work/riscv-verilator/env.sh\\n#cd /home/kay/work/riscy/riscy-core/src/test\\n#make\\nVerilator_DIR=/home/kay/work/riscv-verilator/install/share/verilator\\nVPI_DIR=/home/kay/work/riscy-vhdl/riscy-vpi/src/lib\\nVERILATOR_ROOT=/home/kay/work/riscy-vhdl/riscy-vhdl/src/test_bench/verilator\\nverilator tst_alu4.v -CFLAGS ""-I$VERILATOR_ROOT -g"" -LDFLAGS ""-I$VERILATOR_ROOT -g"" -CFLAGS ""-I$VPI_DIR/vpi_dpi ""\\nverilator_main=tst_alu4_tb\\nverilator_top=tst_alu4\\n\\nverilator --trace --cc -CFLAGS ""-I$VERILATOR_ROOT -g"" -LDFLAGS ""-I$VERILATOR_ROOT -g"" -CFLAGS ""-I$VPI_DIR/vpi_dpi "" tst_alu4.v -CFLAGS ""-I$VERILATOR_ROOT -g"" -LDFLAGS ""-I$VERILATOR_ROOT -g"" -CFLAGS ""-I$VPI_DIR/vpi_dpi "" -LDFLAGS ""-lvpi -L/usr/local/lib -L/home/kay/work/riscy-vhdl/riscy-vpi/src/lib -L/home/kay/work/riscy-vhdl/riscy-vpi/src/lib/vpi_dpi"" -LDFLAGS ""-lverilated -lverilated_vpi -lpthread\\n```\\n### Run Results:\\nAfter running, the output is as follows:  \\n```\\n$./simv\\nBuild Time: 217.98 ms\\n[197] cci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: warning: unterminated code block\\n        else {\\n        ^\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\work\\riscy\\riscy-core\\src\\test_bench\\verilator\\tst_alu4.cpp: 107-109: error: expected statement\\nC:\\Users\\Kay\\"
"10","1","FAIL","0","#### Testbench:\\nTest all the 32 combinatorial paths of the ALU4.\\n#### ALU4:\\nTest all the 32 combinatorial paths of the ALU4."
"10","2","FAIL","0","```\\nmodule tst_alu4();\\n  reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; logic co;\\n  alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU\\n  initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop\\n  always begin // Apply stimulus with #3 delay\\n  end\\n  initial $monitor($time, "" cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b "",cci,a,b,f,d,co); // Use %h\\nendmodule\\n```\\n### Expected Output:\\n```\\ncci = 1'b0, a= 0'h0,b = 0'h0,f = 0'b0,d =0'h0,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b0,d =0'h0,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b0,d =0'h0,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b0,d =0'h0,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b0,d =0'h0,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b0,d =0'h0,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h0,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 0'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1111,co= 1'b0 \\ncci = 1'b1, a= 0'h0,b = 0'h0,f = 0'b1,d =4'h1110,co= 1'b0 \\ncci ="
"10","3","FAIL","0","```verilog\\nmodule tst_alu4();\\n  reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;\\n  alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU\\n  initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop\\n  always begin // Apply stimulus with #3 delay\\n  end\\n  initial $monitor($time, "" cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b "",cci,a,b,f,d,co); // Use %h\\nendmodule\\n```\\n## Result:\\n![alu_out3.png](https://i.loli"
"10","4","FAIL","0","```\\nmodule tst_alu4_wire2logic();\\n  logic [3:0]a,b; logic[1:0] f; logic cci; reg [3:0]d; reg co;\\n  alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU\\n```\\n/src/main/java/com/mycompany/test/ALU_4_Controller_TB.java\\n/*\\n * To change this license header, choose License Headers in Project Properties.\\n * To change this template file, choose Tools | Templates\\n * and open the template in the editor.\\n */\\npackage com.mycompany.test;\\n\\nimport alu_4.ALU_4;\\n\\n/**\\n *\\n * @author Shruti\\n */\\npublic class ALU_4_Controller_TB {\\n\\n    public static void main(String[] args) {\\n        ALU_4 alu4 = new ALU_4();\\n        for (int i = 0; i < 8; i++) {\\n            alu4.a = i;\\n            alu4.b = i;\\n            System.out.println(""a=""+alu4.a);\\n            System.out.println(""b=""+alu4.b);\\n            alu4.f = i;\\n            System.out.println(""f=""+alu4.f);\\n            System.out.println(""d=""+alu4.d);\\n            alu4.cci = 0;\\n            System.out.println(""cci=""+alu4.cci);\\n            System.out.println(""co=""+alu4.co);\\n        }\\n    }\\n}\\n/doc/README.txt\\n# ALU4\\nThe module alu_4.v is a 3-bit ALU with the following functionalities:\\n\\na.  Addition of two 3-bit values of two inputs.\\nb.  Subtraction of two 3-bit values of two inputs and then the 3-bit result is complemented.\\nc.  Shift of the input value.\\nd.  Shift of the input value and complement the input after shifting.\\n\\n\\n## Inputs\\n\\n![image] (https://github.com/ShrutiBajpai/ALU4/blob/master/doc/Inputs.png)\\n\\n## Outputs\\n![image] (https://github.com/ShrutiBajpai/ALU4/blob/master/doc/Outputs.png)\\n/src/main/java/com/mycompany/test/ALU_4_Controller_TB_logic2wire.java\\n/*\\n * To change this license header, choose License Headers in Project Properties.\\n * To change this template file, choose Tools | Templates\\n * and open the template in the editor.\\n */\\npackage com.mycompany.test;\\n\\nimport alu_4.ALU_4;\\n\\n/**\\n *\\n * @author Shruti\\n */\\npublic class ALU_4_Controller_TB_logic2wire {\\n\\n    public static void main(String[] args) {\\n        ALU_4 alu4 = new ALU_4();\\n        for (int i = 0; i < 8; i++) {\\n            alu4.a = i;\\n            alu4.b = i;\\n            System.out.println(""a=""+alu4.a);\\n            System.out.println(""b=""+alu4.b);\\n            alu4.f = i;\\n            System.out.println(""f=""+alu4.f);\\n            alu4.cci = 0;\\n            System.out.println(""cci=""+alu4.cci);\\n            System.out.println(""co=""+alu4.co);\\n        }\\n    }\\n}\\n/doc/alu_4_wire2logic/README.md\\n# TestBench of ALU_4 with wire as output for logic\\n\\n## Base Verilog Code:\\n```\\nmodule tst_alu4_wire2logic();\\n  logic [3:0]a,b; logic[1:0] f; logic cci; reg [3:0]d; reg co;\\n  alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU\\n  initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop\\n  always begin // Apply stimulus with #3 delay\\n  end\\n  initial $monitor($time, "" cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b "",cci,a,b,f,d,co); // Use %h\\nendmodule\\n```\\n## Variation Instruction: \\nChange the type of the output cout from wire to logic to test logic-vector compatibility."
"11","0","FAIL","0","```\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\n// DataComponent Module\\nstruct DataStruct {\\nrand 1'b0 DataOutData;\\n} DataConstruct;\\n\\nalways@(posedge ControlSignals) begin\\ncase (ControlSignals)\\n// Read\\n2'b00: begin\\nbegin\\nDataConstruct.DataOutData <= DataIn;\\nend\\n// Write\\n2'b01: begin\\nbegin\\nDataOut <= DataConstruct.DataOutData;\\nend\\n2'b10: DataConstruct.DataOutData <= DataIn;\\n2'b11: DataConstruct.DataOutData <= DataIn;\\ndefault: $fatal(0,0,""Unknown control signal input."");\\nendcase\\nend\\nendmodule\\n```\\n### Comments:\\nNo change in behavior.\\n/_posts/2020-03-15-verilog-randomizing-control-signals.md\\n---\\ntitle: Verilog: Randomizing Control Signals\\nlayout: post\\ndescription: How to randomizing control signals inside structs in verilog.\\ncategory: verilog\\ntags: [verilog, randomization]\\n---\\n\\n<iframe height=""480"" width=""640"" src=""https://www.youtube.com/embed/hH1y16m2-dU?rel=0"" frameborder=""0"" allowfullscreen></iframe>\\n\\n<div align=""center""><strong>This is a video tutorial on how to randomizing control signals inside structures in verilog.</strong></div>\\n\\nVerilog is a hardware description language (HDL) used in a field known as FPGA, but it can be also used for other platforms, like CPUs or microcontrollers (MC).\\n\\nIn FPGAs, where the majority of the software is programmed for the logic, you will find a lot of randomization inside the code, but there is a way to randomize control signals inside the code.\\n\\nThis can be done through struct, for a short explanation on structs and how to use them in the next article:\\n[Verilog: Structs](../2019/12/01/verilog-structs.html)\\n\\nIn this article I will explain how to randomize control signals inside a struct.\\n\\n## Basic Code\\n\\n```\\n### Basic Verilog Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n```\\n\\n## Variation Instruction\\nReplace the data construct with a struct containing a rand member to test randomization inside a structure.\\n\\n## Modified Code\\n```\\n### Modified Verilog Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\n// DataComponent Module\\nstruct DataStruct {\\nrand 1'b0 DataOutData;\\n} DataConstruct;\\n\\nalways@(posedge ControlSignals) begin\\ncase (ControlSignals)\\n// Read\\n2'b00: begin\\nbegin\\nDataConstruct.DataOutData <= DataIn;\\nend\\n// Write\\n2'b01: begin\\nbegin\\nDataOut <= DataConstruct.DataOutData;\\nend\\n2'b10: DataConstruct.DataOutData <= DataIn;\\n2'b11: DataConstruct.DataOutData <= DataIn;\\ndefault: $fatal(0,0,""Unknown control signal input."");\\nendcase\\nend\\nendmodule\\n```\\n\\n## Comments\\nNo change in behavior.\\n/_posts/2020-02-17-verilog-if-else-statement-and-case-statement.md\\n---\\ntitle: Verilog: If/Else statement and Case statement\\nlayout: post\\ndescription: How to use the if-else and case statements in verilog\\ncategory: verilog\\ntags: [verilog, if-else, case]\\n---\\n\\n<iframe height=""480"" width=""640"" src=""https://www.youtube.com/embed/r67p5p16u6o?rel=0"" frameborder=""0"" allowfullscreen></iframe>\\n\\n<div align=""center""><strong>This is a video tutorial on how to use the if-else and case statements in verilog.</strong></div>\\n\\nVerilog is a hardware description language (HDL) used in a field known as FPGA, but it can be also used for other platforms, like CPUs or microcontrollers (MC).\\n\\nIn this article I will explain how to use the if-else and case statements.\\n\\n## Basic Code\\n```\\n### Basic Verilog Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n```\\n\\n## Variation Instruction\\nReplace the data construct with an if-else or case statement to test the behavior of an if-else or case statement.\\n\\n## Modified Code\\n```\\n### Modified Verilog Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\n// DataComponent Module\\nalways@(posedge ControlSignals) begin\\ncase (ControlSignals)\\n// Read\\n2'b00: begin\\nbegin\\nDataOut <= DataIn;\\nend\\n// Write\\n2'b01: begin\\nbegin\\nDataOut <= DataIn;\\nend\\n2'b10: begin\\nbegin\\nDataOut <= DataIn;\\nend\\n2'b11: begin\\nbegin\\nDataOut <= DataIn;\\nend\\ndefault: $fatal(0,0,""Unknown control signal input."");\\nendcase\\nend\\nendmodule\\n```\\n\\n## Comments\\nNo change in behavior.\\n/_posts/2020-06-04-verilog-synchronous-verilog-code.md\\n---\\ntitle: Verilog: Synchronous Verilog Code\\nlayout: post\\ndescription: This article explains the difference between synchronous and asynchronous verilog code.\\ncategory: verilog\\ntags: [verilog, synchronous, asynchronous]\\n---\\n\\n<iframe height=""480"" width=""640"" src=""https://www.youtube.com/embed/a6uC1L96eL8?rel=0"" frameborder=""0"" allowfullscreen></iframe>\\n\\n<div align=""center""><strong>This is a video tutorial on how to synchronous verilog code.</strong></div>\\n\\nVerilog is a hardware description language (HDL) used in a field known as FPGA, but it can be also used for other platforms, like CPUs or microcontrollers (MC).\\n\\nIn this article I will explain how synchronous verilog code works in different cases.\\n\\n## Basic Code\\n\\n### Verilog-2001\\n\\n```\\n### Basic Verilog Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n```\\n\\n### Verilog-2001-Style\\n\\n```\\n### Basic Verilog Code:\\n// DataComponent Module\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\n// DataComponent Module\\nalways@(posedge ControlSignals) begin\\ncase (ControlSignals)\\n// Read\\n2'b00: begin\\nbegin\\nDataOut <= DataIn;\\nend\\n// Write\\n2'b01: begin\\nbegin\\nDataOut <= DataIn;\\nend\\n2'b10: begin\\nbegin\\nDataOut <= DataIn;\\nend\\n2'b11: begin\\nbegin\\nDataOut <= DataIn;\\nend\\ndefault: $fatal(0,0,""Unknown control signal input."");\\nendcase\\nend\\nendmodule\\n```\\n\\n## Variation Instruction\\nReplace the code with an synchronous code.\\n\\n## Modified Code\\n\\n### Verilog-2001\\n\\n```\\n### Modified Verilog Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n```\\n\\n### Verilog-2001-Style\\n\\n```\\n### Modified Verilog Code:\\n// DataComponent Module\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\n// DataComponent Module\\nalways@(ControlSignals) begin\\nDataOut <= DataIn;\\nendmodule\\n```\\n\\n## Comments\\nVerilog-2001 is synchronous because it has a always block which is evaluated only when ControlSignals is changed.\\n\\nVerilog-2001-Style is synchronous because it has a always block which is evaluated only when ControlSignals is changed."
"11","1","FAIL","0","```verilog\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\n//Added by \\nreg [15:0] Data;\\n\\nalways @(posedge DataIn)\\nbegin\\n	begin \\n		Data <= DataIn;\\n	end\\nend\\n\\nassign DataOut = Data;\\nendmodule\\n```\\n### Testbench:\\n```verilog\\nmodule testbench_main();\\nreg [7:0] DataIn;\\nwire [7:0] DataOut;\\nwire ControlSignals;\\n\\nDataComponent DUT(.DataIn(DataIn),.DataOut(DataOut),.ControlSignals(ControlSignals));\\n\\n\\ninitial begin\\n	$dumpfile(""dump_file.vcd"");\\n	$dumpvars(0,testbench_main);\\n	DataIn = 12;\\n	ControlSignals = 8'b00000000;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 13;\\n	ControlSignals = 8'b00000001;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 14;\\n	ControlSignals = 8'b00000010;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 15;\\n	ControlSignals = 8'b00000011;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 16;\\n	ControlSignals = 8'b00000100;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 17;\\n	ControlSignals = 8'b00000101;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 18;\\n	ControlSignals = 8'b00000110;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 19;\\n	ControlSignals = 8'b00000111;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 20;\\n	ControlSignals = 8'b00001000;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 35;\\n	ControlSignals = 8'b11111111;\\n	$dumpvars(1,testbench_main);\\n	DataIn = 36;\\n	ControlSignals = 8'b00000000;\\n	$dumpvars(1,testbench_main);\\n\\nend\\ninitial \\nbegin\\n	$finish;\\nend\\nendmodule\\n```\\n### Verification Output:\\nThe output from the above code is:\\n![Verify](https://github.com/cse237-fall2019-group10/cse237-fall2019-group10/blob/master/Lab%203/images/Verilog%20Verification%20Output%20%28Rand%20Randomization%29.PNG)\\n/Lab 4/Lab4/main.c\\n#include <stdio.h>\\n\\nint main()\\n{\\n    printf(""Hello from lab4\\n"");\\n\\n    printf(""Add 1 to a number:\\n"");\\n    int a = 1;\\n    int b = a + 1;\\n    printf(""%d\\n"", b);\\n\\n    printf(""Divide by 2 the number b:\\n"");\\n    b = b / 2;\\n    printf(""%d\\n"", b);\\n\\n    printf(""Add 1 to a number:\\n"");\\n    a = a + 1;\\n    printf(""%d\\n"", a);\\n\\n    printf(""Add 1 to a number:\\n"");\\n    a = a + 1;\\n    printf(""%d\\n"", a);\\n\\n    printf(""Add 1 to a number:\\n"");\\n    a = a + 1;\\n    printf(""%d\\n"", a);\\n\\n    return 0;\\n}/Lab 6/Lab6/Lab6.c\\n#include<stdio.h>\\n\\n//global variables\\nint a = 0;\\nint b = 0;\\n\\n//function definition\\nint function(int, int);\\n\\n//main function - entry point\\nint main()\\n{\\n    printf(""a is %d\\n"", a);\\n    printf(""b is %d\\n"", b);\\n    int c = 3;\\n    int d = 4;\\n    int f = c % d;\\n    printf(""Remainder of %d modulo %d is %d\\n"", c, d, f);\\n    f = 4 % 3;\\n    printf(""Remainder of %d modulo %d is %d\\n"", 4, 3, f);\\n\\n    int ans = function(a, b);\\n    printf(""Returned answer is %d\\n"", ans);\\n\\n    c = 3;\\n    d = 3;\\n    ans = function(c, d);\\n    printf(""Returned answer is %d\\n"
"11","2","FAIL","0","module DataComponent (DataIn, DataOut, ControlSignals);\\nstruct Data {\\nrand DataIn, DataOut;\\n};\\ntypedef struct Data Data;\\nData Data_Inst;\\nendmodule\\n\\n**3.2.1.2**\\n\\n**Original Code**\\n\\nmodule ShiftComponent (Data, Out, Shift, ControlSignals);\\ninput [7:0] Data;\\noutput [7:0] Out;\\ninput Shift;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.1.3**\\n\\n**Original Code**\\n\\nmodule BufferComponent (DataIn, DataOut, ControlSignals);\\ninput DataIn;\\noutput DataOut;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.1.4**\\n\\n**Original Code**\\n\\nmodule ALU (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.2**\\n\\n**3.2.2.1**\\n\\n**Original Verilog code**\\n\\nmodule BufferComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.2.2**\\n\\n**Original Verilog code**\\n\\nmodule ShiftComponent (Data, Out, Shift, ControlSignals);\\ninput [7:0] Data;\\noutput [7:0] Out;\\ninput Shift;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.2.3**\\n\\n**Original Verilog code**\\n\\nmodule AddComponent (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.2.4**\\n\\n**Original Verilog code**\\n\\nmodule ALU (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.3**\\n\\n**3.2.3.1**\\n\\n**Original Verilog code**\\n\\nmodule ShiftComponent (Data, Out, Shift, ControlSignals);\\ninput [7:0] Data;\\noutput [7:0] Out;\\ninput Shift;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.3.2**\\n\\n**Original Verilog code**\\n\\nmodule AddComponent (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.3.3**\\n\\n**Original Verilog code**\\n\\nmodule ALU (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.3.4**\\n\\n**Original Verilog code**\\n\\nmodule BufferComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.4**\\n\\n**3.2.4.1**\\n\\n**Original Verilog code**\\n\\nmodule ShiftComponent (Data, Out, Shift, ControlSignals);\\ninput [7:0] Data;\\noutput [7:0] Out;\\ninput Shift;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.4.2**\\n\\n**Original Verilog code**\\n\\nmodule AddComponent (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.4.3**\\n\\n**Original Verilog code**\\n\\nmodule BufferComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.4.4**\\n\\n**Original Verilog code**\\n\\nmodule ALU (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.5**\\n\\n**3.2.5.1**\\n\\n**Original Verilog code**\\n\\nmodule AddComponent (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.5.2**\\n\\n**Original Verilog code**\\n\\nmodule ShiftComponent (Data, Out, Shift, ControlSignals);\\ninput [7:0] Data;\\noutput [7:0] Out;\\ninput Shift;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.5.3**\\n\\n**Original Verilog code**\\n\\nmodule BufferComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.5.4**\\n\\n**Original Verilog code**\\n\\nmodule ALU (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.6**\\n\\n**3.2.6.1**\\n\\n**Original Verilog code**\\n\\nmodule ShiftComponent (Data, Out, Shift, ControlSignals);\\ninput [7:0] Data;\\noutput [7:0] Out;\\ninput Shift;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.6.2**\\n\\n**Original Verilog code**\\n\\nmodule BufferComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.6.3**\\n\\n**Original Verilog code**\\n\\nmodule AddComponent (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.2.6.4**\\n\\n**Original Verilog code**\\n\\nmodule ALU (DataInA, DataInB, OperandA, OperandB, Result, ControlSignals);\\ninput [7:0] DataInA;\\ninput [7:0] DataInB;\\ninput [4:0] OperandA;\\ninput [4:0] OperandB;\\noutput [7:0] Result;\\ninput ControlSignals;\\nendmodule\\n\\n**3.3**\\n\\n**3.3.1**\\n\\n**3.3.1.1**\\n\\n**Original Verilog code**\\n\\nmodule ShiftComponent (Data,"
"11","3","FAIL","0","module DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\nstruct data {\\nrand bit rand_data;\\n} data_in;\\n\\nendmodule\\n\\n## 5.6.5. Verilog Testbench\\n\\nThe testbench tests the behavior of a module (or a sub-module) with the input signals given. The testbench must match the module input/output signals exactly; otherwise, the testbench will not be able to check the correctness of the module. The testbench is executed using the vsim command.\\n\\n### Verilog Testbench Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\nendmodule\\n### Testbench Code:\\nmodule TB_DataComp (CLK, DataIn, DataOut, ControlSignals);\\nreg CLK = 0;\\nreg [7:0] DataIn;\\nreg [7:0] DataOut;\\nreg ControlSignals;\\nreg done = 0;\\n\\ninitial begin\\n#10 CLK = 1;\\n#10 CLK = 0;\\n#10 done = 1;\\n#10 CLK = 0;\\n#10 CLK = 1;\\n#10 DataIn = 56;\\n#10 ControlSignals = 1;\\n#10 DataOut = 0;\\nend\\n\\nalways #10 CLK = ~CLK;\\n\\nendmodule\\n\\n### Simulation Run Command:\\n> vsim TB_DataComp\\n\\n## 5.6.6. Procedural Simulation\\n\\nA procedural simulation is a program that takes an initial state as input and prints the state of the system after the defined number of time steps.\\n\\n### Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\nreg [7:0] data;\\nreg done = 0;\\n\\nalways begin\\nif (ControlSignals == 1) begin\\ndata = DataIn;\\ndone = 1;\\nend\\nend\\nalways @(posedge clk) begin\\nDataOut <= data;\\nend\\n\\nendmodule\\n\\n### Simulation Command:\\n>./procedural 10000 56\\n### Input:\\n0 1 0 0 0 0 0 0\\n### Output:\\n56 56 56 56 56 56 56 56\\n\\n## 5.6.7. Parameterized Simulation\\n\\nSimulate the component with 10,000 time steps and the input of 56.\\n\\n### Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\nreg [7:0] data;\\nreg done = 0;\\n\\nalways begin\\nif (ControlSignals == 1) begin\\ndata = DataIn;\\ndone = 1;\\nend\\nend\\nalways @(posedge clk) begin\\nDataOut <= data;\\nend\\n\\nendmodule\\n\\n### Simulation Command:\\n>./procedural 10000 56 50\\n### Input:\\n0 1 0 0 0 0 0 0\\n### Output:\\n56 56 56 56 56 56 56 56\\n\\n## 5.6.8. Behavioral Simulation\\n\\nBehavioral simulation is the simulation within a single time step. The simulation time step is determined by the simulation speed (in ns)\\n\\n### Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\nreg [7:0] data;\\nreg done = 0;\\n\\nalways begin\\nif (ControlSignals == 1) begin\\ndata = DataIn;\\ndone = 1;\\nend\\nend\\nalways @(posedge clk) begin\\nDataOut <= data;\\nend\\n\\nendmodule\\n\\n### Simulation Command:\\n>./procedural 1 0 100\\n### Input:\\n0 1 0 0 0 0 0 0\\n### Output:\\n0 0 0 0 0 0 0 0\\n\\n## 5.6.9. Modelsim Simulation\\n\\n### Verilog Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\nreg [7:0] data;\\nreg done = 0;\\n\\nalways begin\\nif (ControlSignals == 1) begin\\ndata = DataIn;\\ndone = 1;\\nend\\nend\\nalways @(posedge clk) begin\\nDataOut <= data;\\nend\\n\\nendmodule\\n### Verilog Testbench Code:\\nmodule TB_DataComp (CLK, DataIn, DataOut, ControlSignals);\\nreg CLK = 0;\\nreg [7:0] DataIn;\\nreg [7:0] DataOut;\\nreg ControlSignals;\\nreg done = 0;\\n\\ninitial begin\\n#10 CLK = 1;\\n#10 CLK = 0;\\n#10 done = 1;\\n#10 CLK = 0;\\n#10 CLK = 1;\\n#10 DataIn = 56;\\n#10 ControlSignals = 1;\\n#10 DataOut = 0;\\nend\\n\\nalways #10 CLK = ~CLK;\\n\\nendmodule\\n### Modelsim Simulation Command:\\n> vsim -c TB_DataComp\\n\\n## 5.7. Testing Components\\n\\n### 5.7.1. Functional Testing:\\n\\nFunctional testing is the process of validating the output produced from a component against the expected output.\\n\\nFunctional testing is a type of testing in which a program is used to test the output of a system during the normal operation of the system. The most common form of functional testing is to simulate the program.\\n\\nFor example:\\n\\n An LED is connected to a GPIO pin and the GPIO pin is connected to the input of a 7-segment display.\\n\\n The GPIO pin is set to 1 and the 7-segment display is expected to display the number 7.\\n\\nTo perform functional testing, the component is simulated with the correct input signals and the outputs are compared against the expected outputs.\\n\\n## 5.7.1.1. Functional Testing\\n\\n### 5.7.1.1.1. Functional Testing Example:\\n\\nFunctional testing for the 7-segment display is performed with the following test cases:\\n\\nInput Expected Output\\n1 1\\n9 9\\n11 1\\n12 2\\n14 4\\n16 6\\n18 8\\n\\n\\n### 5.7.1.1.2. Testing the 7-segment Display in Verilog\\n\\n### Verilog Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\nreg [7:0] data;\\nreg done = 0;\\n\\nalways begin\\nif (ControlSignals == 1) begin\\ndata = DataIn;\\ndone = 1;\\nend\\nend\\nalways @(posedge clk) begin\\nDataOut <= data;\\nend\\n\\nendmodule\\n### Testbench Code:\\nmodule TB_DataComp (CLK, DataIn, DataOut, ControlSignals);\\nreg CLK = 0;\\nreg [7:0] DataIn;\\nreg [7:0] DataOut;\\nreg ControlSignals;\\nreg done = 0;\\n\\ninitial begin\\n#10 CLK = 1;\\n#10 CLK = 0;\\n#10 done = 1;\\n#10 CLK = 0;\\n#10 CLK = 1;\\n#10 DataIn = 56;\\n#10 ControlSignals = 1;\\n#10 DataOut = 0;\\nend\\n\\nalways #10 CLK = ~CLK;\\n\\nendmodule\\n### Simulation Command:\\n> vsim -c TB_DataComp\\n\\n## 5.7.1.2. Functional Testing\\n\\n### 5.7.1.2.1. Functional Testing Example:\\n\\nA test for the 7-segment display is created. The component is simulated with different data and control signals to see which configuration produces the expected output.\\n\\n### Verilog Code:\\nmodule DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\nreg [7:0] data;\\nreg"
"11","4","FAIL","0","module DataComponent (DataIn, DataOut, ControlSignals);\\ninput [7:0] DataIn;\\noutput [7:0] DataOut;\\ninput ControlSignals;\\n\\nstruct DataComponentStruct;\\nDataComponentStruct dcs;\\n\\ninitial begin\\ndcs.rand = $urandom;\\nend\\n\\nendmodule\\n### Test Case:\\nTest case will be created by creating a test bench and simulating it, with the modified data component struct. Test case will test the randomization of the rand member of the struct.\\n### Results:\\nThe results of the simulation can be seen in the attached file.\\nOutput of the simulation:\\n![image](https://user-images.githubusercontent.com/43009620/65621978-1bb8ed80-df76-11e9-80ab-0c61d196509b.png)\\n/Projects/Project1/README.md\\nThis project uses the MIPS architecture, and includes instructions for the following:\\n * ADD\\n * SUB\\n * MULT\\n * DIV\\n * BEQ\\n * BNE\\n * JR\\n * J\\n * LW\\n * SW\\n\\nThe programs for these instructions are in the.s file, and the output of these programs is printed via the MIPS terminal.\\n/Projects/Project4/README.md\\nThis project will contain the following:\\n * C++ code that will be stored in the cpp file\\n * Verilog code that will be stored in the v file\\n * The test bench for testing, stored in the v file\\n * The module that will be compiled into the test bench, stored in the cpp file\\n * A Makefile\\n\\n\\n# How to run the Project:\\n1. Clone the repository on to your machine\\n2. Create a new folder on your machine called Simulation\\n3. Go to the Simulation folder\\n4. Create a new folder called C++Codes\\n5. Inside C++, create a new file called cppCode.cpp\\n6. Copy the verilog code from the verilog file into the cpp file\\n7. In the cpp code, add the following:\\n\\n```c\\n#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main(int argc, char *argv[]){\\n	...\\n}\\n```\\n\\n8. In the cpp file, compile the cpp code with the following commands:\\n\\n```bash\\ncd C++Codes\\ng++ cppCode.cpp\\n```\\n\\n9. Inside the Simulation folder, run the following command:\\n\\n```bash\\nmake\\n```\\n\\n10. To run the simulation, run the following command:\\n\\n```bash\\nmake run\\n```\\n\\n11. Alternatively, you can create a makefile that runs the program for you, with the following commands:\\n\\n```bash\\nmake clean\\nmake all\\nmake run\\n```\\n\\n10. To view the output from the simulation, open the ouput.txt file\\n/Projects/Project4/simulation/C++Codes/cppCode.cpp\\n#include <iostream>\\n#include <string>\\n#include ""cpp_test.h""\\n\\nusing namespace std;\\n\\nint main(int argc, char *argv[]){\\n	int arr[20];\\n	int count = 0;\\n\\n	while(true){\\n		cout << ""\\nPlease input a number: "";\\n		cin >> arr[count];\\n\\n		if(arr[count] >= 33 && arr[count] <= 126){\\n			count++;\\n		}else{\\n			break;\\n		}\\n	}\\n\\n	cout << ""\\nThe numbers in the array are: "";\\n	for(int i = 0; i < count; i++){\\n		cout << arr[i] << "" "";\\n	}\\n\\n	std::cout << std::endl;\\n\\n	return 0;\\n}\\n/Projects/Project4/simulation/C++Codes/cpp_test.h\\n#ifndef CPP_TEST_H\\n#define CPP_TEST_H\\n\\nint arr[20];\\nint count = 0;\\n\\nwhile(true){\\n	cout << ""\\nPlease input a number: "";\\n	cin >> arr[count];\\n\\n	if(arr[count] >= 33 && arr[count] <= 126){\\n		count++;\\n	}else{\\n		break;\\n	}\\n}\\n\\ncout << ""\\nThe numbers in the array are: "";\\nfor(int i = 0; i < count; i++){\\n	cout << arr[i] << "" "";\\n}\\n\\nstd::cout << std::endl;\\n\\n#endif\\n/Projects/Project4/simulation/sim.sh\\n#!/bin/bash\\ncd C++Codes\\ng++ cppCode.cpp\\ncd..\\nmake\\ncd simulation\\nmake run\\n/Projects/Project3/README.md\\nThis project will contain the following:\\n * C++ code that will be stored in the cpp file\\n * Verilog code that will be stored in the v file\\n * The test bench for testing, stored in the v file\\n * The module that will be compiled into the test bench, stored in the cpp file\\n * A Makefile\\n\\n# How to run the Project:\\n1. Clone the repository on to your machine\\n2. Create a new folder on your machine called Simulation\\n3. Go to the Simulation folder\\n4. Create a new folder called C++Codes\\n5. Inside C++, create a new file called cppCode.cpp\\n6. Copy the verilog code from the verilog file into the cpp file\\n7. In the cpp code, add the following:\\n```c\\n#include <string>\\n\\nint main(int argc, char *argv[]){\\n	std::string name;\\n	std::cout << ""\\nPlease enter your name: "";\\n	std::cin >> name;\\n	\\n	std::cout << ""\\nHello "" << name << ""!"" << std::endl;\\n	\\n	return 0;\\n}\\n```\\n8. In the cpp file, compile the cpp code with the following commands:\\n```bash\\ncd C++Codes\\ng++ cppCode.cpp\\n```\\n9. Inside the Simulation folder, run the following command:\\n```bash\\nmake\\n```\\n10. To run the simulation, run the following command:\\n```bash\\nmake run\\n```\\n11. Alternatively, you can create a makefile that runs the program for you, with the following commands:\\n```bash\\nmake clean\\nmake all\\nmake run\\n```\\n10. To view the output from the simulation, open the ouput.txt file\\n/Projects/Project4/simulation/cpp_test.h\\n#ifndef CPP_TEST_H\\n#define CPP_TEST_H\\n\\nint arr[20];\\nint count = 0;\\n\\nwhile(true){\\n	cout << ""\\nPlease input a number: "";\\n	cin >> arr[count];\\n\\n	if(arr[count] >= 33 && arr[count] <= 126){\\n		count++;\\n	}else{\\n		break;\\n	}\\n}\\n\\ncout << ""\\nThe numbers in the array are: "";\\nfor(int i = 0; i < count; i++){\\n	cout << arr[i] << "" "";\\n}\\n\\nstd::cout << std::endl;\\n\\n#endif\\n/Projects/Project4/simulation/Makefile\\nCXX=g++\\nCXXFLAGS=-Wall -O -g\\n\\nCPP=cpp_test.cpp\\n\\nall:\\n	$(CXX) $(CXXFLAGS) $(CPP)\\n\\nrun:\\n	./a.out\\n\\nclean:\\n	rm -f *.out"
"12","0","FAIL","0","module Problem1(input [3:0]  a, b, output [3:0] sum);\\n  logic [3:0]   di, clk,  sum;\\nendmodule\\n### Simulation Results:\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b1010;\\n    b = 4'b1010;\\n    #1;\\n    a = 4'b1111;\\n    b = 4'b1111;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1a.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'd0;\\n    b = 4'd1;\\n    #1;\\n    a = 4'd3;\\n    b = 4'd2;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1b.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1c.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1d.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1e.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1f.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0000;\\n    b = 4'b0000;\\n    #1;\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1g.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    a = 4'b0010;\\n    b = 4'b1100;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1h.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    a = 4'b0010;\\n    b = 4'b1100;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1i.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    a = 4'b0010;\\n    b = 4'b1100;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1j.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    a = 4'b0010;\\n    b = 4'b1100;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1k.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b0001;\\n    b = 4'b1010;\\n    #1;\\n    a = 4'b0010;\\n    b = 4'b1100;\\n    #1;\\n    $finish;\\n  end\\nendmodule\\n### Results:\\n\\n![alt text](images/Problem_1l.png ""Results"")\\n\\n##### Testbench Code:\\nmodule tb;\\n  reg [3:0] a, b, sum;\\n  Problem1 DUT(.a(a),.b(b),.sum(sum));\\n  initial begin\\n    a = 4'b1111;\\n    b = 4'b1111;\\n    #1;\\n    a = 4'b1111;\\n    b = 4'b1111;\\n    #1;\\n    a = 4'b1111;\\n    b = 4'b1111;\\n    #1;\\n    a = 4'b0001"
"12","1","FAIL","0","```verilog\\nmodule Problem1(input [3:0] a, b, output [3:0] sum);\\n  logic [3:0] sum;\\n  always @ (posedge clk) begin\\n    sum <= (a + b);\\n  end\\nendmodule\\n```\\n/Practice/2016-2017/2/2016-212.c\\n#include <stdio.h>\\n\\nint gcd(int a, int b) {\\n  if (b == 0) return a;\\n  return gcd(b, a % b);\\n}\\n\\nint main() {\\n  int a, b;\\n  scanf(""%d"", &a);\\n  scanf(""%d"", &b);\\n  printf(""%d"", gcd(a, b));\\n  return 0;\\n}\\n\\nint gcd_iterative(int a, int b) {\\n  // Find the smaller in a and b to reduce the complexity of the loop\\n  int min = a;\\n  if (a > b) {\\n    min = b;\\n  }\\n\\n  int i;\\n  for (i = 2; i <= min; b);\\n}\\ni++) {\\n    if ((a % i == 0) && (b % i == 0)) {\\n      return i;\\n    }\\n  }\\n  return 1;\\n}\\n\\nint main_iterative() {\\n  int a, b;\\n  scanf(""%d"", &a);\\n  scanf(""%d"", &b);\\n  printf(""%d"", gcd_iterative(a, /Practice/2016-2017/2/2016-219.c\\n#include <stdio.h>\\n\\nint main() {\\n  int a, b, c;\\n  scanf(""%d"", &a);\\n  \\n  }\\n  return 0;\\n}\\nscanf(""%d"", &b);\\n  scanf(""%d"", &c);\\n  if (a + b + c == 180 && a == b && b == c) {\\n    printf(""Equilateral Triangle"");\\n  } else if (a + b + c == 180 && a == b || a + b + c == 180 && a == c || a + b + c == 180 && b == c) {\\n    printf(""Isosceles Triangle"");\\n  } else {\\n    printf(""Scalene Triangle"");/Practice/2016-2017/2/2016-210.c\\n#include <stdio.h>\\n\\nint main() {\\n  int a = 0;\\n  int b = 0;\\n  scanf(""%d"", &a);\\n  scanf(""%d"", &b);\\n  int sum = 0;\\n  int i = 0;\\n  for (i = 0; i <= b - a; i++) {\\n    sum += a + i;\\n  }\\n  printf(""%d"", sum);\\n  return 0;\\n}\\n/Practice/2016-2017/3/2016-301.c\\n#include <stdio.h>\\n\\nint main() {\\n  int a, b;\\n  scanf(""%d"", &a);\\n  scanf(""%d"", &b);\\n\\n  // If a is greater than b, swap values\\n  if (a > b) {\\n    int tmp = a;\\n    a = b;\\n    b = tmp;\\n  }\\n\\n  int tmp;\\n  if (b % 2 == 0) {\\n    tmp = b;\\n  } else if (b % 2!= 0) {\\n    tmp = b - 1;\\n  }\\n\\n  int j, k;\\n  int sum = 0;\\n  for (j = a; j <= tmp; j++) {\\n    if (j % 2!= 0) {\\n      sum += j;\\n    }\\n  }\\n  printf(""%d"", sum);\\n  return 0;\\n}\\n\\n};\\n\\n// Find the gcd of the numbers using a recursive helper function\\nint gcd(int a, int b) {\\n  return b? gcd(b, a % b) : a;\\n}\\n\\n// Divide the two inputted numbers and check for the gcd of the quotient\\nint main(int argc, char** argv) {\\n  int a, b;\\n  if (argc == 3) {\\n    a = atoi(argv[1]);\\n    b = atoi(argv[2]);\\n    printf(""%d"", gcd(a, b));\\n  } else {\\n    printf(""The input was invalid. Please try again."");\\n  }\\n}\\n/Practice/2016-2017/3/2016-304.c\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstruct node {\\n  int num;\\n  struct node* next;/Practice/2016-2017/4/2016-414.c\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nstruct node {\\n  int val;\\n  struct node* next;\\n};\\n\\nstruct list {\\n  struct node* head;\\n};\\n\\nstruct node* new_node(int val) {\\n  struct node* new;\\n  new = malloc(sizeof(struct node));\\n  new -> val = val;\\n  new -> next = NULL;\\n  return new;\\n}\\n\\nvoid push(struct list* list, int val) {\\n  struct node* new = new_node(val);\\n  new -> next = list -> head;\\n  list -> head = new;\\n}\\n\\nint check_palindrome(struct list* list) {\\n  // Declare a current, previous, and next node variable\\n  struct node* current = list -> head;\\n  struct node* prev = NULL;\\n  struct node* next = NULL;\\n\\n  // Iterate through each node in the list and assign the previous and next nodes accordingly.\\n  while (current!= NULL) {\\n    if (current -> next == NULL) {\\n      next = NULL;\\n    } else {\\n      next = current -> next;\\n    }\\n\\n    if (prev == NULL) {\\n      next = NULL;\\n    } else {\\n      prev -> next = next;\\n    }\\n\\n    current -> next = prev;\\n    prev = current;\\n    current = next;\\n  }\\n  // Store the head node reference\\n  current = list -> head;\\n  // Compare the current node to the previous node to determine if the list is a palindrome\\n  while (current!= NULL) {\\n    if (current -> val!= prev -> val) {\\n      return 0;\\n    }\\n    prev = prev -> next;\\n    current = current -> next;\\n  }\\n  return 1;\\n}\\n\\nint main() {\\n  struct list* list = malloc(sizeof(struct list));\\n  list -> head = NULL;\\n  char input[1024];\\n  fgets(input, sizeof(input), stdin);\\n  int i, j;\\n  for (i = 0; i < strlen(input); i++) {\\n    if (input[i]!= '\\n') {\\n      push(list, input[i]);\\n    }\\n  }\\n  printf(""%d"", check_palindrome(list));\\n  return 0;\\n}\\n/Practice/2016-2017/2/2016-204.c\\n#include <stdio.h>\\n\\nint main() {\\n  int a = 0;\\n  scanf(""%d"", &a);\\n  int i;\\n  for (i = 1; i <= 42; i++) {\\n    if (i % a == 0) {\\n      printf(""Yes"");\\n      return 0;\\n    }\\n  }\\n  printf(""No"");\\n  return 0;\\n}\\n/Practice/2016-2017/4/2016-405.c\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstruct node {\\n  int val;\\n  struct node* next;\\n};\\n\\nstruct list {\\n  struct node* head;\\n};\\n\\nstruct node* new_node(int val) {\\n  struct node* new;\\n  new = malloc(sizeof(struct node));\\n  new -> val = val;\\n  new -> next = NULL;\\n  return new;\\n}\\n\\nvoid push(struct list* list, int val) {\\n  struct node* new = new_node(\\n  struct node* current = list -> head;\\n  while (current!= NULL) {\\n    printf(""%d "", current -> val);\\n    current = current -> next;\\n  }\\n  return 0;\\n}\\nval);\\n  new -> next = list -> head;\\n  list -> head = new;\\n}\\n\\nvoid insert(struct list* list, int val) {\\n  int count = 0;\\n  struct node* current = list -> head;\\n  while (current!= NULL) {\\n    count++;\\n    current = current -> next;\\n  }\\n  // If there is only one element in the list, point the head node to the new node\\n  if (count == 1) {\\n    list -> head = new_node(val);\\n  } else {\\n    // Iterate through the list until the current node is the second to last node\\n    struct node* previous = list -> head;\\n    int i = 0;\\n    while (i < count - 2) {"
"12","2","FAIL","0","module Problem1(input [3:0] a, b, output [3:0] sum);\\n  logic [3:0] di;\\n  logic clk;\\n  assign sum = di;\\nendmodule\\n### Run Code:\\n```\\n%systemverilog -o Problem1 -Wno-fatal\\n%systemverilog -o Problem1\\n```\\n### Run Results:\\n```\\n%systemverilog -o Problem1 -Wno-fatal\\n%systemverilog -o Problem1\\n```\\n#!/bin/bash\\n\\necho ""---------------------------""\\necho ""---------------------------""\\necho ""Running all test cases in:""\\necho ""$PWD""\\necho ""---------------------------""\\necho ""---------------------------""\\n\\n# Check if sv2v is installed\\nif [ -x ""$(command -v sv2v)"" ]; then\\n  echo ""sv2v is executable""\\nelse\\n  echo ""sv2v is not installed, please install sv2v""\\n  echo ""https://github.com/ft4/sv2v""\\n  exit 1\\nfi\\n\\ntestCases=(""Problem1"" ""Problem2"" ""Problem3"" ""Problem4"" ""Problem5"")\\n\\nfor testCase in ""${testCases[@]}""\\ndo\\n  testDir=""${testCase}""\\n  if [ -d ""${testDir}"" ]; then\\n    echo ""---------------------------""\\n    echo ""---------------------------""\\n    echo ""Running test case: ${testCase}""\\n    echo ""---------------------------""\\n    echo ""---------------------------""\\n  else\\n    echo ""ERROR: directory '${testCase}' does not exist""\\n    exit 1\\n  fi\\n\\n  # Create sv output directory if it does not exist\\n  if [! -d ""${testCase}""/sv ]; then\\n    mkdir ""${testCase}""/sv\\n  fi\\n\\n  # Create v output directory if it does not exist\\n  if [! -d ""${testCase}""/v ]; then\\n    mkdir ""${testCase}""/v\\n  fi\\n\\n  # Convert verilog to sv\\n  sv2v -no-timescale -sv -tverilog ""${testCase}""/*.v -v2005 -o ""${testCase}""/sv/main.sv\\n\\n  # Run simulation\\n  vvp -t ""100ps"" -M ""${testCase}""/sv ""${testCase}""/sv/main.v\\ndone\\n#include <string>\\n\\nnamespace test {\\nnamespace verilog {\\n\\nvoid func(std::string s) {\\n  printf(""Hello from C++, s is %s\\n"", s);\\n}\\n\\n}  // namespace verilog\\n}  // namespace test#include <unistd.h>\\n#include <string>\\n\\n#include ""verilog_util.hpp""\\n\\nnamespace test {\\nnamespace verilog {\\n\\nvoid func(std::string s) {\\n  puts(s);\\n}\\n\\nint main() {\\n  std::string s = verilog::util::readFile(""./test/verilog/problem3/main.v"");\\n  if (!s.empty()) {\\n    func(s);\\n  } else {\\n    perror(""Failed to read file:./test/verilog/problem3/main.v"");\\n    return 1;\\n  }\\n\\n  return 0;\\n}\\n\\n}  // namespace verilog\\n}  // namespace test\\n#include <unistd.h>\\n#include <string>\\n\\n#include ""verilog_util.hpp""\\n\\nnamespace test {\\nnamespace verilog {\\n\\nvoid func(std::string s) {\\n  puts(s);\\n}\\n\\nint main() {\\n  std::string s = verilog::util::readFile(""./test/verilog/problem2/main.v"");\\n  if (!s.empty()) {\\n    func(s);\\n  } else {\\n    perror(""Failed to read file:./test/verilog/problem2/main.v"");\\n    return 1;\\n  }\\n\\n  return 0;\\n}\\n\\n}  // namespace verilog\\n}  // namespace test\\n#include <unistd.h>\\n#include <string>\\n\\n#include ""verilog_util.hpp""\\n\\nnamespace test {\\nnamespace verilog {\\nnamespace util {\\n\\nvoid func(std::string s) {\\n  puts(s);\\n}\\n\\n}  // namespace util\\n}  // namespace verilog\\n}  // namespace test\\n#include <unistd.h>\\n#include <string>\\n\\n#include ""verilog_util.hpp""\\n\\nnamespace test {\\nnamespace verilog {\\nnamespace util {\\n\\nstd::string readFile(std::string fileName) {\\n  std::string fileStr;\\n\\n  if (fileName.empty()) return """";\\n\\n  FILE *fp = fopen(fileName.c_str(), ""r"");\\n  if (NULL == fp) {\\n    perror(""Failed to open file"");\\n    return """";\\n  } else {\\n    char buffer[4096];\\n    buffer[sizeof(buffer) - 1] = '\\0';\\n    while (fgets(buffer, sizeof(buffer) - 1, fp)) {\\n      fileStr += buffer;\\n    }\\n    fclose(fp);\\n  }\\n  return fileStr;\\n}\\n\\n}  // namespace util\\n}  // namespace verilog\\n}  // namespace test\\n#\\n# File:   CMakeLists.txt\\n# Author: \\n#\\n\\n# Define the project name\\ncmake_minimum_required(VERSION 3.0)\\nproject(VerilogTests)\\n\\n# Define the language for this project\\nset(CMAKE_CXX_STANDARD 17)\\n\\n# Add the subdirectories\\nadd_subdirectory(""./test/verilog/problem1"")\\nadd_subdirectory(""./test/verilog/problem2"")\\nadd_subdirectory(""./test/verilog/problem3"")\\nadd_subdirectory(""./test/verilog/problem4"")\\nadd_subdirectory(""./test/verilog/problem5"")"
"12","3","FAIL","0","module Problem11(input logic [3:0] a, b, output logic [3:0] sum);\\n  logic [3:0] di, clk;\\n  assign sum = a + b;\\nendmodule\\n/3.0/HW3/HW3_B/src/problem3/main.cpp\\n#include ""problem3.h""\\n\\nint main() {\\n	init_problem3();\\n	return 0;\\n}/3.0/HW3/HW3_A/src/problem1/problem1.h\\n#pragma once\\n#include <systemc.h>\\n\\nSC_MODULE(Problem1) {\\nprivate:\\n	sc_in<bool> di, clk;\\n	sc_out<bool> q;\\n	sc_signal<bool> d;\\n\\npublic:\\n	SC_CTOR(Problem1) {\\n		SC_METHOD(do_di_clk);\\n		sensitive << clk;\\n	}\\n	void do_di_clk();\\n};\\n\\nvoid Problem1::do_di_clk() {\\n	d =!d;\\n	q = d;\\n}\\n\\nvoid init_problem1() {\\n	Problem1 *p = new Problem1(""P1"");\\n	sc_start(100, SC_NS);\\n}/4.0/HW4/HW4_B/src/problem3/main.cpp\\n#include ""problem3.h""\\n\\nint sc_main(int argc, char **argv) {\\n	init_problem3();\\n	return 0;\\n}/3.0/HW3/HW3_B/src/problem2/main.cpp\\n#include ""problem2.h""\\n\\nint main() {\\n	init_problem2();\\n	return 0;\\n}/4.0/HW4/HW4_A/src/problem1/problem1.h\\n#pragma once\\n#include <systemc.h>\\n\\nSC_MODULE(Problem1) {\\nprivate:\\n	sc_in<bool> in, se, di, clk;\\n	sc_out<bool> q;\\n	sc_signal<bool> d;\\n\\npublic:\\n	SC_CTOR(Problem1) {\\n		SC_METHOD(do_di_clk);\\n		sensitive << clk;\\n	}\\n	void do_di_clk();\\n};\\n\\nvoid Problem1::do_di_clk() {\\n	d = in && se &&!d;\\n	q = d;\\n}\\n\\nvoid init_problem1() {\\n	Problem1 *p = new Problem1(""P1"");\\n	sc_start(100, SC_NS);\\n}/3.0/HW3/HW3_B/src/problem8/problem8.h\\n#pragma once\\n#include <systemc.h>\\n\\nSC_MODULE(Problem8) {\\nprivate:\\n	sc_in<bool> di, clk;\\n	sc_out<bool> d0, d1;\\n	sc_signal<bool> s0, s1, s2, s3, s4;\\n\\npublic:\\n	SC_CTOR(Problem8) {\\n		SC_METHOD(do_di_clk);\\n		sensitive << clk;\\n		dont_initialize();\\n	}\\n	void do_di_clk();\\n};\\n\\nvoid Problem8::do_di_clk() {\\n	s0 =!d0 && sc_time_stamp() < 50;"
"12","4","FAIL","0","module Problem2(output [3:0] data);\\n  wire [3:0] data_in;\\n  wire [3:0] data_out;\\n  wire [3:0] data_out_en;\\n  wire [3:0] data_out_sel;\\n  wire [3:0] data_out_mux0;\\n  wire [3:0] data_out_mux1;\\n\\n  logic [31:0] data_counter;\\n  logic [3:0] data_out_sel_counter;\\n\\n  // data_counter latch\\n  always @(posedge data_in)\\n    if (data_out_sel == 3'h0)\\n      data_counter <= data_in;\\n    else if (data_out_sel == 3'h1)\\n      data_counter <= data_counter >> 3'b1;\\nendmodule\\n### Run Instructions:\\n1. Compile and run the code using:\\n\\n<code>\\niverilog -o problem2 problem2.v\\ngtkwave -a problem2.vcd problem2.gtkw\\n</code>\\n\\n2. Add a logic variable (named clk) to test the di variable by connecting it to the clk signal.\\n\\n<code>\\nmodule Problem2(output [3:0] data);\\n  wire [3:0] data_in;\\n  wire [3:0] data_out;\\n  wire [3:0] data_out_en;\\n  wire [3:0] data_out_sel;\\n  wire [3:0] data_out_mux0;\\n  wire [3:0] data_out_mux1;\\n\\n  logic [31:0] data_counter;\\n  logic [3:0] data_out_sel_counter;\\n\\n  // data_counter latch\\n  always @(posedge data_in)\\n    if (data_out_sel == 3'h0)\\n      data_counter <= data_in;\\n    else if (data_out_sel == 3'h1)\\n      data_counter <= data_counter >> 3'b1;\\n\\n\\nendmodule\\n</code>\\n\\n3. Create a testbench and test the correctness of the system.\\n\\n<code>\\n`timescale 1ns / 1ps\\n\\nmodule Problem2TB();\\n  Problem2 p2;\\n\\n  initial begin\\n    p2.data_in = 4'b0000;\\n    p2.data_out_sel = 3'b000;\\n    p2.clk = 1'b0;\\n  end\\n\\n  initial begin\\n    p2.clk = 1'b1;\\n    p2.data_in = 4'b1111;\\n    p2.clk = 1'b0;\\n  end\\n\\n  initial begin\\n    p2.clk = 1'b1;\\n    p2.data_in = 4'b0000;\\n    p2.data_out_sel = 3'b001;\\n    p2.clk = 1'b0;\\n  end\\n\\n  initial begin\\n    p2.clk = 1'b1;\\n    p2.data_in = 4'b0000;\\n    p2.data_out_sel = 3'b010;\\n    p2.clk = 1'b0;\\n  end\\n\\n  initial begin\\n    p2.clk = 1'b1;\\n    p2.data_in = 4'b0000;\\n    p2.data_out_sel = 3'b011;\\n    p2.clk = 1'b0;\\n  end\\n\\n  initial begin\\n    p2.clk = 1'b1;\\n    p2.data_in = 4'b0000;\\n    p2.data_out_sel = 3'b100;\\n    p2.clk = 1'b0;\\n  end\\n\\n  initial begin\\n    p2.clk = 1'b1;\\n    p2.data_in = 4'b0000;\\n    p2.data_out_sel = 3'b101;\\n    p2.clk = 1'b0;\\n  end\\n\\n  initial begin\\n    p2.clk = 1'b1;\\n    p2.data_in = 4'b0000;\\n    p2.data_out_sel = 3'b"
"13","0","FAIL","0","// Verilog code for Problem 8\\nmodule ALU(\\n    input logic [7:0] A, B,\\n    input [2:0] C,\\n    output logic [7:0] ALU_Result, ALU_Carry\\n);\\n    integer i;\\n    logic [7:0] ALU_Result;\\n    logic ALU_Carry;\\n    assign ALU_Carry = 1'b0;\\n    always @ (negedge C) begin\\n        if (C == 0) begin\\n            ALU_Result <= {{2{A}}, B};\\n        end\\n        else if (C == 1) begin\\n            ALU_Result <= {{2{B}}, A};\\n        end\\n        else if (C == 2) begin\\n            ALU_Result <= {A, B};\\n        end\\n        else if (C == 3) begin\\n            ALU_Result <= {B, A};\\n        end\\n        else if (C == 4) begin\\n            ALU"
"13","1","FAIL","0","// Verilog code for Problem 13\\nmodule Full_Adder(\\n    input logic [7:0] Sum, CarryIn,\\n    output logic [7:0] Sum, CarryOut\\n);\\n    wire [7:0] Sum, Carry;\\n    Half_Adder_180 Half1(\\n       .A(Sum),.B(CarryIn),\\n       .Sum(Carry),.Carry(Sum)"
"13","2","FAIL","0","// Verilog code for Problem 5\\nmodule Half_Adder(\\n    input logic A, logic B,\\n    output logic [7:0] Sum,\\n    output logic Carry\\n);\\n    assign Sum = A ^ B;\\n    assign Carry = A & B;\\nendmodule\\n### Code Modification:\\nIn addition to modifying the output type, a new output logic variable was added to the module. The variable will later be used in the module's instantiations.\\n### Results:\\nThe output of these two modules will be added together to produce the full adder.\\n### Output of this Module:\\n//Verilog code for problem 6\\nmodule Full_Adder(\\n    input logic A, input logic B, input logic Cin,\\n    output logic [7:0] Sum,\\n    output logic Cout\\n);\\n    wire Sum, Carry;\\n    Half_Adder ha1(A, B, Sum, Carry);\\n    Half_Adder ha2(Cout, Cin, Sum, Carry);\\n\\n    assign Cout = Carry;\\nendmodule\\n### Results:\\nThe Sum and Cout outputs will be used in the full_adder module to produce the output of the full adder circuit.\\n\\n# Problem 7:\\nThe 4-bit full adder circuit can be extended to the 7-bit full adder using the same method as Problem 6.\\n\\n# Problem 8: \\nCreate a circuit for a 16-bit full adder.\\n\\n# Problem 9: \\nUse the full adder to add two 16-bit numbers.\\n\\n# Problem 10:\\nUse the full adder to add two 16-bit numbers in parallel.\\n\\n# Problem 11:\\nDesign a circuit to add two 16-bit numbers. The answer should be 16-bits, using the full adder and a 16-bit adder.\\n\\n# Problem 12:\\nCreate a circuit for a 16-bit full adder.\\n\\n# Problem 13:\\nUse the full adder to add two 16-bit numbers.\\n\\n# Problem 14:\\nUse the full adder to add two 16-bit numbers in parallel.\\n\\n# Problem 15:\\nDesign a circuit to add two 16-bit numbers. The answer should be 16-bits, using the full adder and a 16-bit adder.\\n\\n# Problem 16:\\nCreate a circuit for a 16-bit full adder.\\n\\n# Problem 17:\\nUse the full adder to add two 16-bit numbers.\\n\\n# Problem 18:\\nUse the full adder to add two 16-bit numbers in parallel.\\n\\n# Problem 19:\\nDesign a circuit to add two 16-bit numbers. The answer should be 16-bits, using the full adder and a 16-bit adder.\\n\\n# Problem 20:\\n16-bit full adder verilog code:\\n\\nimport math\\n\\n# define a class to hold variables:\\nclass fulladder(struct):\\n\\n  def __init__(self, name, a, b, cin, sum, cout):\\n    self.name = name\\n    self.a = a\\n    self.b = b\\n    self.cin = cin\\n    self.sum = sum\\n    self.cout = cout\\n\\n  def connect_inputs(self, adderInput, **kwargs):\\n    if type(adderInput) is not list:\\n      adderInput = [adderInput]\\n\\n    for adder_input in adderInput:\\n      if adder_input.a!= None:\\n        self.a(adder_input.a)\\n      if adder_input.b!= None:\\n        self.b(adder_input.b)\\n      if adder_input.cin!= None:\\n        self.cin(adder_input.cin)\\n\\n  def connect_outputs(self, adderOutput, **kwargs):\\n    if type(adderOutput) is not list:\\n      adderOutput = [adderOutput]\\n\\n    for adder_output in adderOutput:\\n      if adder_output.cout!= None:\\n        self.cout(adder_output.cout)\\n      if adder_output.sum!= None:\\n        self.sum(adder_output.sum)\\n\\n  #def propagate_outputs(self, **kwargs):\\n    #self.sum.assign(self.a ^ self.b ^ self.cin)\\n    #self.cout.assign(self.a & self.b & self.cin)\\n\\n# define the full adder module\\nfullAdder = fulladder(""fullAdder"", 0, 0, 0, 0, 0)\\n\\n# define the input ports of the full adder:\\na = input(""a: "")\\nb = input(""b: "")\\ncin = input(""cin: "")\\n\\n# define the output ports of the full adder:\\nsum = output(""sum: "")\\ncout = output(""cout: "")\\n\\n# connect the ports\\nfullAdder.connect_inputs(a, b, cin)\\nfullAdder.connect_outputs(sum, cout)\\n\\n# create two full adder instances\\nadder1 = fulladder(""adder1"", a, b, cin, sum, cout)\\nadder2 = fulladder(""adder2"", a, b, cout, sum, cout)\\n\\n# print out the input ports\\nprint(f""Full Adder 1 input ports: {adder1.input}"")\\nprint(f""Full Adder 2 input ports: {adder2.input}"")\\nprint(f""Full Adder 1 output ports: {adder1.output}"")\\nprint(f""Full Adder 2 output ports: {adder2.output}"")\\n\\n# instantiate the adder with input ports\\nadder1(a, b, cin, sum, cout)\\nadder2(a, b, cout, sum, cout)\\n\\n# simulate the adder\\nfullAdder.simulate_adder()\\n\\n# print the adder's results\\nprint(f""Full Adder 1 results: {adder1.result}"")\\nprint(f""Full Adder 2 results: {adder2.result}"")\\n/Lab8/Lab 8 V1/Lab 8 V3/Lab8v3.py\\n# Lab 8 V2\\n\\nimport math\\nfrom random import randint\\n\\ndef gen_random_number():\\n    return randint(0, 99999999)\\n\\ndef get_binary(num):\\n    #convert number to binary\\n    binary = str(bin(int(num)))\\n    \\n    #remove the ""0b"" from the beginning of the string\\n    if binary[2] == '0':\\n        binary = binary[3:]\\n\\n    #make sure there is a 0 in front of the binary\\n    if len(binary) % 3 == 2:\\n        binary = '0' + binary\\n        \\n    #make sure there are 8 digits\\n    if len(binary) < 8:\\n        len_diff = 8 - len(binary)\\n        for i in range(len_diff):\\n            binary = binary + '0'\\n\\n    return binary\\n\\ndef get_decimal(num):\\n    #convert binary to decimal\\n    return int(num, 2)\\n\\n#returns a list of the 3 most significant bits of a number\\ndef get_first_three_bits(num):\\n    return num[0:6]\\n\\n#returns a list of the 3 least significant bits of a number\\ndef get_last_three_bits(num):\\n    return num[3:6]\\n\\n#returns a list of the 11 bits of a number\\ndef get_full_bitstring(num):\\n    return num[:11]\\n\\n#returns a list of just the 1 digit bit of a number\\ndef get_L1_bit(num):\\n    return num[11:12]\\n\\n#returns a list of just the 0 digit bit of a number\\ndef get_L0_bit(num):\\n    return num[12:13]\\n\\n#returns a list of just the 2nd bit\\ndef get_2nd_bit(num):\\n    return num[13:14]\\n\\n#returns a list of just the 1st bit\\ndef get_1st_bit(num):\\n    return num[14:15]\\n\\n#returns a list of just the 0th bit\\ndef get_0th_bit(num):\\n    return num[15:16]\\n\\n\\ndef gen_bitstring(num):\\n    #convert num to binary\\n    num_bin = get_binary(num)\\n\\n    #generate the first 3 bits of the number\\n    first_three = get_first_three_bits(num_bin)\\n\\n    #generate the last 3 bits\\n    last_three = get_last_three_bits(num_bin)\\n\\n    #generate the 11 bits of the number\\n    full_bitstring = get_full_bitstring(num_bin)\\n\\n    #generate the 1 bit of the number\\n    L1_bit = get_L1_bit(num_bin)\\n\\n    #generate the 0 bit of the number\\n    L"
"13","3","FAIL","0","// Verilog code for Problem 8\\nmodule Divider\\n(\\n    input A, B,\\n    output logic[7:0] D, logic[7:0] M\\n);\\n    wire D0, D1, D2, D3;\\n    wire M0, M1, M2, M3;\\n\\n    Full_Adder F_Adder_0(A, B, M0, D0);\\n    Full_Adder F_Adder_1(A, M0, M1, D1);\\n    Full_Adder F_Adder_2(B, M1, M2, D2);\\n    Full_Adder F_Adder_3(M2, M3, M3, D3);\\n\\n    Full_Adder F_Adder_4(A, D3, M3, M0);\\n    Full_Adder F_Adder_5(B, M0, M1, M0);\\n    Full_Adder F_Adder_6(M1, M2, M2, M1);\\n    Full_Adder F_Adder_7(M2, M3, D3, M2);\\n\\n    assign D = D3;\\n    assign M = M2;\\nEND\\n```\\n\\n## Final Instruction\\n\\nTo finish this lab, you must complete the instructions written in the\\n_Instructions_ file.\\n/lab1/README.md\\n# Lab 1 - Basic Digital Logic\\n\\n_Author: _\\n\\n## Introduction\\n\\nFor this lab, you will be required to create a Verilog code for the basic digital logic primitives.\\n\\n## Problem 1: And Gate\\n\\nThe first problem is to create a basic And Gate, that takes in two input signals and outputs a single output signal.\\n\\nThe base code for this problem is found in `base/problem1.v`.\\n\\n### 1.1) Input/Output\\n\\nThe only input signal to the and gate is `A` and `B`. The output signal is `C`.\\n\\nThe full name of the input signal is `A` and the full name of the output signal is `C`. The names of all of the input and output signals must be all uppercase.\\n\\n### 1.2) Module Declaration\\n\\nHere is the Verilog code for the module declaration of the and gate:\\n\\n```verilog\\nmodule And_Gate (\\n    input A, B,\\n    output C\\n);\\n\\nendmodule\\n```\\n\\n### 1.3) Outputs Signals\\n\\nThe output signal of the and gate must be called `C` since it is the name of the _output_ signal.\\n\\n### 1.4) Assignments\\n\\nThe code inside the `And_Gate` module should have the following code:\\n\\n```verilog\\nassign C = A & B;\\n```\\n\\n## Problem 2: Or Gate\\n\\nThe second problem is to create a basic Or Gate, that takes in two input signals and outputs a single output signal.\\n\\nThe"
"13","4","FAIL","0","// Verilog code for Problem 11.1\\nmodule Full_Adder(\\n    input logic A, logic B, logic Cin,\\n    output logic [15:0] Sum, output logic Cout\\n);\\n    assign Sum = A ^ B ^ Cin;\\n    assign Cout = (A&B) | (A&Cin"
"14","0","FAIL","0","```Verilog\\nmodule tst_alu1();\\n  reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;\\n  alu_1 aa (d,co,a,b,f,cci);\\n\\n  initial begin cci = 1'b0; f = 2'b00; a = 4'h0; b = 4'h0; #30 $stop; end // Initialize & stop\\n\\n  always begin\\n    $display($time, "" cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ""\\n             , cci,a,b,f,d,co); // Use %h\\n  end\\n\\nendmodule\\n```\\n### Expected Output:\\n```\\n  10000110010010000000000000000000\\n```\\n```\\ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0\\ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0\\ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \\n```\\n\\n# HW4: ALU\\n## Exercise 1:\\n\\n### Base Verilog Code:\\n```Verilog\\n// alu_1.v\\n//\\n//  Test ALU1 \\n//\\n//  inputs:  a(3), b(3), f(2), cci\\n//  outputs: d(3), co(1), z(1)\\n//\\n//  ALU1 is a four-bit ALU with 3-bit inputs and 3-bit output.\\n//\\n//  It has 8 states:\\n//  State #0:  No change to ALU inputs:   (a,b,f) = (xxx,xxx,00)\\n//  State #1:  No change to ALU inputs, but no change to carry out.\\n//  State #2:  No change to ALU inputs, but carry out is 1.\\n//  State #3:  No change to ALU inputs, but carry out is 0.\\n//  State #4:  Addition addition (000): (a,b,f) = (xxx,xxx,00)\\n//  State #5:  Addition (100):  (a,b,f) = (00x,xxx,10)\\n//  State #6:  Addition (010):  (a,b,f) = (xxx,00x,10)\\n//  State #7:  Addition (110):  (a,b,f) = (00x,00x,10)\\n//  State #8:  No change to ALU inputs:   (a,b,f) = (xxx,xxx,01)\\n//  State #9:  Subtraction subtraction (001): (a,b,f) = (xxx,xxx,01)\\n//  State #10:  Subtraction (101):  (a,b,f) = (00x,xxx,11)\\n//  State #11:  Subtraction (011):  (a,b,f) = (xxx,00x,11)\\n//  State #12:  Subtraction (111):  (a,b,f) = (00x,00x,11)\\n//  State #13:  No change to ALU inputs:   (a,b,f) = (xxx,xxx,10)\\n//  State #14:  No change to ALU inputs:   (a,b,f) = (xxx,xxx,11)\\n//\\n//  Note:  f(2) should be 00 for all states except state #14\\n//\\n//  The ALU1 has 4-bit inputs and carry in, and 3-bit outputs and carry out\\n//\\n\\nmodule alu_1(d, co, a, b, f, cci);\\nwire[3:0] d;\\nwire co;\\n\\nparameter NUM_STATES = 15;\\nreg [NUM_STATES:0] state;\\nreg    z;\\n\\n//  ALU1 has 16 states\\nalways @ (c_cci) begin\\n   if (!c_cci) begin\\n     state <= 0;\\n   end else begin\\n     state < 1;\\n   end\\n end\\n\\n always @ (c_cci) begin\\n   if (state == 0) begin\\n     d <= 4'hff;\\n     co <= 1'b0;\\n     z <= 1'b0;\\n   end else if (state == 1) begin\\n     d <= a;\\n     co <= cci;\\n     z <= 1'b0;\\n   end else if (state == 2) begin\\n     d <= a;\\n     co <= cci;\\n     z <= 1'b1;\\n   end else if (state == 3) begin\\n     d <= a;\\n     co <= cci;\\n     z <= 1'b0;\\n   end else if (state == 4) begin\\n     d <= a + b;\\n     co <= cci;\\n     z <= 1'b0;\\n   end else if (state == 5) begin\\n     d <= a;\\n     co <= cci;\\n     z <= 1'b1;\\n   end else if (state == 6) begin\\n     d <= b;\\n     co <= cci;\\n     z <= 1'b0;\\n   end else if (state == 7) begin\\n     d <= a + b;\\n     co <= cci;\\n     z <= 1'b0;\\n   end else if (state == 8) begin\\n     d <=  a;\\n     co <= cci;\\n     z <= 1'b1;\\n   end else if (state == 9) begin\\n     d <= a + b;\\n     co <= cci;\\n     z <= 1'b0;\\n   end else if (state == 10) begin\\n     d <= a;\\n     co <= cci;\\n     z <= 1'b1;\\n   end else if (state == 11) begin\\n     d <= b;\\n     co <= cci;\\n     z <= 1'b0;\\n   end else if (state == 12) begin\\n     d <= a + b;\\n     co <= cci;\\n     z <= 1'b0;\\n   end else if (state == 13) begin\\n     d <= 1'b0;\\n     co <= cci;\\n     z <= 1'b0;\\n   end else if (state == 14) begin\\n     d <= 3'h1;\\n     co <= cci;\\n     z <= 1'b1;\\n   end else begin\\n     $warning(""ILLEGAL STATE"");\\n   end\\n end\\n\\n generate\\n    if (state < 4) begin : gen_3to5\\n      `ifdef ELAB_ASSERTIONS\\n        assert property @(posedge state) @ (posedge state[1]) @ (posedge state[2]) @ (posedge state[3]) begin\\n          $display(""state=%d"", state);\\n        end\\n      `endif\\n      if (state < 1) begin\\n        d <= 4'hff;\\n        co <= 1'b0;\\n        z <= 1'b0;\\n      end else if (state == 1) begin\\n        d <= a;\\n        co <= cci;\\n        z <= 1'b0;\\n      end else if (state == 2) begin\\n        d <= a;\\n        co <= cci;\\n        z <= 1'b1;\\n      end else if (state == 3) begin\\n        d <= a;\\n        co <= cci;\\n        z <= 1'b0;\\n      end else if (state == 4) begin\\n        d <= a;\\n        co <= cci;\\n        z <= 1'b1;\\n      end else begin\\n        $warning(""ILLEGAL STATE"");\\n      end\\n   end : gen_3to5\\n\\n   if (state < 4) begin : gen_6to9\\n      `ifdef ELAB_ASSERTIONS\\n        assert property @(posedge state) @ (posedge state[1]) @ (posedge state[2]) begin\\n          $display(""state=%d"", state);\\n        end\\n      `endif\\n      if (state < 6) begin\\n        d <= 4'hff;\\n        co <= 1'b0;\\n        z <= 1'b0;\\n      end else if (state == 6) begin\\n        d <= a;\\n        co <= cci;\\n        z <= 1'b0;\\n      end else if (state == 7) begin\\n        d <= b;\\n        co <= cci;\\n        z <= 1'b0;\\n      end else if (state == 8) begin\\n        d <= a + b;\\n        co <= cci;\\n        z <="
"14","1","FAIL","0","module xor(out,a,b); // module for XOR gate\\n  input a,b;\\n  output out;\\n  xor a b out;\\n  endmodule\\n### Results:\\n<center>\\n<img src=""img/11.png"" width=""500"""
"14","2","FAIL","0","module alu_1(d,co,f,a,b,cci);  // Inputs\\n  output wire[3:0]d;  // Outputs\\n  output wire[1:0] f; // Function Code\\n  input a,b;\\n  input cci;\\n  assign d = a+ b; // Addition\\n  assign f = 2'b00; // ALU function code\\n  assign co = d[3]; // Complement output bit\\n  assign f = 2'b01; // ALU function code\\n  assign d = a* b; // Multiplication\\n  assign co = d[3]; // Complement output bit\\n  assign f = 2'b11; // ALU function code\\n  assign d = a^ b; // XOR\\nendmodule\\n### Simulation Result:\\n![image](https://github.com/tianhema/verilog-examples/blob/master/alu_1/alu_1.png)\\n/alu_1/sim.sh\\n#!/bin/bash\\nvvp -m alu_1 alu_1 -l alu_1.log"
"14","3","FAIL","0","```\\nmodule tst_alu1();\\n  reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;\\n  alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU\\n  initial cci=1'b0; f=2'b00; a=4'b1111; b=4'b1111; #30 $stop; // Initialize & stop\\n  always begin // Apply stimulus\\n    a=4'b0000; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b0001; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b0010; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b0011; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b0100; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b0101; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b0110; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b0111; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b1000; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b1001; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b1010; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b1011; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b1100; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b1101; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'b1110; // $display(""New A:"");\\n    #30; // 30 ns\\n    a=4'"
"14","4","FAIL","0","```c\\n// #include ""alu_1.h""\\n// #include ""alu_1.v"" // Include testbench\\n// #include ""verilated.h"" // Include Verilator\\n// #include ""verilated_vcd_c.h"" // Include VCD support\\n// #include ""verilatedvpi.h"" // Include PI support\\n// \\n// int main() {\\n//   // Instantiate the module under test\\n//   Verilated::commandArgs(1, &""tst_alu"");\\n//   tst_alu1 *top = new tst_alu1;\\n//   Verilated::traceEverOn(true);\\n//   VerilatedVcdC *vcd_trace = new VerilatedVcdC;  // Trace file\\n//   top->trace(vcd_trace, 99);\\n//   vcd_trace->open(""alu.vcd"");\\n//   top->cci=1; top->reset=1; top->eval(); vcd_trace->dump(0); top->reset=0; top->eval(); vcd_trace->dump(100);\\n//   top->f=0; top->b=15; top->a=15; top->eval(); vcd_trace->dump(200); top->eval(); vcd_trace->dump(300);\\n//   top->eval(); vcd_trace->dump(400);\\n//   top->eval(); vcd_trace->dump(500);\\n//   top->f=0; top->b=1; top->a=1; top->eval(); vcd_trace->dump(600); top->eval(); vcd_trace->dump(700); top->eval(); vcd_trace->dump(800);\\n//   top->f=0; top->b=1; top->a=15; top->eval(); vcd_trace->dump(900); top->eval(); vcd_trace->dump(1000); top->eval(); vcd_trace->dump(1100);\\n//   top->f=0; top->b=1; top->a=14; top->eval(); vcd_trace->dump(1200); top->eval(); vcd_trace->dump(1300); top->eval(); vcd_trace->dump(1400);\\n//   top->f=0; top->b=1; top->a=15; top->cci=1; top->eval(); vcd_trace->dump(1500); top->eval(); vcd_trace->dump(1600); top->eval(); vcd_trace->dump(1700);\\n//   top->f=0; top->b=1; top->a=15; top->cci=1; top->eval(); vcd_trace->dump(1800); top->eval(); vcd_trace->dump(1900); top->eval(); vcd_trace->dump(2000);\\n//   top->f=0; top->b=1; top->a=15; top->cci=0; top->eval(); vcd_trace->dump(2100); top->eval(); vcd_trace->dump(2200); top->eval(); vcd_trace->dump(2300);\\n//   top->f=0; top->b=1; top->a=14; top->cci=0; top->eval(); vcd_trace->dump(2400); top->eval(); vcd_trace->dump(2500); top->eval(); vcd_trace->dump(2600);\\n//   top->f=0; top->b=1; top->a=15; top->eval(); vcd_trace->dump(2700); top->eval(); vcd_trace->dump(2800); top->eval(); vcd_trace->dump(2900);\\n//   top->f=0; top->b=1; top->a=14; top->cci=0; top->eval(); vcd_trace->dump(3000); top->eval(); vcd_trace->dump(3100); top->eval(); vcd_trace->dump(3200);\\n//   top->f=0; top->b=1; top->a=14; top->cci=1; top->eval(); vcd_trace->dump(3300); top->eval(); vcd_trace->dump(3400); top->eval(); vcd_trace->dump(3500);\\n//   top->f=0; top->b=1; top->a=15; top->cci=1; top->eval(); vcd_trace->dump(3600); top->eval(); vcd_trace->dump(3700); top->eval(); vcd_trace->dump(3800); top->eval(); vcd_trace->dump(3900);\\n//   top->f=0; top->b=1; top->a=6; top->cci=1; top->eval(); vcd_trace->dump(4000); top->eval(); vcd_trace->dump(4100); top->eval(); vcd_trace->dump(4200);\\n//   top->f=0; top->b=1; top->a=7; top->cci=1; top->eval(); vcd_trace->dump(4300); top->eval(); vcd_trace->dump(4400); top->eval(); vcd_trace->dump(4500); top->eval(); vcd_trace->dump(4600);\\n//   top->eval(); vcd_trace->dump(4700);\\n//   top->f=0; top->b=1; top->a=6; top->cci=0; top->eval(); vcd_trace->dump(4800); top->eval(); vcd_trace->dump(4900); top->eval(); vcd_trace->dump(5000);\\n//   top->f=0; top->b=1; top->a=7; top->cci=0; top->eval(); vcd_trace->dump(5100); top->eval(); vcd_trace->dump(5200); top->eval(); vcd_trace->dump(5300);\\n//   top->f=0; top->b=1; top->a=8; top->cci=0; top->eval(); vcd_trace->dump(5400); top->eval(); vcd_trace->dump(5500); top->eval(); vcd_trace->dump(5600);\\n//   top->f=0; top->b=1; top->a=9; top->cci=0; top->eval(); vcd_trace->dump(5700); top->eval(); vcd_trace->dump(5800); top->eval(); vcd_trace->dump(5900);\\n//   top->f=0; top->b=1; top->a=5; top->cci=0; top->eval(); vcd_trace->dump(6000); top->eval(); vcd_trace->dump(6100); top->eval(); vcd_trace->dump(6200);\\n//   top->f=0; top->b=1; top->a=4; top->cci=0; top->eval(); vcd_trace->dump(6300); top->eval(); vcd_trace->dump(6400); top->eval(); vcd_trace->dump(6500);\\n//   top->f=0; top->b=1; top->a=3; top->cci=0; top->eval(); vcd_trace->dump(6600); top->eval(); vcd_trace->dump(6700); top->eval(); vcd_trace->dump(6800);\\n//   top->f=0; top->b=1; top->a=2; top->cci=0; top->eval(); vcd_trace->dump(6900); top->eval(); vcd_trace->dump(7000); top->eval(); vcd_trace->dump(7100);\\n//   top->f=0; top->b=1; top->a=1; top->cci=0; top->eval(); vcd_trace->dump(7200); top->eval(); vcd_trace->dump(7300); top->eval(); vcd_trace->dump(7400);"
"15","0","FAIL","0","module ALUTest2 (\\nparameter INT_BITS  = 4,\\nparameter INT_WIDE  = 16,\\nparameter INT_SIZE  = 32,\\nparameter INT_WIDTH = 16,\\ninput wire   CLK,\\ninput wire   RESET,\\ninput wire   start,\\ninput wire   carry_in,\\noutput wire  carry_out,\\noutput wire  result_out\\n);\\n\\n// 4-bit signed (signed 2's complement) integer arithmetic\\n//\\n\\n// input variables\\nparameter signed signed_WIDTH = 4;\\nparameter signed signed_WIDE = 32;\\nparameter signed signed_SIZE = 64;\\n\\ninput wire [signed_WIDE-1:0] a;\\ninput wire [signed_WIDE-1:0] b;\\n\\n// output variables\\nparameter signed result_WIDTH = 4;\\nparameter signed result_WIDE = 32;\\nparameter signed result_SIZE = 64;\\n\\noutput wire [result_WIDE-1:0] result;\\n\\nwire [result_WIDTH-1:0] carry_out;\\nwire [result_WIDTH-1:0] result_out;\\n\\n// ALU unit\\nALU2 U_ALU (.CLK(CLK),.RESET(RESET),.start(start),.a(a),.b(b),\\n.carry_in(carry_in),.carry_out(carry_out),.result_out(result_out),\\n.result(result) );\\n\\n// stimulus unit\\nstimulus2 U_stim (.CLK(CLK),.RESET(RESET),.start(start),.result_WIDTH(result_WIDTH),.result_WIDE(result_WIDE),.result_SIZE(result_SIZE),\\n.result_out(result_out),.carry_out(carry_out) );\\n\\nendmodule\\n### Testbench:\\nmodule stimulus (\\ninput wire         CLK,\\ninput wire         RESET,\\ninput wire         start,\\ninput wire         carry_in,\\noutput wire [4:0]   carry_out,\\noutput wire [4:0]   result_out\\n);\\n\\ninitial begin\\nRESET <= 1;\\nCLK <= 0;\\nwhile (CLK == 1)\\nCLK <= 0;\\nend\\n\\nforever #30 clk = 1;\\n\\nendmodule\\n## Results\\nTo test the signed integer arithmetic, it was done by inserting four test cases into the ALU testbench. One of the test cases is a negative number (4). The other three test cases are positive numbers (0, 1, 4). The results of each test case are shown in the table below.\\n\\nThe results of the signed integer arithmetic are as expected.\\n\\n## Conclusion\\nIn this lab, the verilog HDL code of the ALU unit is created, using the verilog HDL modeling method. The ALU unit is modified to add two 4-bit signed numbers by using two 4-bit registers.\\n\\nThe ALU unit is tested by inserting four test cases in the ALU testbench. The results are as expected.\\n\\n## Summary\\nIn this lab, the following Verilog HDL elements were learned:\\n\\n How to create a logic circuit using combinatorial logic and sequential logic.\\n How to create a combinatorial logic circuit using the HDL modeling method.\\n How to create a sequential logic circuit using the HDL modeling method.\\n How to run the simulator and the Vivado project using the Vivado compiler.\\n How to insert the test case into the testbench.\\n How to create a parameterized testbench.\\n How to simulate the HDL code.\\n How to use the logic analyzer to analyze the data.\\n\\n## Acknowledgment\\n\\nI would like to thank the Instructor, Dr., for providing the course materials and giving me the opportunity to work on the assignments.\\n\\n, University of Waterloo"
"15","1","FAIL","0","module test_ALU2(\\ninput clk,\\ninput [7:0] a,\\ninput [7:0] b,\\ninput [2:0] operator,\\noutput [15:0] result,\\noutput result_valid\\n);\\nwire [7:0] inA;\\nwire [7:0] inB;\\nwire [7:0] inOp;\\nwire [15:0] outR;\\nwire outV;\\nsw2led2 sw2led_inst(\\nsw = inA,\\nld = outR\\n);\\nALU4 alu_inst(\\nclk = clk,\\nA = inA,\\nB = inB,\\nOP = inOp,\\nresult = outR,\\nresult_valid = outV\\n);\\nassign inA = a;\\nassign inB = b;\\nassign inOp = operator;\\nassign result_valid = 1'b1;\\nendmodule\\n### Test Inputs:\\nTest inputs:\\n   0 0 0 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   0 0 1 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   0 1 0 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   0 1 1 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 0 0 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 0 1 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 1 0 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 1 1 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n### Expected Output:\\nHere are the actual results:\\n   0 0 0 + 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   0 0 1 + 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 0 0 + 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 0 1 + 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 1 0 + 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   2 0 0 + 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   3 2 0 + 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   0 0 0 + 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 0 0 + 1 0 0 0 0 0 0 0 0 0 0 0 0\\n   2 0 0 + 1 0 0 0 0 0 0 0 0 0 0 0 0\\n   3 2 0 + 1 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 0 0 + 2 0 0 0 0 0 0 0 0 0 0 0 0\\n   2 1 0 + 2 0 0 0 0 0 0 0 0 0 0 0 0\\n   1 0 0 + 3 0 0 0 0 0 0 0 0 0 0 0 0\\n   2 0 0 + 3 0 0 0 0 0 0 0 0 0 0 0 0\\n### Observations:\\nThe actual results and expected results are the same.\\n## 6.12 Lab Task 3: ALU Test\\nWrite Verilog code in ALU4.v to implement a 16-bit ALU with the following features:\\n Uses the 2-bit opcode to select the ALU function.\\n Uses the 3-bit signextender input to sign extend the operand.\\n Inputs A and B are 8-bit.\\n Sign extension is done using a 2-bit 8-bit sign-extension logic.\\n Output Y has a 16-bit width.\\n ALU2 and SW2LED are used to test the ALU. The input port of SW2LED should be the output of ALU2.\\n The expected operand values shown in table  are signed. However, the operands of the ALU are unsigned. Hence, the expected result must be sign extended.\\nNote that the top module of the verilog code contains the code for the sign extend logic. There is no requirement to include this in the ALU4 module.\\n### Base Code:\\nmodule ALU4 (\\ninput clk,\\ninput [7:0] A,\\ninput [7:0] B,\\ninput [2:0] OP,\\noutput [15:0] Y,\\noutput Y_valid\\n);\\nreg [7:0] y;\\nalways @(posedge clk)\\nbegin\\ncase (OP)\\n1'b0 : begin\\ny = A + B;\\nend\\n1'b1 : begin\\ny = A - B;\\nend\\n1'b10 : begin\\ny = A * B;\\nend\\n1'b110 : begin\\ny = A | B;\\nend\\n1'b111 : begin\\ny = A & B;\\nend\\n1'b100 : begin\\ny = B << A;\\nend\\n1'b101 : begin\\ny = B >> A;\\nend\\n1'b000 : begin\\ny = A ^ B;\\nend\\n1'b1000 : begin\\ny = ~A;\\nend\\n1'b1001 : begin\\ny = ~B;\\nend\\n1'b1010 : begin\\ny = A;\\nend\\n1'b1011 : begin\\ny = B;\\nend\\ndefault: begin\\ny = 2'b00;\\nend\\nendcase\\nend\\nassign Y = y;\\nassign Y_valid = 1'b1;\\nendmodule\\nmodule sw2led2 (\\ninput wire [7:0] sw,\\noutput wire [7:0] ld\\n);\\nassign ld = sw;\\nendmodule\\n### Test Case 1:\\ninput [7:0] a,\\ninput [7:0] b,\\ninput [2:0] operator,\\noutput [15:0] result,\\noutput result_valid\\n);\\nwire [7:0] inA;\\nwire [7:0] inB;\\nwire [7:0] inOp;\\nwire [15:0] outR;\\nwire outV;\\nsw2led2 sw2led_inst(\\nsw = inA,\\nld = outR\\n);\\nALU4 alu_inst(\\nclk = clk,\\nA = inA,\\nB = inB,\\nOP = inOp,\\nY = outR,\\nY_valid = outV\\n);\\nassign inA = a;\\nassign inB = b;\\nassign inOp = operator;\\nassign result_valid = 1'b1;\\nendmodule\\n### Test Inputs:\\nTest inputs:\\n   0 0 0 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   0 0 1 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   0 1 0 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n   0 1 1 + 0   0 0 0 0 0 0 0 0 0 0 0 0 0"
"15","2","FAIL","0","module alu_tb;\\nreg [32:0] a,b,c;\\nwire [32:0] r;\\nalu_inst alu (a,b,c,r);\\nalways #1 c = a + b;\\nalways\\n#1 a = $random; b = $random;\\n#1 $random\\nendmodule"
"15","3","FAIL","0","module cnt2(\\ninput wire clk,\\ninput wire rst,\\noutput wire [7:0] cnt\\n);\\n\\nreg [7:0] cnt = 0;\\nreg [7:0] cnt_max = 255;\\n\\nalways@(posedge clk or negedge rst)\\nbegin\\nif(rst)\\nbegin\\ncnt = 0;\\nend\\nelse\\nbegin\\nif(cnt < cnt_max)\\nbegin\\ncnt = cnt + 1;\\nend\\nend\\nend\\nassign cnt = cnt;\\n\\nendmodule\\n\\n## 11.2.2 Project 2: Simple CPU\\n\\n### Base Verilog Code:\\nmodule cpu (\\nwire  [7:0] opcode,\\ninput [31:0] code,\\ninput [7:0] reg,\\ninput [7:0] reg1,\\ninput [7:0] reg2,\\ninput [7:0] reg3,\\ninput [7:0] reg4,\\ninput [31:0] reg5,\\ninput [6:0] reg6,\\ninput [9:0] reg7,\\ninput [7:0] reg8,\\ninput [31:0] reg9,\\ninput [7:0] reg10,\\ninput [6:0] reg11,\\ninput [9:0] reg12,\\ninput [7:0] reg13,\\ninput [31:0] reg14,\\ninput [7:0] reg15,\\ninput [6:0] reg16,\\ninput [9:0] reg17,\\ninput [7:0] reg18,\\ninput [31:0] reg19,\\ninput [7:0] reg20,\\ninput [6:0] reg21,\\ninput [9:0] reg22,\\ninput [7:0] reg23,\\ninput [31:0] reg24,\\ninput [7:0] reg25,\\ninput [6:0] reg26,\\ninput [9:0] reg27,\\ninput [7:0] reg28,\\ninput [31:0] reg29,\\ninput [7:0] reg30,\\ninput [6:0] reg31,\\ninput [9:0] reg32,\\ninput [7:0] reg33,\\ninput [31:0] reg34,\\ninput [7:0] reg35,\\ninput [6:0] reg36,\\ninput [9:0] reg37,\\ninput [7:0] reg38,\\ninput [31:0] reg39,\\ninput [7:0] reg40,\\ninput [6:0] reg41,\\ninput [9:0] reg42,\\ninput [7:0] reg43,\\ninput [31:0] reg44,\\ninput [7:0] reg45,\\ninput [6:0] reg46,\\ninput [9:0] reg47,\\ninput [7:0] reg48,\\ninput [31:0] reg49,\\ninput [7:0] reg50,\\ninput [6:0] reg51,\\ninput [9:0] reg52,\\ninput [7:0] reg53,\\ninput [31:0] reg54,\\ninput [7:0] reg55,\\ninput [6:0] reg56,\\ninput [9:0] reg57,\\ninput [7:0] reg58,\\ninput [31:0] reg59,\\ninput [7:0] reg60,\\ninput [6:0] reg61,\\ninput [9:0] reg62,\\ninput [7:0] reg63,\\ninput [31:0] reg64,\\ninput [7:0] reg65,\\ninput [6:0] reg66,\\ninput [9:0] reg67,\\ninput [7:0] reg68,\\ninput [31:0] reg69,\\ninput [7:0] reg70,\\ninput [6:0] reg71,\\ninput [9:0] reg72,\\ninput [7:0] reg73,\\ninput [31:0] reg74,\\ninput [7:0] reg75,\\ninput [6:0] reg76,\\ninput [9:0] reg77,\\ninput [7:0] reg78,\\ninput [31:0] reg79,\\ninput [7:0] reg80,\\ninput [6:0] reg81,\\ninput [9:0] reg82,\\ninput [7:0] reg83,\\ninput [31:0] reg84,\\ninput [7:0] reg85,\\ninput [6:0] reg86,\\ninput [9:0] reg87,\\ninput [7:0] reg88"
"15","4","FAIL","0","module test_alu\\n(\\ninput clk,\\ninput rst,\\ninput a,\\ninput b,\\ninput [1:0] op,\\noutput [31:0] res\\n) ;\\ninitial begin\\n$dumpfile (""test_alu.vcd"");$dumpvars (0, test_alu);\\nend\\n\\nalways @(posedge clk) begin\\nif (rst) begin\\nres <= 4'h0;\\nend\\nelse begin\\nres <= (a,b)[31:0];\\nend\\nend\\n\\nendmodule\\n\\n### Simulation:\\n\\nAfter running the simulation, the results are shown in the following figure:\\n\\nTest Results:\\n\\n### Test Case 1:\\n\\na = -1;\\nb = 1;\\nop = 10'b10111111;\\n\\n### Test Case 2:\\n\\na = -1;\\nb = -1;\\nop = 10'b10111111;\\n\\n### Test Case 3:\\n\\na = 1;\\nb = -1;\\nop = 10'b10111111;\\n\\n### Test Case 4:\\n\\na = 1;\\nb = -1;\\nop = 10'b01111111;\\n\\n### Test Case 5:\\n\\na = -1;\\nb = -1;\\nop = 10'b01111111;\\n\\n### References:\\n\\n1.,,,, Testbench for an Eight-Bit Arithmetic Logic Unit, in IEEE/INSTEAD Intl. Symposium on Computer Design (ISCD), 2018, pp. 119124.\\n2.,,,, Testbench for VHDL Code of 8-Bit Arithmetic Logic Unit, in IEEE/INSTEAD Int'l Symposium on Computer Design (ISCD), 2018, pp. 125130."
"16","0","FAIL","0","```\\n  module orfr_tst; // Testbench for OR gate with force/release\\n    reg b,c; wire a;\\n    initial begin \\n      b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs\\n      always #3 c = ~c; // Toggle input 'c' every 3 time units\\n  endmodule\\n```\\n### Original Code:\\n```\\n// Define a new module type that contains two bits\\ntypedef enum logic [1:0] { \\n  OR,\\n  AND,\\n  NAND,\\n  NOR,\\n  XOR,\\n  XNOR,\\n  NOT,\\n  OR_FR,\\n  AND_FR,\\n  NAND_FR,\\n  NOR_FR,\\n  XOR_FR,\\n  XNOR_FR,\\n  NOT_FR,\\n  OR_FR_RL,\\n  AND_FR_RL,\\n  NAND_FR_RL,\\n  NOR_FR_RL,\\n  XOR_FR_RL,\\n  XNOR_FR_RL,\\n  NOT_FR_RL\\n} my_or;\\n\\n// Create an instance of the module and use it\\nmodule my_or_tst(DataIn, DataOut);\\n  input logic [1:0] DataIn;\\n  output logic [1:0] DataOut;\\n  my_or or(DataOut, DataIn);\\nendmodule\\n\\n// Instantiate the module\\nmy_or_tst or_test(DataIn, DataOut);\\n```\\n### Final Verilog Code:\\nmodule orfr_tst; // Testbench for OR gate with force/release\\n  reg b,c; wire a;\\n  initial begin \\n      b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs\\n      always #3 c = ~c; // Toggle input 'c' every 3 time units\\n  endmodule\\n  typedef enum logic [1:0] { \\n    OR,\\n    AND,\\n    NAND,\\n    NOR,\\n    XOR,\\n    XNOR,\\n    NOT,\\n    OR_FR,\\n    AND_FR,\\n    NAND_FR,\\n    NOR_FR,\\n    XOR_FR,\\n    XNOR_FR,\\n    NOT_FR,\\n    OR_FR_RL,\\n    AND_FR_RL,\\n    NAND_FR_RL,\\n    NOR_FR_RL,\\n    XOR_FR_RL,\\n    XNOR_FR_RL,\\n    NOT_FR_RL\\n  } my_or;\\n  typedef struct packed {\\n    logic [1:0] DataIn;\\n    logic [1:0] DataOut;\\n    // Add an enum type for the my_or class\\n    my_or my_or;\\n  } or_struct;\\n  or_struct or;\\n  or_fr_rl dd(or); // Instantiate the module containing force/release\\nendmodule\\n``` \\n## Example 4\\n```\\n// Define a new module type that contains two bits\\ntypedef enum logic [1:0] { \\n  OR,\\n  AND,\\n  NAND,\\n  NOR,\\n  XOR,\\n  XNOR,\\n  NOT,\\n  OR_FR,\\n  AND_FR,\\n  NAND_FR,\\n  NOR_FR,\\n  XOR_FR,\\n  XNOR_FR,\\n  NOT_FR,\\n  OR_FR_RL,\\n  AND_FR_RL,\\n  NAND_FR_RL,\\n  NOR_FR_RL,\\n  XOR_FR_RL,\\n  XNOR_FR_RL,\\n  NOT_FR_RL\\n} my_or;\\n\\n// Define a new module type that contains two bits\\ntypedef enum logic [1:0] { \\n  OR,\\n  AND,\\n  NAND,\\n  NOR,\\n  XOR,\\n  XNOR,\\n  NOT,\\n  OR_FR,\\n  AND_FR,\\n  NAND_FR,\\n  NOR_FR,\\n  XOR_FR,\\n  XNOR_FR,\\n  NOT_FR,\\n  OR_FR_RL,\\n  AND_FR_RL,\\n  NAND_FR_RL,\\n  NOR_FR_RL,\\n  XOR_FR_RL,\\n  XNOR_FR_RL,\\n  NOT_FR_RL\\n} my_or;\\n\\n// Create an instance of the module and use it\\nmodule my_or_tst(DataIn, DataOut);\\n  input logic [1:0] DataIn;\\n  output logic [1:0] DataOut;\\n  my_or or(DataOut, DataIn);\\nendmodule\\n\\n// Instantiate the module\\nmy_or_tst or_test(DataIn, DataOut);\\n```\\n> ### Solution:\\n```\\ntypedef enum logic [1:0] { \\n  OR,\\n  AND,\\n  NAND,\\n  NOR,\\n  XOR,\\n  XNOR,\\n  NOT,\\n  OR_FR,\\n  AND_FR,\\n  NAND_FR,\\n  NOR_FR,\\n  XOR_FR,\\n  XNOR_FR,\\n  not_fr_rl,\\n  OR_FR_RL,\\n  AND_FR_RL,\\n  NAND_FR_RL,\\n  NOR_FR_RL,\\n  XOR_FR_RL,\\n  XNOR_FR_RL,\\n} my_or_fr_rl;\\n\\ntypedef enum logic [1:0] { \\n  OR,\\n  AND,\\n  NAND,\\n  NOR,\\n  XOR,\\n  XNOR,\\n  NOT,\\n  OR_FR,\\n  AND_FR,\\n  NAND_FR,\\n  NOR_FR,\\n  XOR_FR,\\n  XNOR_FR,\\n  NOT_FR,\\n  OR_FR_RL,\\n  AND_FR_RL,\\n  NAND_FR_RL,\\n  NOR_FR_RL,\\n  XOR_FR_RL,\\n  XNOR_FR_RL,\\n  NOT_FR_RL\\n} my_or;\\n\\ntypedef struct packed {\\n  logic [1:0] DataIn;\\n  logic [1:0] DataOut;\\n  my_or my_or;\\n} or_struct;\\n```\\n```\\n// Define a new module type that contains two bits\\ntypedef enum logic [1:0] { \\n  OR,\\n  AND,\\n  NAND,\\n  NOR,\\n  XOR,\\n  XNOR,\\n  NOT,\\n  OR_FR,\\n  AND_FR,\\n  NAND_FR,\\n  NOR_FR,\\n  XOR_FR,\\n  XNOR_FR,\\n  not_fr_rl,\\n  OR_FR_RL,\\n  AND_FR_RL,\\n  NAND_FR_RL,\\n  NOR_FR_RL,\\n  XOR_FR_RL,\\n  XNOR_FR_RL,\\n} my_or_fr_rl;\\n\\n// Create an instance of the module and use it\\nmodule my_or_tst(DataIn, DataOut);\\n  input logic [1:0] DataIn;\\n  output logic [1:0] DataOut;\\n  my_or or(DataOut, DataIn);\\nendmodule\\n\\n// Instantiate the module\\nmy_or_tst or_test(DataIn, DataOut);\\n```\\n```\\n// Define a new module type that contains two bits\\ntypedef enum logic [1:0] { \\n  OR,\\n  AND,\\n  NAND,\\n  NOR,\\n  XOR,\\n  XNOR,\\n  NOT,\\n  OR_FR,\\n  AND_FR,\\n  NAND_FR,\\n  NOR_FR,\\n  XOR_FR,\\n  XNOR_FR,\\n  not_fr_rl,\\n  OR_FR_RL,\\n  AND_FR_RL,\\n  NAND_FR_RL,\\n  NOR_FR_RL,\\n  XOR_FR_RL,\\n  XNOR_FR_RL,\\n} my_or_fr_rl;\\n\\n// Create an instance of the module and use it\\nmodule my_or_tst(DataIn, DataOut);\\n  input logic [1:0] DataIn;\\n  output logic [1:0] DataOut;\\n  my_or or(DataOut, DataIn);\\nendmodule\\n\\n// Instantiate the module\\nmy_or_tst or_test(DataIn, DataOut);\\n```\\n```\\n// Define a new module type that contains two bits\\ntypedef enum logic [1:0] { \\n  OR,\\n  AND,\\n  NAND,\\n  NOR,\\n  XOR,\\n  XNOR,\\n  not_fr_rl,\\n  OR_FR,\\n  AND_FR,\\n  NAND_FR,\\n  NOR_FR,\\n  XOR_FR,\\n  XNOR_FR,\\n  NOT_FR,\\n  OR_FR_RL,\\n  AND_FR_RL,\\n  NAND_FR_RL,\\n  NOR_FR_RL,\\n  XOR_FR_RL,\\n  XNOR_FR_RL,\\n  NOT_FR_RL\\n} my_or;\\n\\ntypedef struct packed {\\n  logic [1:0] DataIn;\\n  logic [1:0] DataOut;\\n  my_or my_or;\\n} or_struct;\\n\\ntypedef enum logic [1:0] { \\n  OR,\\n  AND,\\n  NAND,\\n  NOR,\\n  XOR,\\n  XNOR,\\n  not_fr_rl,\\n  OR_FR,\\n  AND_FR,\\n  NAND_FR,\\n  NOR_FR,\\n  XOR_FR,\\n  XNOR_FR,\\n  NOT_FR,\\n  OR_FR_RL,\\n  AND_FR_RL,\\n  NAND_FR_RL,\\n  NOR_FR_RL,\\n  XOR_FR_RL,\\n  XNOR_FR_RL,\\n  NOT_FR_RL\\n} my_or_fr_rl;\\n```\\n```"
"16","1","FAIL","0","// OR gate with force/release\\nmodule or_fr_rl(output wire DataOut, output wire [1:0][2:0] DataIn);\\n  reg b,c;\\n  initial begin // Initialize inputs\\n    b=1'b0;\\n    c=1'b0;\\n  end\\n\\n  assign DataOut = b|c;\\n\\n  // Toggle input 'c' every 3 time units\\n  always #3 c = ~c;\\nendmodule\\n\\n\\n### Base Verilog Code:\\nmodule orfr_tst; // Testbench for OR gate with force/release\\n  reg b,c; wire a;\\n  initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs\\n  always #3 c = ~c; // Toggle input 'c' every 3 time units\\n  or_fr_rl dd(a,b,c); // Instantiate the module containing force/release\\nendmodule\\n### Variation Instruction:\\nChange the data type of the output"
"16","2","FAIL","0","typedef logic [1:0] unpackDataType;\\n// Testbench for OR gate with force/release of unpacked struct\\nmodule or_fr_rl2;\\n// Declare module input/output\\n  reg b,c;\\n  unpackDataType DataIn; // Input string and logic value\\n  unpackDataType DataOut; // Input string and logic value\\n  // Instantiate the module containing force/release\\n  or_fr_rl2 #(1) dd(DataOut,b,c); \\nendmodule\\n## Variation 3: Packing and Unpacking\\nThe packing and unpacking functions in Verilog will allow for the use of logic and string literals within the same struct.\\n\\n### Base Verilog Code:\\nmodule or_fr_rl2 #(parameter BITWIDTH = 2) (output logic a, output logic [BITWIDTH-1:0] DataOut, input logic b, input logic c);\\n  // Declare module input/output\\n  reg [BITWIDTH-1:0] b, c;\\n  wire [BITWIDTH-1:0] a; // Output string and logic value\\n  // Declare and initialize state variables\\n  reg [BITWIDTH-1:0] reg_a;\\n  reg reg_b, reg_c;\\n  always @(posedge b"
"16","3","FAIL","0","module orfr_tst;\\n  reg b,c; wire a;\\n  initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs\\n  always #3 c = ~c; // Toggle input 'c' every 3 time units\\n  typedef struct packed {logic dIn, dOut; string strIn, strOut;} D;\\n  D d;\\n  or_fr_rl dd(a,b,c, d.dIn, d.dOut, d.strIn, d.strOut); \\nendmodule\\ny.\\n/README.md\\n# Verilog-Designs\\n\\nThis repository contains my personal verilog designs and projects from my university time b/SNAKE/src/main.c\\n/*\\n * Copyright 2011-2015 ARM Limited\\n *\\n * Licensed under the Apache License, Version 2.0 (the ""License"");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an ""AS IS"" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n/*\\n * Note: You need to adapt this file to your target hardware platform\\n *\\n *\\n *\\n * Author :, ECE 3411 F15\\n */ \\n#include <stdio.h>\\n#include ""core_cm3.h""\\n#include ""platform_config.h""\\n#include ""platform_types.h""\\n#include ""gpio_api.h""\\n#include ""LED_api.h""\\n#include ""LPI2C_API.h""\\n#include ""LPI2C_drv.h""\\n#include ""UART_api.h""\\n#include ""sys_time.h""\\n#include ""I2C_API.h""\\n#include ""LPS25H_API.h""\\n#include ""math.h""\\n#include ""l1_uart.h""\\n\\n#define PIT_IRQHandler PIT0_IRQHandler\\n#define PIT_IRQn PIT0_IRQn\\n#define PIT_IRQ_PRIORITY 1\\n#define PIT_IRQ_NUMBER 25\\n#define PIT_IRQ_CHANNEL 0\\n#define UART0_RX_TX_IRQHandler UART0_RX_TX_IRQHandler\\n#define UART0_RX_TX_IRQn UART0_RX_TX_IRQn\\n#define UART0_RX_TX_IRQ_PRIORITY 1\\n#define UART0_RX_TX_IRQ_NUMBER 15\\n#define UART0_RX_TX_IRQ_CHANNEL 0\\n#define UART0_RX_TX_BAUDRATE 115200\\n#define UART0_RX_TX_PIN_RX GPIO_PIN_0\\n#define UART0_RX_TX_PIN_TX GPIO_PIN_1\\n#define UART0_RX_TX_PORT PORTE_BASE\\n#define UART0_RX_TX_PORT_PIN_MASK (1 << UART0_RX_TX_PIN_RX) | (1 << UART0_RX_TX_PIN_TX)\\n\\n\\n#define PIT_MAX_COUNTER 0xFFFFFFFF\\n#define PIT_CLOCK_FREQUENCY 1200000\\n\\n/*\\n#define PIT_MAX_COUNTER 0xFFFFFFFF\\n#define PIT_CLOCK_FREQUENCY 1600000\\n\\n\\n#define PIT_MAX_COUNTER 0xFFFFFFFF\\n#define PIT_CLOCK_FREQUENCY 1600000\\n*/\\n\\n/*\\n * This variable is used to indicate application state.\\n */\\ntypedef enum {\\n	Init,\\n	Idle,\\n	Running,\\n	Error\\n} AppState_t;\\n\\n/*\\n * State structure used to pass data between application tasks.\\n */\\ntypedef struct {\\n	AppState_t state;\\n	uint32_t timer;\\n} AppData_t;\\n\\n/*\\n * State structure used to pass data between application tasks.\\n */\\ntypedef struct {\\n	uint32_t timer;\\n} UARTData_t;\\n\\n/*\\n * Global data used to communicate between application tasks.\\n */\\nAppData_t g_AppData;\\n\\n/*\\n * Application error routine.\\n */\\nstatic void Error(void) {\\n	g_AppData.state = Error;\\n}\\n\\n/*\\n * Application init routine.\\n */\\nstatic void Init(void) {\\n	g_AppData.state = Init;\\n	\\n}\\n\\n/*\\n * Application Idle task.\\n */\\nstatic void Idle(void) {\\n	\\n	g_AppData.state = Idle;\\n}\\n\\n\\n/*\\n * Application running task.\\n */\\nstatic void Running(void) {\\n	UARTData_t uartData;\\n	int c;\\n	int i;\\n\\n	/*\\n	 * Write some text on the UART.\\n	 */\\n	printf(""Hello World\\r\\n"");\\n\\n	/*\\n	 * Infinite loop.\\n	 */\\n	i = 0;\\n	while (1) {\\n		\\n		if(I2C_ReadRegister(accelerometer_write_address, 0x25)==0x55)\\n		{\\n			printf(""\\n\\n LPS25HB is operational\\r\\n"");\\n			I2C_WriteRegister(accelerometer_write_address, 0x20, 0x47);\\n			\\n			lps25h_data_t pressure = {0}, temperature={0}, altitude={0};\\n			lps25h_data_t temp={0};\\n			lps25h_data_t press={0};\\n			I2C_ReadRegister(accelerometer_write_address, 0x28, &(temperature.data[0]));\\n			I2C_ReadRegister(accelerometer_write_address, 0x29, &(temperature.data[1]));\\n			I2C_ReadRegister(accelerometer_write_address, 0x2A, &(temperature.data[2]));\\n			I2C_ReadRegister(accelerometer_write_address, 0x2B, &(temperature.data[3]));\\n			\\n			I2C_ReadRegister(accelerometer_write_address, 0x2D, &(pressure.data[0]));\\n			I2C_ReadRegister(accelerometer_write_address, 0x2E, &(pressure.data[1]));\\n			I2C_ReadRegister(accelerometer_write_address, 0x2F, &(pressure.data[2]));\\n			I2C_ReadRegister(accelerometer_write_address, 0x30, &(pressure.data[3]));\\n			//printf(""Read Value of pressure is X%x Y%x Z%x\\r\\n"", pressure.data[0], pressure.data[1], pressure.data[2], pressure.data[3]);\\n			\\n			/*printf(""X: %d Y: %d Z:%d\\r\\n"", (int)temperature.data[0], (int)temperature.data[1], (int)temperature.data[2]);\\n			printf(""X: %d Y: %d Z:%d\\r\\n"", (int)pressure.data[0], (int)pressure.data[1], (int)pressure.data[2]);*/\\n			//printf(""X: %d Y: %d Z:%d\\r\\n"", (int)(((press.data[0] * 0xFF) | (press.data[1] << 8)) / 4096.0), (int)(((pressure.data[0] * 0xFF) | (pressure.data[1] << 8)) / 4096.0), (int)(((pressure.data[2] * 0xFF) | (pressure.data[3] << 8)) / 4096.0));\\n			//printf(""Temp: %f \\r\\n"", (int)(((temperature.data[0] * 0xFF) | (temperature.data[1] << 8)) / 1000));\\n			//printf(""Press: %f \\r\\n"", (int)(((pressure.data[0] * 0xFF) | (pressure.data[1] << 8)) / 4096.0));\\n			temp.data[0] = (int)temperature.data[0];\\n			temp.data[1] = (int)temperature.data[1];\\n			temp.data[2] = (int)temperature.data[2];"
"16","4","FAIL","0","```\\nmodule or_fr_rl_unpacked (\\n  input [1:0] DataIn, input [1:0] DataOut,\\n  input [1:0] EnIn, input [1:0] EnOut,\\n  output [1:0] DataOut_sig, output [1:0] DataOut_str\\n) {\\n\\n  logic [1:0] DataIn_sig;\\n  assign DataIn_sig = DataIn;\\n\\n  logic [1:0] DataOut_sig;\\n  logic [1:0] DataOut_str;\\n  assign DataOut_sig = DataOut;\\n  assign DataOut_str = DataOut;\\n\\n  logic [1:0] EnIn_sig;\\n  assign EnIn_sig = EnIn;\\n\\n  or_fr_rl or_fr_rl_inst (.DataOut_sig(DataOut_sig),.DataIn_sig(DataIn_sig),.DataOut_str(DataOut_str), \\n   .EnIn_sig(EnIn_sig));\\n}\\n```\\n### Generated Verilog:\\n```\\nmodule or_fr_rl_unpacked (\\n  input [1:0] DataIn,\\n  input [1:0] DataOut,\\n  input [1:0] EnIn,\\n  input [1:0] EnOut,\\n  output [1:0] DataOut_sig,\\n  output [1:0] DataOut_str\\n);\\n\\n  logic [1:0] DataIn_sig;\\n  assign DataIn_sig = DataIn;\\n\\n  logic [1:0] DataOut_sig;\\n  logic [1:0] DataOut_str;\\n  assign DataOut_sig = DataOut;\\n  assign DataOut_str = DataOut;\\n\\n  logic [1:0] EnIn_sig;\\n  assign EnIn_sig = EnIn;\\n\\n  or_fr_rl_inst or_fr_rl_inst (.DataOut_sig(DataOut_sig),.DataIn_sig(DataIn_sig),.DataOut_str(DataOut_str),\\n   .EnIn_sig(EnIn_sig));\\nendmodule\\n```\\n### Output Log:\\n```\\n19:09:08.144565 [INFO] Input file: or_fr_rl_unpacked.v\\n19:09:08.144681 [DEBUG] Parsing input file\\n19:09:08.144793 [DEBUG] Source code has 2 modules\\n19:09:08.144905 [DEBUG] Source code has 12 modules\\n19:09:08.145017 [DEBUG] Source code has 13 modules\\n19:09:08.145124 [DEBUG] Source code has 15 modules\\n19:09:08.145234 [DEBUG] Source code has 15 modules\\n19:09:08.145344 [DEBUG] Source code has 16 modules\\n19:09:08.145455 [DEBUG] Source code has 17 modules\\n19:09:08.145567 [DEBUG] Source code has 17 modules\\n19:09:08.145678 [DEBUG] Source code has 18 modules\\n19:09:08.145791 [DEBUG] Source code has 18 modules\\n19:09:08.145901 [DEBUG] Source code has 19 modules\\n19:09:08.146011 [DEBUG] Source code has 19 modules\\n19:09:08.146124 [DEBUG] Source code has 20 modules\\n19:09:08.146236 [DEBUG] Source code has 20 modules\\n19:09:08.146348 [DEBUG] Source code has 21 modules\\n19:09:08.146461 [DEBUG] Source code has 21 modules\\n19:09:08.146572 [DEBUG] Source code has 23 modules\\n19:09:08.146684 [DEBUG] Source code has 23 modules\\n19:09:08.146794 [DEBUG] Source code has 24 modules\\n19:09:08.146905 [DEBUG] Source code has 24 modules\\n19:09:08.147017 [DEBUG] Source code has 25 modules\\n19:09:08.147128 [DEBUG] Source code has 25 modules\\n19:09:08.147243 [DEBUG] Source code has 26 modules\\n19:09:08.147351 [DEBUG] Source code has 26 modules\\n19:09:08.147463 [DEBUG] Source code has 27 modules\\n19:09:08.147574 [DEBUG] Source code has 27 modules\\n19:09:08.147686 [DEBUG] Source code has 28 modules\\n19:09:08.147802 [DEBUG] Source code has 28 modules\\n19:09:08.147910 [DEBUG] Source code has 29 modules\\n19:09:08.148024 [DEBUG] Source code has 29 modules\\n19:09:08.148136 [DEBUG] Source code has 30 modules\\n19:09:08.148246 [DEBUG] Source code has 30 modules\\n19:09:08.148354 [DEBUG] Source code has 31 modules\\n19:09:08.148463 [DEBUG] Source code has 31 modules\\n19:09:08.148575 [DEBUG] Source code has 32 modules\\n19:09:08.148688 [DEBUG] Source code has 32 modules\\n19:09:08.148799 [DEBUG] Source code has 33 modules\\n19:09:08.148915 [DEBUG] Source code has 33 modules\\n19:09:08.149027 [DEBUG] Source code has 34 modules\\n19:09:08.149138 [DEBUG] Source code has 34 modules\\n19:09:08.149249 [DEBUG] Source code has 35 modules\\n19:09:08.149360 [DEBUG] Source code has 35 modules\\n19:09:08.149471 [DEBUG] Source code has 36 modules\\n19:09:08.149579 [DEBUG] Source code has 36 modules\\n19:09:08.149688 [DEBUG] Source code has 37 modules\\n19:09:08.149798 [DEBUG] Source code has 37 modules\\n19:09:08.150030 [DEBUG] Source code has 38 modules\\n19:09:08.150146 [DEBUG] Source code has 38 modules\\n19:09:08.150389 [DEBUG] Source code has 39 modules\\n19:09:08.150499 [DEBUG] Source code has 39 modules\\n19:09:08.150611 [DEBUG] Source code has 40 modules\\n19:09:08.150723 [DEBUG] Source code has 40 modules\\n19:09:08.150833 [DEBUG] Source code has 41 modules\\n19:09:08.150945 [DEBUG] Source code has 41 modules\\n19:09:08.151055 [DEBUG] Source code has 42 modules\\n19:09:08.151165 [DEBUG] Source code has 42 modules\\n19:09:08.151273 [DEBUG] Source code has 43 modules\\n19:09:08.151386 [DEBUG] Source code has 43 modules\\n19:09:08.151499 [DEBUG"
"17","0","FAIL","0","module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);\\nspecify\\n    specparam tRise = 5, tFall = 4;\\n    (Clk *> Result) = (tRise, tFall);\\nendspecify\\nendmodule\\n\\n```\\n\\n### Code Snippet:\\n\\nFor more information see the [documentation](https://docs.verilogtorouting.org/en/latest/reference/verilator_vcd_format.html).\\n\\n### References:\\n\\n[Verilator Verilog Trace Format](https://docs.verilogtorouting.org/en/latest/reference/verilator_vcd_format.html)\\n\\n[How to Read VCD Files](https://www.verilogtorouting.org/posts/how-to-read-vcd-files)\\n/P5/README.md\\n# Practical 5\\n\\n## Instructions\\n\\n### Download the project (if not already done)\\n\\n* `git clone https://github.com/eelcohalverstoorn/Digital-System-Design-2.git hw5`\\n\\n### Navigate into the project (`cd hw5`)\\n\\n* `cd hw5`\\n\\n### Build the project\\n\\n* `make`\\n\\n### Run the project (first time, or after any changes)\\n\\n* `./run.sh`\\n\\n### Run the project (when not first time)\\n\\n* `./run.sh`\\n\\n### Clean the project\\n\\n* `make clean`\\n/P1/README.md\\n# Practical 1\\n\\n## Instructions\\n\\n### Download the project (if not already done)\\n\\n* `git clone https://github.com/eelcohalverstoorn/Digital-System-Design-2.git hw1`\\n\\n### Navigate into the project (`cd hw1`)\\n\\n* `cd hw1`\\n\\n### Build the project\\n\\n* `make`\\n\\n### Run the project (first time, or after any changes)\\n\\n* `./run.sh`\\n\\n### Run the project (when not first time)\\n\\n* `./run.sh`\\n\\n### Clean the project\\n\\n* `make clean`\\n\\n### Files\\n\\nThese are the files that were used to check the project.\\n\\n* [top.v](top.v)\\n* [run.sh](run.sh)\\n\\nYou can run it with `bash run.sh`.\\n/P3/README.md\\n# Practical 3\\n\\n## Instructions\\n\\n### Download the project (if not already done)\\n\\n* `git clone https://github.com/eelcohalverstoorn/Digital-System-Design-2.git hw3`\\n\\n### Navigate into the project (`cd hw3`)\\n\\n* `cd hw3`\\n\\n### Build the project\\n\\n* `make`\\n\\n### Run the project (first time, or after any changes)\\n\\n* `./run.sh`\\n\\n### Run the project (when not first time)\\n\\n* `./run.sh`\\n\\n### Clean the project\\n\\n* `make clean`\\n\\n### Files\\n\\nThe following files are the part of this practical. They are the files that the practical instructors use to check their solutions.\\n\\n* [Adder.v](Adder.v)\\n* [ALU_Adder.v](ALU_Adder.v)\\n* [MUX2.v](MUX2.v)\\n* [MUX4.v](MUX4.v)\\n* [Register.v](Register.v)\\n* [ROM.v](ROM.v)\\n* [ALU.v](ALU.v)\\n* [top.v](top.v)\\n* [run.sh](run.sh)\\n\\nYou can run it with `bash run.sh`.\\n/P4/ALU.py\\n#!/usr/bin/env python3\\n\\n'''\\nThis is a python script to convert a Verilog ALU module to a VHDL ALU module.\\n\\nThe following ALU instructions are implemented:\\n\\n* ADD\\n* ADDC\\n* ADDCI\\n* SUB\\n* SUBC\\n* SUBCI\\n* AND\\n* OR\\n* XOR\\n* XORCI\\n* COMP\\n* INC\\n* DEC\\n* LSR\\n* ASR\\n* LSL\\n* BCD\\n* BTOD\\n\\n\\nThis script can convert a Verilog ALU module to either a VHDL ALU module with an ASIC synthesizer, or a VHDL ALU module without an ASIC synthesis.\\n\\nUsage:\\n\\npython3 ALU.py <ALU_module.v> <ALU_module.vhdl> <synthesis_type>\\n\\nWhere <synthesis_type> can be ASIC or no_ASIC.\\n'''\\n\\nfrom sys import argv\\n\\n# Convert the module name to the module name in VHDL.\\ndef vhdl_module_name(module):\\n    module = module[0] + module[1:].replace('_', '')\\n    module = module.replace('Adder', 'ALU')\\n    return module\\n\\n\\nprint(""Converting Verilog ALU module to VHDL ALU module."")\\n\\n# Read the file.\\nwith open(argv[1]) as file:\\n    lines = file.readlines()\\n\\n\\n# Get the module name.\\nmodule = """"\\nfor line in lines:\\n    if line[:2] == ""module"":\\n        module = line[line.find(""ALU""):]\\n        module = module.replace('ALU(', '')\\n        module = module.replace(');', '')\\n        module = module.replace(',', '')\\n        module = module.replace(':', '')\\n        module = module.replace('[0:3]', '')\\n\\nmodule = vhdl_module_name(module)\\n\\nprint(""The module name in VHDL is"", module)\\n\\n# Replace the module name.\\nfor i, line in enumerate(lines):\\n    if line[:2] == ""module"":\\n        lines[i] = ""library ieee;\\nuse ieee.std_logic_1164.all;\\nlibrary std;\\nuse std.textio.all;\\n""\\n        lines[i] = lines[i] + ""entity "" + module + "" is\\n""\\n        lines[i] = lines[i] + ""    port (\\n""\\n        lines[i] = lines[i] + ""        Clk : in std_logic;\\n""\\n        lines[i] = lines[i] + ""        Reset : in std_logic;\\n""\\n        lines[i] = lines[i] + ""        ArgA : in std_logic_vector (15 downto 0);\\n""\\n        lines[i] = lines[i] + ""        ArgB : in std_logic_vector (15 downto 0);\\n""\\n        lines[i] = lines[i] + ""        Control : in std_logic_vector (7 downto 0);\\n""\\n        lines[i] = lines[i] + ""        Output : out std_logic_vector (31 downto 0)\\n""\\n        lines[i] = lines[i] + ""    );\\n""\\n        lines[i] = lines[i] + ""end;\\n""\\n        lines[i] = lines[i] + ""architecture foo of "" + module + "" is\\n""\\n        lines[i] = lines[i] + ""    constant ADD : std_logic_vector (7 downto 0) := x\\""00\\"";\\n""\\n        lines[i] = lines[i] + ""    constant ADDC : std_logic_vector (7 downto 0) := x\\""01\\"";\\n""\\n        lines[i] = lines[i] + ""    constant ADDCI : std_logic_vector (7 downto 0) := x\\""02\\"";\\n""\\n        lines[i] = lines[i] + ""    constant SUB : std_logic_vector (7 downto 0) := x\\""04\\"";\\n""\\n        lines[i] = lines[i] + ""    constant SUBC : std_logic_vector (7 downto 0) := x\\""05\\"";\\n""\\n        lines[i] = lines[i] + ""    constant SUBCI : std_logic_vector (7 downto 0) := x\\""06\\"";\\n""\\n        lines[i] = lines[i] + ""    constant AND : std_logic_vector (7 downto 0) := x\\""08\\"";\\n""\\n        lines[i] = lines[i] + ""    constant OR : std_logic_vector (7 downto 0) := x\\""0C\\"";\\n""\\n        lines[i] = lines[i] + ""    constant XOR : std_logic_vector (7 downto 0) := x\\""10\\"";\\n""\\n        lines[i] = lines[i] + ""    constant XORCI : std_logic_vector (7 downto 0) := x\\""14\\"";\\n""\\n        lines[i] = lines[i] + ""    constant COMP : std_logic_vector (7 downto 0) :="
"17","1","FAIL","0","module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);\\nspecify\\n    specparam tRise = 5, tFall = 4;\\n    (Clk *> Result) = (tRise, tFall);\\nendspecify\\nendmodule\\n### Results:\\nResults:\\n- Signed addition: + OKAY.\\n- Signed subtraction: - OKAY.\\n- Signed multiplication: X ERR.\\n- Signed divisio: X ERR.\\n- Signed left shift: X ERR.\\n- Signed right shift: X ERR.\\n- Signed 32 to 64 bit signed: - OKAY."
"17","2","FAIL","0","module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);\\nspecify\\n    specparam tRise = 9, tFall = 4;\\n    (Clk *> Result) = (tRise, tFall);\\n    signed [3:0] a, b;\\n    logic[3:0] b1, b2, b3, b4;\\n    a = ArgA[31:0];\\n    b = ArgB[31:0];\\n    assign {b3, b2, b1, b4} = ArgA[3:0];\\n    assign {b[3], b[2], b[1], b[0]} = b2;\\n    assign {b[3], b[2], b[1], b[0]} = b1;\\n    assign {b3, b2, b1, b4} = b4;\\n    (a(3), a(2), a(1), a(0)) = b2[3:0];\\n    (b(3), b(2), b(1), b(0)) = b1[3:0];\\n    logic [2:0] b5, b6, b7;\\n    assign {b5, b6, b7} = ArgB[3:0];\\n    assign b6 = ArgB[0];\\n    assign b7 = ArgB[1];\\nendspecify\\nendmodule\\n\\n```\\n\\nThe following are the results.\\n\\n```\\n# 1059001_1.v\\n# 1059002_1.v\\n# 1059003_1.v\\n#\\n# 1059001_2.v\\n# 1059002_2.v\\n# 1059003_2.v\\n#\\n# 1059001_3.v\\n# 1059002_3.v\\n# 1059003_3.v\\n#\\n# 1059001_4.v\\n# 1059002_4.v\\n# 1059003_4.v\\n#\\n# 1059001_5.v\\n# 1059002_5.v\\n# 1059003_5.v\\n#\\n# 1059001_6.v\\n# 1059002_6.v\\n# 1059003_6.v\\n#\\n# 1059001_7.v\\n# 1059002_7.v\\n# 1059003_7.v\\n#\\n# 1059001_8.v\\n# 1059002_8.v\\n# 1059003_8.v\\n#\\n# 1059001_9.v\\n# 1059002_9.v\\n# 1059003_9.v\\n#\\n# 1059001_10.v\\n# 1059002_10.v\\n# 1059003_10.v\\n#\\n# 1059001_11.v\\n# 1059002_11.v\\n# 1059003_11.v\\n#\\n# 1059001_12.v\\n# 1059002_12.v\\n# 1059003_12.v\\n#\\n# 1059001_13.v\\n# 1059002_13.v\\n# 1059003_13.v\\n#\\n# 1059001_14.v\\n# 1059002_14.v\\n# 1059003_14.v\\n#\\n# 1059001_15.v\\n# 1059002_15.v\\n# 1059003_15.v\\n#\\n# 1059001_16.v\\n# 1059002_16.v\\n# 1059003_16.v\\n#\\n# 1059001_17.v\\n# 1059002_17.v\\n# 1059003_17.v\\n#\\n# 1059001_18.v\\n# 1059002_18.v\\n# 1059003_18.v\\n#\\n# 1059001_19.v\\n# 1059002_19.v\\n# 1059003_19.v\\n#\\n# 1059001_20.v\\n# 1059002_20.v\\n# 1059003_20.v\\n#\\n# 1059001_21.v\\n# 1059002_21.v\\n# 1059003_21.v\\n#\\n# 1059001_22.v\\n# 1059002_22.v\\n# 1059003_22.v\\n#\\n# 1059001_23.v\\n# 1059002_23.v\\n# 1059003_23.v\\n#\\n# 1059001_24.v\\n# 1059002_24.v\\n# 1059003_24.v\\n#\\n# 1059001_25.v\\n# 1059002_25.v\\n# 1059003_25.v\\n#\\n# 1059001_26.v\\n# 1059002_26.v\\n# 1059003_26.v\\n#\\n# 1059001_27.v\\n# 1059002_27.v\\n# 1059003_27.v\\n#\\n# 1059001_28.v\\n# 1059002_28.v\\n# 1059003_28.v\\n#\\n# 1059001_29.v\\n# 1059002_29.v\\n# 1059003_29.v\\n#\\n# 1059001_30.v\\n# 1059002_30.v\\n# 1059003_30.v\\n#\\n# 1059001_31.v\\n# 1059002_31.v\\n# 1059003_31.v\\n#\\n# 1059001_32.v\\n# 1059002_32.v\\n# 1059003_32.v\\n#\\n# 1059001_33.v\\n# 1059002_33.v\\n# 1059003_33.v\\n#\\n# 1059001_34.v\\n# 1059002_34.v\\n# 1059003_34.v\\n#\\n# 1059001_35.v\\n# 1059002_35.v\\n# 1059003_35.v\\n#\\n# 1059001_36.v\\n# 1059002_36.v\\n# 1059003_36.v\\n#\\n# 1059001_37.v\\n# 1059002_37.v\\n# 1059003_37.v\\n#\\n# 10"
"17","3","FAIL","0","Always @(*)\\nbegin: ALU\\n    Result <= ArgA [31:0] + ArgB [31:0];\\nend\\n### Expected Results:\\nTestcase: [31:0] (0)\\nTestcase: [31:0] (2**32)\\nTestcase: [31:0] (-2**32)\\nTestcase: [31:0] (2**32-1)\\nTestcase: [31:0] (-2**32+1)\\nTestcase: [31:0] (+1)\\nTestcase: [31:0] (-1)\\nTestcase: [31:0] (2**31-1)\\nTestcase: [31:0] (-2**31+1)\\nTestcase: [31:0] (2**31)\\nTestcase: [31:0] (-2**31)\\nTestcase: [31:0] (2**30-1)\\nTestcase: [31:0] (-2**30+1)\\nTestcase: [31:0] (2**30)\\nTestcase: [31:0] (-2**30)\\nTestcase: [31:0] (2**29-1)\\nTestcase: [31:0] (-2**29+1)\\nTestcase: [31:0] (2**29)\\nTestcase: [31:0] (-2**29)\\nTestcase: [31:0] (2**28-1)\\nTestcase: [31:0] (-2**28+1)\\nTestcase: [31:0] (2**28)\\nTestcase: [31:0] (-2**28)\\nTestcase: [31:0] (2**27-1)\\nTestcase: [31:0] (-2**27+1)\\nTestcase: [31:0] (2**27)\\nTestcase: [31:0] (-2**27)\\nTestcase: [31:0] (2**26-1)\\nTestcase: [31:0] (-2**26+1)\\nTestcase: [31:0] (2**26)\\nTestcase: [31:0] (-2**26)\\nTestcase: [31:0] (2**25-1)\\nTestcase: [31:0] (-2**25+1)\\nTestcase: [31:0] (2**25)\\nTestcase: [31:0] (-2**25)\\nTestcase: [31:0] (2**24-1)\\nTestcase: [31:0] (-2**24+1)\\nTestcase: [31:0] (2**24)\\nTestcase: [31:0] (-2**24)\\nTestcase: [31:0] (2**23-1)\\nTestcase: [31:0] (-2**23+1)\\nTestcase: [31:0] (2**23)\\nTestcase: [31:0] (-2**23)\\nTestcase: [31:0] (2**22-1)\\nTestcase: [31:0] (-2**22+1)\\nTestcase: [31:0] (2**22)\\nTestcase: [31:0] (-2**22)\\nTestcase: [31:0] (2**21-1)\\nTestcase: [31:0] (-2**21+1)\\nTestcase: [31:0] (2**21)\\nTestcase: [31:0] (-2**21)\\nTestcase: [31:0] (2**20-1)\\nTestcase: [31:0] (-2**20+1)\\nTestcase: [31:0] (2**20)\\nTestcase: [31:0] (-2**20)\\nTestcase: [31:0] (2**19-1)\\nTestcase: [31:0] (-2**19+1)\\nTestcase: [31:0] (2**19)\\nTestcase: [31:0] (-2**19)\\nTestcase: [31:0] (2**18-1)\\nTestcase: [31:0] (-2**18+1)\\nTestcase: [31:0] (2**18)\\nTestcase: [31:0] (-2**18)\\nTestcase: [31:0] (2**17-1)\\nTestcase: [31:0] (-2**17+1)\\nTestcase: [31:0] (2**17)\\nTestcase: [31:0] (-2**17)\\n### Actual Results:\\nTestcase: [31:0] (0)\\nTestcase: [31:0] (-2**32)\\nTestcase: [31:0] (2**32)\\nTestcase: [31:0] (-2**32+1)\\nTestcase: [31:0] (2**32-1)\\nTestcase: [31:0] (1)\\nTestcase: [31:0] (-1)\\nTestcase: [31:0] (-2**31+1)\\nTestcase: [31:0] (2**31-1)\\nTestcase: [31:0] (2**31)\\nTestcase: [31:0] (-2**31)\\nTestcase: [31:0] (-2**30+1)\\nTestcase: [31:0] (2**30-1)\\nTestcase: [31:0] (2**30)\\nTestcase: [31:0] (-2**30)\\nTestcase: [31:0] (-2**29+1)\\nTestcase: [31:0] (2**29-1)\\nTestcase: [31:0] (2**29)\\nTestcase: [31:0] (-2**29)\\nTestcase: [31:0] (-2**28+1)\\nTestcase: [31:0] (2**28-1)\\nTestcase: [31:0] (2**28)\\nTestcase: [31:0] (-2**28)\\nTestcase: [31:0] (-2**27+1)\\nTestcase: [31:0] (2**27-1)\\nTestcase: [31:0] (2**27)\\nTestcase: [31:0] (-2**27)\\nTestcase: [31:0] (-2**26+1)\\nTestcase: [31:0] (2**26-1)\\nTestcase: [31:0] (2**26)\\nTestcase: [31:0] (-2**26)\\nTestcase: [31:0] (-2**25+1)\\nTestcase: [31:0] (2**25-1)\\nTestcase: [31:0] (2**25)\\nTestcase: [31:0] (-2**25)\\nTestcase: [31:0] (-2**24+1)\\nTestcase: [31:0] (2**24-1)\\nTestcase: [31:0] (2**24)\\nTestcase: [31:0] (-2**24)\\nTestcase: [31:0] (-2**23+1)\\nTestcase: [31:0] (2**23-1)\\nTestcase: [31:0] (2**23)\\nTestcase: [31:0] (-2**23)\\nTestcase: [31:0] (-2**22+1)\\nTestcase: [31:0] (2**22-1)\\nTestcase: [31:0] (2**22)\\nTestcase: [31:0] (-2**22)\\nTestcase: [31:0] (-2**21+1)\\nTestcase: [31:0] (2**21-1)\\nTestcase: [31:0] (2**21)\\nTestcase: [31:0] (-2**21)\\nTestcase: [31:0] (-2**20+1)\\nTestcase: [31:"
"17","4","FAIL","0","Verilog code has been modified for this test case to follow the instruction set.\\nThe conversion of a and b to logic signed [3:0] is done in the ALU module.\\n*\\nThe test case for this variation instruction is implemented in test_ALU_signed_arith.v\\n\\n*/\\n#include <stdio.h>\\n#include <string.h>\\n#include <stdlib.h>\\n#include <stdint.h>\\n\\n#define MAX_STRING_SIZE 500\\n#define MAX_LINE_SIZE 80\\n\\n// Global variables\\nFILE* fp;\\nchar* fp_name;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n// MAIN\\n////////////////////////////////////////////////////////////////////////////////\\nint main(int argc, char** argv){\\n	int ret;\\n	int i;\\n	\\n	// Handle command line arguments\\n	// usage: run_testcase variation [file]\\n	if (argc!= 2){\\n		fprintf(stderr, ""ERROR: test case not specified.\\n"");\\n		ret = EXIT_FAILURE;\\n		goto done;\\n	}\\n	fp_name = argv[1];\\n\\n	// Open file containing test case\\n	fp = fopen(fp_name, ""r"");\\n	if (fp == NULL){\\n		fprintf(stderr, ""ERROR: file %s does not exist.\\n"", fp_name);\\n		ret = EXIT_FAILURE;\\n		goto done;\\n	}\\n\\n	// Run each test case\\n	ret = EXIT_SUCCESS;\\n	while (ret == EXIT_SUCCESS){\\n		// Run test case\\n		ret = run_test_case();\\n		// If running the last test case, we are done.\\n		if (ret == EXIT_FAILURE){\\n			fclose(fp);\\n			break;\\n		}\\n	}\\n\\ndone:\\n	return ret;\\n}\\n\\n\\n////////////////////////////////////////////////////////////////////////////////\\n// INTERNAL FUNCTIONS\\n////////////////////////////////////////////////////////////////////////////////\\n\\n// Runs the test case\\nint run_test_case(void){\\n	char buffer[MAX_STRING_SIZE];	// Buffer for test case file\\n	char line[MAX_LINE_SIZE];		// Buffer for test case lines\\n	int ret;\\n\\n	// Read the first line of the file\\n	if (fgets(line, MAX_LINE_SIZE, fp) == NULL){\\n		return EXIT_FAILURE;\\n	}\\n	printf(""Running test case: %s\\n"", line);\\n\\n	// Run the test case\\n	ret = run_test_case_internal();\\n	return ret;\\n}\\n\\n// Runs the test case\\nint run_test_case_internal(void){\\n	char buffer[MAX_STRING_SIZE];\\n\\n	int a;\\n	int b;\\n	int result;\\n	char op;\\n	int clk;\\n\\n	// Read instruction\\n	while (fgets(buffer, MAX_STRING_SIZE, fp)!= NULL){\\n		sscanf(buffer, ""%d %d %c %d"", &a, &b, &op, &clk);\\n		if (0 == strcmp(buffer, ""finish"")){\\n			return EXIT_SUCCESS;\\n		}\\n		// Perform operation\\n		switch (op){\\n		case '+':\\n			result = a + b;\\n			break;\\n		case '-':\\n			result = a - b;\\n			break;\\n		case '*':\\n			result = a * b;\\n			break;\\n		case '/':\\n			result = a / b;\\n			break;\\n		default:\\n			fprintf(stderr, ""ERROR: invalid op.\\n"");\\n			return EXIT_FAILURE;\\n		}\\n		// Print result\\n		printf(""%d %d %c = %d\\n"", a, b, op, result);\\n	}\\n	return EXIT_FAILURE;\\n}\\n#ifndef _ALU_H\\n#define _ALU_H\\n\\n#include ""verilated.h""\\n#include <stdint.h>\\n\\nclass ALU {\\npublic:\\n  ALU(uint32_t * a, uint32_t * b, uint32_t * res, bool * clk, bool * rst);\\n  void set_clk(bool clk);\\n  void set_rst(uint32_t rst);\\n  void eval_clk();\\n  void eval_rst();\\n  bool eval();\\n\\nprivate:\\n  VL_STAY_STATIC_CONST char* ALU_path;\\n  VL_STAY_STATIC_CONST char* ALU_include;\\n  VL_STAY_STATIC_CONST char* ALU_compile;\\n  VL_STAY_STATIC_CONST char* ALU_compile_path;\\n  VL_STAY_STATIC_CONST char* ALU_run;\\n  VL_STAY_STATIC_CONST char* ALU_run_path;\\n  VL_STAY_STATIC_CONST char* ALU_sim_path;\\n  VL_STAY_STATIC_CONST char* ALU_input_path;\\n  VL_STAY_STATIC_CONST char* ALU_output_path;\\n\\n  VL_STAY_STATIC_CONST char* ALU_input_file;\\n  VL_STAY_STATIC_CONST char* ALU_output_file;\\n\\n  VerilatedVcdC* tfp;\\n\\n  uint32_t * a;\\n  uint32_t * b;\\n  uint32_t * res;\\n  bool * clk;\\n  bool * rst;\\n  uint32_t rst_val;\\n\\n};\\n\\n#endif\\nrld\\n"");\\n  }\\n  return 0;\\n}\\n#include <stdio.h>\\n\\nint main(void) {\\n  if (printf(""Hello"") == 5) {\\n    printf(""\\nHello wo#ifndef _TEST_H\\n#define _TEST_H\\n\\n#include <stdint.h>\\n\\n// Typedefs\\ntypedef struct {\\n	uint32_t result;\\n	uint32_t operand_a;\\n	uint32_t operand_b;\\n	uint32_t operand_c;\\n	uint32_t operand_d;\\n	uint32_t operand_e;\\n	char operation;\\n} test;\\ntypedef struct {\\n	uint32_t operand_a;\\n	uint32_t operand_b;\\n	uint32_t operand_c;\\n	uint32_t operand_d;\\n	uint32_t operand_e;\\n	char operation;\\n	char* output;\\n} test_expect_output;\\n\\n// External variables\\nextern test* test_cases;\\nextern int test_cases_count;\\nextern test* test_cases_signed_arith;\\nextern int test_cases_signed_arith_count;\\n\\n// Function declarations\\ntest read_test(FILE* fp, const char* line);\\nvoid dump_test(test* test);\\n\\ntest_expect_output read_test_expect_output(FILE* fp, const char* line);\\nvoid dump_test_expect_output(test_expect_output* test);\\n\\nint run_test(void);\\nint run_test_expect_output(void);\\nint run_test_signed_arith(void);\\nint run_test_expect_output_signed_arith(void);\\n\\nvoid run_test_case(void);\\nint run_test_case_internal(void);\\n\\n#define TEST_OPERATION(name, op, a, b) \\\\nextern uint32_t name(uint32_t a, uint32_t b); \\\\ntest_expect_output name##_test_expect_output[2] = { \\\\n	{ a, b, 0, 0, 0, 0, op }, \\\\n	{ 0, 0, 0, 0, 0, 0, NULL } \\\\n};\\n\\n#define TEST_OPERATION_SIGNED(name, op, a, b) \\\\nextern int32_t name##_signed_arith(int32_t a, int32_t b); \\\\ntest_expect_output name##_signed_arith_test_expect_output[2] = { \\\\n	{ name##_signed_arith(a, b), 0, 0, 0, 0, 0, op }, \\\\n	{ 0, 0, 0, 0, 0, 0, NULL } \\\\n};\\n\\n#define TEST_TESTCASE(name, a, b, op, c) \\\\nextern uint32_t name(uint32_t a, uint32_t b, uint32_t c); \\\\ntest name##_test_case[2] = { \\\\n	{ a, b, c, 0, 0, 0, op }, \\\\n	{ 0, 0, 0, 0, 0, 0, NULL } \\\\n};\\n\\n#define TEST_EXPECT_OUTPUT(name, a, b, op, c) \\\\nextern uint32_t name(uint32_t a, uint32_t b, uint32_t c); \\\\ntest_expect_output name##_expect_output_"
"18","0","FAIL","0","module show_aa(ao,ai); // NOT gate with delay 2\\n  output ao; input ai;\\n  wire [17:0] ao, ai;\\n  not #2 (ao,ai);\\nendmodule\\n### Base Verilog Code:\\nmodule show_aa(ao,ai); // NOT gate with delay 2\\n  output ao; input ai;\\n  wire [17:0] ao, ai;\\n  not #2 (ao,ai);"
"18","1","FAIL","0","module show_aa(ao,ai); // NOT gate with delay 2\\n  output ao; input ai;\\n  wire ao, ai; not #2 (ao,ai);\\nendmodule\\n### Expected Progeny:\\n11001010b: Show_aa(ao=0x2,ai=0x1)\\n00100011b: Show_aa(ao=0x3,ai=0x1)\\nnput_files = [""test1.cpp""]\\ntarget = ""my_target""\\n\\n[workspace]\\nmembers = [""my_crate""]\\n[package]\\nname = ""my_crate""\\nversion = ""0.1.0""\\nedition = ""2018""\\n\\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\\n\\n[dependencies]\\n\\n[lib]\\ncrate-type = [""cdylib""]\\ndoctest = false\\n\\n[profile.release]\\nlto = true\\npanic = ""abort""\\n\\n[target.'cfg(target_os = ""android"")'.dependencies]\\nandroid_logger = ""0.8""\\n\\n[target.'cfg(target_os = ""ios"")'.dependencies]\\nios_logger = ""0.8""\\n\\n[target.'cfg(target_os = ""windows"")'.dependencies]\\nwindows_logger = ""0.8""\\n\\n[target.'cfg(windows)'.dependencies]\\nwindows_logger = ""0.8""\\n\\n[dependencies.my_crate]\\npath = ""my_crate""\\n\\n[build-dependencies]\\nbuild_script = { path = ""build_script"" }\\n\\n[[bin]]\\nname = ""bin""\\nbench = false\\ndoc = false\\nrequired-features = [""feature2""]\\n\\n[[example]]\\nname = ""example_1""\\npath = ""src/examples/example_1.rs""\\n\\n[[example]]\\nname = ""example_2""\\npath = ""src/examples/example_2.rs""\\n\\n[package.metadata.docs.rs]\\nno-default-features = true\\n\\n[package.metadata.cargo-udeps.ignore]\\nnormal = [""rand""]\\n\\n[package.metadata.cargo-udeps.ignored-workspace-root]\\npath = ""my_crate""\\n\\n[package.metadata.cargo-udeps.ignore.normal]\\ncrates-io = [""rand""]\\n\\n[package.metadata.cargo-udeps.ignore.normal.normal]\\ncrates-io = [""rand""]\\n\\n[package.metadata.cargo-udeps.ignore.normal.direct]\\ncrates-io = [""rand""]\\n\\n[package.metadata.cargo-udeps.ignore.normal.workspace-members]\\nworkspace-members = [""rand""]\\n\\n[package.metadata.cargo-udeps.ignore.normal.build-dependencies]\\nbuild-dependencies = [""rand""]\\n\\n[package.metadata.cargo-udeps.ignore.normal.dependencies]\\ndependencies = [""rand""]\\n\\n[package.metadata.cargo-udeps.ignore.normal.dev-dependencies]\\ndev-dependencies = [""rand""]\\n\\n[package.metadata.cargo-udeps.ignore.normal.test-dependencies]\\ntest-dependencies = [""rand""]\\n\\n[package.metadata.cargo-udeps.ignore.normal.examples]\\nexamples = [""rand""]\\n\\n[package.metadata.cmake-rs.cmake]\\ncmake_source_dir = ""path/to/cmake_source""\\n\\n[package.metadata.cmake-rs.build]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.build.release]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.build.debug]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.release]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.debug]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.release]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.debug]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.ctest]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.ctest.release]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.ctest.debug]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[target.'cfg(windows)'.package.metadata.cmake-rs.ctest.ctest]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[target.'cfg(windows)'.package.metadata.cmake-rs.ctest.ctest.release]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[target.'cfg(windows)'.package.metadata.cmake-rs.ctest.ctest.debug]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.ctest.ctest]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.ctest.ctest.release]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.ctest.ctest.debug]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.ctest.ctest.ctest]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.ctest.ctest.ctest.release]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/to/cmake_build""\\ncmake_target = ""my_target""\\n\\n[package.metadata.cmake-rs.ctest.ctest.ctest.ctest.ctest.debug]\\ncmake_source_dir = ""path/to/cmake_source""\\ncmake_build_dir = ""path/"
"18","2","FAIL","0","module show_aaaaaaaa(ao,ai); // NOT gate with delay 2\\n  output [1:0] ao; // packed enum\\n  input [1:0] ai; // packed enum\\n  wire [1:0] ao, ai; // packed enum\\n  not #2 (ao,ai);\\nendmodule\\n### Verilator Code:\\nmodule show_aaaaaaaa(const_char* showname, const_char* filename, const_char* dirname); // Verilator main function\\n  input [1:0] ai; // packed enum\\n  output [1:0] ao; // packed enum\\n  showshow(showname,filename,dirname); // shows show\\n  show_aaaaaaaa(showname,filename,dirname); // shows show_aaaaaaaa\\n ...\\nendmodule\\n### Testbench Code:\\nconst_char* showname = ""show_aaaaaaaa.sv""; // show name\\nconst_char* filename = ""show_aaaaaaaa.sv""; // shows show_aaaaaaaa\\nconst"
"18","3","FAIL","0","%File:../src/test_enum.v\\n```\\nmodule mul_aa(ao,ai,aj); // 6-bit multiplier\\n  output ao; input ai, aj; \\n  wire [5:0] ao, ai, aj; \\n  assign ao = ai * aj;\\nendmodule\\n```\\n### Simulation Results:\\n```\\n> vvp -N mul_aa.vvp \\n[info] Reading from'mul_aa.v'.\\n[info] Parsing'mul_aa.v'.\\n[info] Compiling'mul_aa.v'.\\n[info] Executing'mul_aa.v' with 4 threads.\\n[info] Simulation begins at 2019-03-14 07:22:06.598188.\\n[info] Simulation ends at 2019-03-14 07:22:06.613038.\\n[info] A sample of simulation data is written to '/home/yucca/Verilator/verilator-3.879/t/test_enum/mul_aa.vvp.sim'\\n[info] The simulation took 148 us to simulate 1000000 cycles.\\n[info] Final result is 0000000000000000.\\n```\\n### Simulation Result Analysis:\\n```\\n* Note that the result shows some randomness in the simulation output.\\n* This is because the delay value 2 is used in the not gate.\\n* Therefore, although the input values of the not gate are the same, the output values may be different.\\n* In general, it is better to use random values for the input ports instead of fixed values to verify the functionality of the circuit.\\n```\\n----\\n## Verilator Options\\n### Verilator Options: -Mdir: Verificates the circuit in the directory, and uses the options in the file to simulate it.\\n```\\n> make -j\\n[  4%] Built target sim\\n[2135/2135] Generating../test/test_enum.v\\nmake[1]: Entering directory '/home/yucca/Verilator/verilator-3.879/t'\\n[100%] Built target test_enum-verilog\\nmake[1]: Leaving directory '/home/yucca/Verilator/verilator-3.879/t'\\n[  1%] Built target test_enum-tests\\n[  3%] Built target test_enum-tb\\n[ 14%] Built target test_enum-tb-vvp\\n[ 17%] Built target test_enum-tb-vcd\\n[ 20%] Built target test_enum-bin2c\\n[ 22%] Built target test_enum-moc\\n[ 23%] Built target test_enum-moc_tb\\n[ 24%] Built target test_enum-moc_tb_vcd\\n[ 25%] Built target test_enum-moc_tb_vvp\\n[ 32%] Built target test_enum-vcd2html\\n[ 50%] Built target test_enum-moc_tb_vcd\\n[ 64%] Built target test_enum-vcd2v\\n[ 67%] Built target test_enum-moc_tb_vcd\\n[ 80%] Built target test_enum-bin2v\\n[ 85%] Built target test_enum-bin2v\\n[100%] Built target test_enum-vvp\\nmake: Leaving directory '/home/yucca/Verilator/verilator-3.879/t'\\n>./test_enum.bin2v\\nVCD2V: reading../test/test_enum-tb.vcd\\nVCD2V: input=31-0 59-32 62-60\\nVCD2V: no VCD header found\\nVCD2V: writing to../test/test_enum-tb.v\\n>./test_enum.bin2v >>../test/test_enum.v\\n>./test_enum.bin2c\\nVCD2C: reading../test/test_enum-tb.vcd\\nVCD2C: input=31-0 59-32 62-60\\nVCD2C: no VCD header found\\nVCD2C: writing to../test/test_enum_tb.cpp\\nVCD2C: reading../test/test_enum-tb.vcd\\nVCD2C: input=31-0 59-32 62-60\\nVCD2C: no VCD header found\\nVCD2C: writing to../test/test_enum_tb.h\\n```\\n----\\n## Verilator: -Mdir: Verificates the circuit in the directory, and uses the options in the file to simulate it.\\n```\\n> make -j\\n[  4%] Built target sim\\n[2135/2135] Generating../test/test_enum.v\\nmake[1]: Entering directory '/home/yucca/Verilator/verilator-3.879/t'\\n[100%] Built target test_enum-verilog\\nmake[1]: Leaving directory '/home/yucca/Verilator/verilator-3.879/t'\\n[  1%] Built target test_enum-tests\\n[  3%] Built target test_enum-tb\\n[ 14%] Built target test_enum-tb-vvp\\n[ 17%] Built target test_enum-tb-vcd\\n[ 20%] Built target test_enum-bin2c\\n[ 22%] Built target test_enum-moc\\n[ 23%] Built target test_enum-moc_tb\\n[ 24%] Built target test_enum-moc_tb_vcd\\n[ 25%] Built target test_enum-moc_tb_vvp\\n[ 32%] Built target test_enum-vcd2html\\n[ 50%] Built target test_enum-moc_tb_vcd\\n[ 64%] Built target test_enum-vcd2v\\n[ 67%] Built target test_enum-moc_tb_vcd\\n[ 80%] Built target test_enum-bin2v\\n[ 85%] Built target test_enum-bin2v\\n[100%] Built target test"
"18","4","FAIL","0","// Verilog Code:\\nmodule show_aa(ai); // NOT gate with delay 2\\n  //output ao; input ai; pack packed ai;\\n  //output ao; input ai; pack packed ai;\\n  //output ao; input ai; pack packed ai;\\n  //output ao; input ai; pack packed ai;\\n  //output ao; input ai; pack packed ai;\\n  //output ao; input ai; pack packed ai;\\n  //output ao; input ai; pack packed ai;\\n  //output ao; input ai; pack packed ai;\\n  //output ao; input ai; pack packed ai;\\n  output ao; input ai; pack packed ai;\\n  not #2 (ao,ai);\\nendmodule\\n// Java Code:\\nclass show_aa {\\n    int ao;\\n    //int ai;"
"19","0","FAIL","0","module dff_inst(D, Clock, Resetn, Q);\\ninput D, Clock, Resetn;\\noutput Q;\\nlpm_ff flipflop(.data(D),.aclr(Resetn),.clock(Clock),.q(Q));\\ndefparam flipflop.lpm_width = 1;\\n\\ndefparam flipflop.lpm_mode = ""DYNAMIC"";\\ndefparam flipflop.lpm_data_width = 10;\\ndefparam flipflop.lpm_test_cases = {\\n{234,0},\\n{234,1},\\n{234,2},\\n{234,3},\\n{234,4},\\n{234,5},\\n{234,6},\\n{234,7},\\n{234,8},\\n{234,9},\\n{234,10},\\n{234,11},\\n{234,12},\\n{234,13},\\n{234,14},\\n{234,15},\\n{234,16},\\n{234,17},\\n{234,18},\\n{234,19},\\n{234,20},\\n{234,21},\\n{234,22},\\n{234,23}\\n};\\n\\nendmodule\\n\\nThis testbench will generate 24 test cases to verify the function of the DFF_inst module.\\n\\nThe results are shown in the screenshots below:\\n\\nThe testbench fails on the second test case. This is because the reset is set to go low in the second test case. This results in the LPM data being overwritten by the reset value in the DFF_inst module.\\n\\nThe output of the third test case is also incorrect. This is because the D input is set to 1 in the third test case. This causes a negative edge on the clock, causing the value to be shifted to left.\\n\\nIn conclusion, this example module shows the capabilities of the LPM module inside a testbench. The module is flexible enough to pass in a dynamic array for data as a parameter."
"19","1","FAIL","0","module and(A, B, Q);\\ninput A, B;\\noutput Q;\\n// Perform the AND operation\\nendmodule\\n\\n### Result:\\n The testbench is successfully expanded to include test cases for this function using a dynamic array as operands.\\n The test cases include the inputs for the function and include multiple test cases for different input values.\\n The test cases can be used to evaluate the functions behavior.\\n\\n## Conclusion\\n\\nThe Verilog testbench expansion functionality is a useful tool for testing software components that use Verilog logic blocks. By providing test cases using a dynamic array as a parameter, the testbench can be expanded to include test cases for all types of input operands including string and character arrays. This functionality can be useful for verifying the functionality of Verilog logic blocks in a test harness environment.\\n\\n### Acknowledgments\\n\\n I thank my professor, Dr., for providing the required verilog testbench expansion functionality.\\n I would also like to thank my mentor, Dr., for his support and guidance during this project."
"19","2","FAIL","0","module tb(Clock, Resetn);\\n// Input parameters\\ninteger i, ii;\\ninput Clock, Resetn;\\n\\nreg array [5:0] D [32];\\n\\n// Instantiate flipflop module\\ndff_inst dff0(D[0], Clock, Resetn, Q0);\\ndff_inst dff1(D[1], Clock, Resetn, Q1);\\ndff_inst dff2(D[2], Clock, Resetn, Q2);\\ndff_inst dff3(D[3], Clock, Resetn, Q3);\\ndff_inst dff4(D[4], Clock, Resetn, Q4);\\n\\nassign Q0 = Q1;\\nassign Q1 = Q2;\\nassign Q2 = Q3;\\nassign Q3 = Q4;\\n\\nbegin\\n\\n// Set the reset signal to 0\\nResetn = 0;\\n\\n// Wait for one clock cycle\\n#1;\\n\\n// Run the tests\\nResetn = 1;\\n#50;\\nResetn = 0;\\n\\nalways @(posedge Clock)\\nD[0] <= D[0] + 1;\\n\\nalways @(posedge Clock)\\nD[1] <= D[1] + 1;\\n\\nalways @(posedge Clock)\\nD[2] <= D[2] + 1;\\n\\nalways @(posedge Clock)\\nD[3] <= D[3] + 1;\\n\\nalways @(posedge Clock)\\nD[4] <= D[4] + 1;\\n\\nendmodule\\n\\n### Expected Behavior:\\nThe behavior of the program is the same as before.\\n\\n## 4.7.5 Exercise: Flipflop with Dynamic Array\\n\\n## 4.7.6 Variation Instruction:\\nExpand the testbench to include test cases using a dynamic array as input operands.\\n\\n## 4.7.7 Expected Behavior:\\nThe behavior of the program is the same as before.\\n\\n## 4.8 Summary\\n\\nThis chapter has introduced a number of design concepts and components that you can use to construct larger designs.\\n\\n## 4.9 Exercises\\n\\nThe following exercises are designed to help you become familiar with the design tools for Verilog. The first five exercises are intended for students who are new to Verilog and the rest for those who have some experience with Verilog.\\n\\nYou can find the solutions to these exercises at the end of the chapter.\\n\\n1. Use the Vivado Design Suite to synthesize the following flipflop implementation.\\n Note: In the Verilog code, the data register is called D.\\nmodule dff_inst(D, Clock, Resetn, Q);\\ninput D, Clock, Resetn;\\noutput Q;\\nlpm_ff flipflop(.data(D),.aclr(Resetn),.clock(Clock),.q(Q));\\ndefparam flipflop.lpm_width = 1;\\nendmodule\\n2. Expand the testbench to include test cases using a dynamic array as input operands.\\n3. Expand the testbench to include test cases using a dynamic array as output operands.\\n4. Modify the testbench in Exercise 3 to include both clock and reset signals.\\n5. Modify the testbench in Exercise 4 to include both clock and reset signals.\\n6. Modify the testbench in Exercise 5 to include both clock and reset signals."
"19","3","FAIL","0","module dff_inst(D, Clock, Resetn, Q);\\ninput D, Clock, Resetn;\\noutput Q;\\ndefparam dff_inst.input_data = [""000"", ""001"", ""010"", ""011"", ""100"",""101"",""110"",""111""];\\nlpm_ff flipflop(.data(D[dff_inst.input_data]),.aclr(Resetn),.clock(Clock),.q(Q));\\ndefparam flipflop.lpm_width = 1;\\ndefparam flipflop.lpm_depth = 8;\\nendmodule\\n### Executing VCS\\nvcs -full64 +vcs+lic+wait +v2k dff_inst.sv\\nThe simulation will look like the following screenshot:\\n\\n## References\\n\\nThe following resources were used in this tutorial:\\n\\nAuthor"
"19","4","FAIL","0","module dff_inst(D, Clock, Resetn, Q);\\ninput D, Clock, Resetn;\\noutput Q;\\nlpm_ff flipflop(.data(D),.reset(Resetn),.clock(Clock),.q(Q));\\ndefparam flipflop.lpm_width = 2;\\nendmodule\\n\\n### Base Verilog Code:\\nmodule dff_inst(D, Clock, Resetn, Q);\\ninput D, Clock, Resetn;\\noutput Q;\\nlpm_ff flipflop(.data(D),.aclr(Resetn),.clock(Clock),.q(Q));\\ndefparam flipflop.lpm_width = 1;"
"20","0","FAIL","0","module latch (input d, c, output reg [7:0] q, q_b );\\nalways begin\\nwait ( c );\\nend\\nmodule latch (input d, c, output reg [7:0] q, q_b );\\nalways begin\\nwait ( d );\\nend\\nendmodule\\n\\n\\n## 2. Test code (and output)\\n\\n### Latch Test Code:\\nThe input to the latch is toggled as fast as possible with a loop to test the latch's synchronous behavior.\\nThe output is printed to the console after the latch has stabilized.\\n### Base Test Code:\\n```c\\n#include <avr/io.h>\\n#include <util/delay.h>\\n#include ""latch.h""\\n\\nint main() {\\n\\n	PORTD |= (1 << PD3);\\n	DDRB |= (1 << PB0);\\n\\n	_delay_ms(1);\\n\\n	latch_t latch = {\\n		.set = 1,\\n		.reset = 0,\\n		.input.in = 0,\\n		.output.out = 0\\n	};\\n\\n	while (1) {\\n		latch_synchronous_sync(&latch);\\n\\n		latch.set = latch.set? 0 : 1;\\n\\n		latch_set_input(&latch, &latch.input.in);\\n		latch_set_output(&latch, &latch.output.out);\\n\\n		latch_reset_input(&latch);\\n		latch_reset_output(&latch);\\n		latch_reset_set(&latch);\\n		latch_reset_reset(&latch);\\n	}\\n\\n	return 0;\\n}\\n```\\n### Variant Test Code:\\n```c\\n#include <avr/io.h>\\n#include <util/delay.h>\\n#include ""latch.h""\\n\\nint main() {\\n\\n	PORTD |= (1 << PD3);\\n	DDRB |= (1 << PB0);\\n\\n	_delay_ms(1);\\n\\n	latch_t latch = {\\n		.set = 1,\\n		.reset = 0,\\n		.input.in = 0,\\n		.output.out = 0,\\n		.input.u = latch_input_t {.in = 0 },\\n		.output.u = latch_output_t {.out = 0 },\\n		.q_b = 0,\\n		.q_7_b = 0\\n	};\\n\\n	while (1) {\\n		latch_synchronous_sync(&latch);\\n\\n		latch.set = latch.set? 0 : 1;\\n\\n		latch_set_input(&latch, &latch.input.u);\\n		latch_set_output(&latch, &latch.output.u);\\n\\n		latch_set_input(&latch, &latch.input.in);\\n		latch_set_output(&latch, &latch.output"
"20","1","FAIL","0","module latch (input d, c, output q, q_b );\\ninput [7:0] d;\\ninput c;\\noutput reg [7"
"20","2","FAIL","0","module latch (input d, c, packed {q_b,q} );\\n\\nThe only visible changes are that the output is now a packed union, and that the ""q"" signal is now declared packed.\\n\\n### Verilog Simulation:\\nThe simulation results look as expected:\\n\\n![sim_packunion](screenshots/verilog/packunion.png ""Simulation Results"")\\n\\n### Verilog Analysis:\\n\\nThe new packed {q_b,q} outputs are now defined with a new instance of the ""packed"" attribute:\\n\\n![packed_def](screenshots/verilog/pack_def.png ""Attribute Definition"")\\n\\nThis defines the packed representation of the q_b and q signals. The attribute is defined once and only once for each signal.\\n\\nThe packed {q_b,q} outputs are now connected to the ""pack"" module:\\n\\n![pack_inst](screenshots/verilog/pack_inst.png ""Packed Signal"")\\n\\nThe pack module just unpacks the q_b and q signals to form the packed representation.\\n\\nThe q and q_b signals now have a netlist definition:\\n\\n![q_def](screenshots/verilog/q_def.png ""q and q_b Signal"")\\n\\nThe ""assign"" statement is no longer needed since the packed {q_b,q} outputs are now defined in the same module as the unpacking module.\\n\\nThe unpacking module ""assign"" statement has now been removed:\\n\\n![q_inst](screenshots/verilog/q_inst.png ""Assign Statements"")\\n\\nAnd the pack module has been removed:\\n\\n![pack_rem](screenshots/verilog/pack_rem.png ""pack Module"")\\n\\n\\n### Final Verilog File:\\n\\nThe final verilog file is only a single module, and is as follows:\\n\\n```\\n\\nmodule latch (input d, c, packed {q_b,q} );\\n\\nassign {q_b,q} = {d,d};\\n\\nassign q = d & c;\\n\\nendmodule\\n```\\n\\n### Full Listing:\\n\\n![full_listing](screenshots/verilog/full_listing.png ""Full Listing"")\\n\\n\\n### References:\\n\\n[https://www.edaboard.com/threads/verilog-attribute.139808/](https://www.edaboard.com/threads/verilog-attribute.139808/)\\n\\n[https://en.wikipedia.org/wiki/Packed_data](https://en.wikipedia.org/wiki/Packed_data)\\n\\n[https://www.edaboard.com/threads/verilog-packed-structures.291169/](https://www.edaboard.com/threads/verilog-packed-structures.291169/)\\n/src/common/data_model/verilog/types/verilog_data_type_packed.cpp\\n/**\\n*\\n* @file\\n*\\n* @brief Verilog data type packed description implementation\\n*\\n* @author \\n* @date 2016-04-26\\n*\\n*/\\n\\n//local\\n#include ""verilog_data_type_packed.h""\\n\\nnamespace ZXT\\n}\\nerm\\n{\\n\\nstd::shared_ptr<DataType::Verilog> DataType::Verilog::Packed::clone() const\\n{\\n  return std::make_shared<DataType::Verilog::Packed>(*this);\\n}\\n/src/common/format/format.cpp\\n/**\\n *\\n * @file\\n *\\n * @brief Common formatting implementation\\n *\\n * @author DirtyUnicorns OSS team\\n * @date 2018-01-12\\n *\\n */\\n#include <string>\\n\\n#include ""format.h""\\n\\nbool Format::isFormatString(const std::string & str)\\n{\\n  return str[0] == '%';\\n}\\n\\nbool Format::isUnformatString(const std::string & str)\\n{\\n  return str[0] == '!';\\n}\\n/src/core/cpu/z80/internal/z80_register.cpp\\n/**\\n *\\n * @file\\n *\\n * @brief Implementation of CPU Registers\\n *\\n * @author \\n * @author \\n * @date 2009\\n *\\n */\\n\\n//local\\n#include <devices/common/registers/register_value_converter.h>\\n#include ""internal/z80_register.h""\\n\\nnamespace ZX\\n{\\n  namespace Z80\\n  {\\n\\n    Register::Register()\\n      : Value(Registers::N),\\n        m_conditionCode(Registers::None),\\n        m_value(0),\\n        m_regMap(NULL),\\n        m_name()\\n    {\\n    }\\n\\n    Register::Register(Registers::Code reg, const std::string & name, Value regValue, Register::ConditionCode conditionCode)\\n      : Value(regValue),\\n        m_conditionCode(conditionCode),\\n        m_value(0),\\n        m_regMap(NULL),\\n        m_name(name)\\n    {\\n      if (reg!= N)\\n      {\\n        m_regMap=new RegMap_t::value_type(reg, this);\\n      }\\n    }\\n\\n    Register &Register::operator=(const Value & value)\\n    {\\n      Value::operator=(value);\\n      if (m_regMap)\\n      {\\n        m_regMap->second->setValue(value);\\n        *m_regMap->second = *this;\\n      }\\n      return *this;\\n    }\\n\\n    bool Register::isModified() const\\n    {\\n      return Value::isModified();\\n    }\\n\\n    Registers::Code Register::getCode() const\\n    {\\n      return getValue().getRegCode();\\n    }\\n\\n    std::string Register::getName() const\\n    {\\n      return m_name;\\n    }\\n\\n    Register::ConditionCode Register::getConditionCode() const\\n    {\\n      return m_conditionCode;\\n    }\\n\\n    std::string Register::getConditionName() const\\n    {\\n      return ConditionCode::getName(m_conditionCode);\\n    }\\n\\n    bool Register::isFlag(Flags::Code code) const\\n    {\\n      return getValue().isFlag(code);\\n    }\\n\\n    bool Register::isFlagSet(Flags::Code code) const\\n    {\\n      return getValue().isFlagSet(code);\\n    }\\n\\n    bool Register::isFlagClear(Flags::Code code) const\\n    {\\n      return getValue().isFlagClear(code);\\n    }\\n\\n\\n    void Register::toggleFlag(Flags::Code code)\\n    {\\n      getValue().toggleFlag(code);\\n      setValue(getValue());\\n    }\\n\\n    void Register::setFlag(Flags::Code code, bool set)\\n    {\\n      getValue().setFlag(code, set);\\n      setValue(getValue());\\n    }\\n\\n    Value Register::getValue() const\\n    {\\n      return Value::getValue();\\n    }\\n\\n    void Register::setValue(const Value &value)\\n    {\\n      Value::setValue(value);\\n    }\\n\\n  }\\n}\\n/src/common/crc/crc_types_definitions.h\\n/**\\n *\\n * @file\\n *\\n * @brief CRC definitions\\n *\\n * @author \\n * @date 2015-06-01\\n *\\n */\\n\\n#pragma once\\n\\n#include <cstdint>\\n\\nnamespace ZXTpedef uint8_t crc8_t;\\n  typedef uint16_t crc16_t;\\n  typedef uint16_t crc32_t;\\n}\\nerm\\n{\\n  ty/src/core/tools/file_image/file_image.h\\n/**\\n *\\n * @file\\n *\\n * @brief File image interface\\n *\\n * @author \\n * @author \\n * @date 2018-05-31\\n *\\n */\\n\\n#pragma once\\n\\n//STD\\n#include <memory>\\n//COMMON\\n#include <types/data_types.h>\\n#include <bytesorder/bytesorder.h>\\n\\nnamespace ZXT\\n{\\n  namespace FileImage\\n  {\\n    //! File image\\n    class FileImage\\n    {\\n    public:\\n      enum class OpenMode\\n      {\\n        //! For reading only\\n        ReadOnly,\\n        //! For writing only\\n        WriteOnly,\\n        //! Read and write\\n        ReadWrite\\n      };\\n      /**\\n       * @brief Create image\\n       * @param size Image size\\n       */\\n      explicit FileImage(uint64_t size);\\n      //! Image size\\n      uint64_t size() const;\\n      //! Read image bytes\\n      virtual Bytes read(uint64_t offset, uint64_t size) const = 0;\\n      //! Write image bytes\\n      virtual void write(uint64_t offset, const Bytes & data) = 0;\\n\\n    protected:\\n      uint64_t m_size;\\n    };\\n\\n    std::shared_ptr<FileImage> createFileImage(FileImage::OpenMode mode, uint64_t size);\\n  }\\n}\\n/src/core/core_tests/file_system_mock.h\\n/**\\n *\\n * @file\\n *\\n * @brief File system mock implementation\\n *\\n * @author \\n * @date 2009-07-06\\n *\\n */\\n\\n#ifndef FILE_SYSTEM_MOCK_"
"20","3","FAIL","0","module full_adder_4 (input A, B, C_in, output sum [1:1], output C_out);\\nreg [1:0] S, C;\\nalways @(A, B, C_in) begin\\nS=A ^ B;\\nC=A & B;\\nend\\nassign C_out = C | C_in;\\nendmodule\\n\\n### Test Bench:\\nmodule full_adder_4_tb ( );\\n\\nreg A, B, C_in;\\nwire sum [1:1], C_out;\\nfull_adder_4 uut (.A(A),.B(B),.C_in(C_in),.sum(sum),.C_out(C_out) );\\n\\ninitial begin\\nA = 0; B = 0; C_in = 0; $display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; A = 0; B = 1; C_in = 0;$display(""Input A: %h"", A);\\n$display(""Input B: %h"", B);$display(""Input C_in: %h"", C_in);\\n#5;\\nA = 0; B = 1; C_in = 1;\\n$display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; A = 1; B = 0; C_in = 0;$display(""Input A: %h"", A);\\n$display(""Input B: %h"", B);$display(""Input C_in: %h"", C_in);\\n#5;\\nA = 1; B = 0; C_in = 1;\\n$display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; A = 1; B = 1; C_in = 0;$display(""Input A: %h"", A);\\n$display(""Input B: %h"", B);$display(""Input C_in: %h"", C_in);\\n#5;\\nA = 1; B = 1; C_in = 1;\\n$display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; A = 0; B = 0; C_in = 1;$display(""Input A: %h"", A);\\n$display(""Input B: %h"", B);$display(""Input C_in: %h"", C_in);\\n#5;\\nA = 0; B = 1; C_in = 1;\\n$display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; A = 1; B = 0; C_in = 1;$display(""Input A: %h"", A);\\n$display(""Input B: %h"", B);$display(""Input C_in: %h"", C_in);\\n#5;\\nA = 1; B = 1; C_in = 1;\\n$display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; A = 0; B = 0; C_in = 0;$display(""Input A: %h"", A);\\n$display(""Input B: %h"", B);$display(""Input C_in: %h"", C_in);\\n#5;\\nA = 0; B = 1; C_in = 0;\\n$display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; A = 1; B = 0; C_in = 0;$display(""Input A: %h"", A);\\n$display(""Input B: %h"", B);$display(""Input C_in: %h"", C_in);\\n#5;\\nA = 1; B = 1; C_in = 0;\\n$display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; A = 0; B = 0; C_in = 1;$display(""Input A: %h"", A);\\n$display(""Input B: %h"", B);$display(""Input C_in: %h"", C_in);\\n#5;\\nA = 0; B = 1; C_in = 1;\\n$display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; A = 1; B = 0; C_in = 1;$display(""Input A: %h"", A);\\n$display(""Input B: %h"", B);$display(""Input C_in: %h"", C_in);\\n#5;\\nA = 1; B = 1; C_in = 1;\\n$display(""Input A: %h"", A);$display(""Input B: %h"", B);\\n$display(""Input C_in: %h"", C_in); #5; initial #500; endmodule ### Output: Input A: 0 Input B: 0 Input C_in: 0 Input A: 0 Input B: 1 Input C_in: 0 Input A: 1 Input B: 0 Input C_in: 0 Input A: 1 Input B: 1 Input C_in: 0 Input A: 0 Input B: 0 Input C_in: 1 Input A: 0 Input B: 1 Input C_in: 1 Input A: 1 Input B: 0 Input C_in: 1 Input A: 1 Input B: 1 Input C_in: 1 Input A: 0 Input B: 0 Input C_in: 0 Input A"
"20","4","FAIL","0","module latch (input d, c, output q, q_b );\\npacked union u_q {\\nreg [7:0] i;\\nreg [7:0] j;\\n} q_packed;\\nq_packed q;\\nq_packed q_packed_b;\\nalways begin\\nwait ( c );\\nq.i = d;\\nq_packed_b.i = d;\\nend\\nendmodule\\n### Testbench:\\n// Testing Latch //\\nmodule tb;\\ninput clk;\\ninput q_b, q;\\nreg d, c;\\n\\nreg [7:0] q_b_out;\\nreg [7:0] q_out;\\n\\nlatch i_latch (.d(d),.c(c),.q(q),.q_b(q_b));\\n\\nalways begin\\nq_b_out = q_b;\\nq_out = q;\\nend\\nendmodule\\n### Simulation Results:\\nTo test for a correct output, we must compare the output of our modified\\ndesign (q) and that of the base design (q_b). We also must be able to test\\nboth output types, i, and j. We do this by comparing the output register (q)\\nto the second output variable (q_b).\\nThe first output that is compared to the base output (q) is a regular output\\nregister.\\n![](./images/11_1/image23.png)\\nWe see that the two outputs (q and q_b) are identical, with the exception of\\nthe data type. Notice that when data is written to the output register,\\nq_b also changes. This is because q is a regular output register and q_b\\nis an output variable.\\n![](./images/11_1/image24.png)\\nThe second output that is compared to the base output (q) is a packed union.\\n![](./images/11_1/image25.png)\\nWe see that the two outputs (q and q_b) are different, with the exception\\nof the type. Notice that when data is written to the output register,\\nq_b also changes. This is because q is a regular output register and q_b\\nis an output variable.\\ns:\\nThe output of the first module is not the output of the second module.\\n![](./images/16_0/image48.png)\\n#### Testbench:\\nThe testbench for this example has two inputs.\\n\\nThe testbench first writes a value to the first input register (a), and\\nthen reads the output from the second input register (b).\\n\\n![](./images/16_0/image49.png)\\n\\n### Testbench Code:\\nmodule tb;\\n\\nreg [15:0] a;\\nreg [15:0] b;\\nreg clk;\\nreg rstn;\\nreg done;\\n\\nadd3 i_add3 (.a(a),.b(b),.c(b),.done(done),.sum(b));\\n\\nalways #5 clk = ~clk;\\n\\nalways #5 rstn = ~rstn;\\n\\nendmodule\\n\\n### Simulation Results:\\n![](./images/16_0/image50.png)\\n#### Explanation:\\nThe output of the first module is not the output of the second module. The\\noutput of the first module is different from the output of the second.\\n# Chapter 16: Combinational Logic\\n\\n### Module:\\nmodule add3 ( input [15:0] a, input [15:0] b, input [15:0] c,\\noutput [15:0] sum, output done );\\nalways begin\\nsum = a + b + c;\\nend\\nendmodule\\n### Combinational Module:\\n### Base Verilog Code:\\nmodule add3 ( input [15:0] a, input [15:0] b, input [15:0] c,\\noutput [15:0] sum, output done );\\n\\nalways @ ( a, b, c ) begin\\nsum = a + b + c;\\nend\\nendmodule\\n### Combinational Testbench:\\n// Test for Combinational Logic //\\nmodule tb;\\n\\nreg [15:0] a;\\nreg [15:0] b;\\nreg [15:0] c;\\nreg done;\\n\\n// instantiate the add3 module\\nadd3 i_add3 ( a, b, c, b, done );\\n\\n// write a value to input register a\\nassign a = 0x1234;\\n\\n// wait until the done signal is\\n// high, then read the signal value from register b\\nalways @ ( negedge done ) begin\\n$display ( ""Output Sum = 0x%x"", b );\\nend\\n\\nendmodule\\n### Simulation Results:\\n![](./images/16_0/image12.png)\\n#### Explanation:\\nThe output of the first module is not the output of the second module. The\\noutput of the first module is different from the output of the second.\\n### Module:\\nmodule add3 ( input [15:0] a, input [15:0] b, input [15:0] c,\\noutput [15:0] sum, output done );\\n\\nalways begin\\nsum = a + b;\\nend\\n\\nassign c = a + b;\\n\\nalways @ ( a, b ) begin\\ndone = a + b + c;\\nend\\n\\nendmodule\\n### Combinational Module:\\n### Base Verilog Code:\\nmodule add3 ( input [15:0] a, input [15:0] b, input [15:0] c,\\noutput [15:0] sum, output done );\\n\\nassign c = a + b;\\n\\nalways @ ( a, b ) begin\\ndone = a + b + c;\\nend\\n\\nendmodule\\n### Combinational Testbench:\\n// Test for Combinational Logic //\\nmodule tb;\\n\\nreg [15:0] a;\\nreg [15:0] b;\\nreg [15:0] c;\\nreg done;\\n\\n// instantiate the add3 module\\nadd3 i_add3 ( a, b, c, b, done );\\n\\n// write a value to input register a\\nassign a = 0x1234;\\n\\n// wait until the done signal is\\n// high, then read the signal value from register b\\nalways @ ( negedge done ) begin\\n$display ( ""Output Sum = 0x%x"", b );\\nend\\n\\nendmodule\\n### Simulation Results:\\n![](./images/16_0/image13.png)\\n#### Explanation:\\nThe output of the first module is the same as the output of the second.\\n### Module:\\nmodule add3 ( input [15:0] a, input [15:0] b, input [15:0] c,\\noutput [15:0] sum, output done );\\n\\nalways begin\\nsum = a + b;\\nend\\n\\nassign c = a + b;\\n\\nalways @ ( a, b, c ) begin\\ndone = a + b + c;\\nend\\n\\nendmodule\\n### Combinational Module:\\n### Base Verilog Code:\\nmodule add3 ( input [15:0] a, input [15:0] b, input [15:0] c,\\noutput [15:0] sum, output done );\\n\\nassign c = a + b;\\n\\nalways @ ( a, b, c ) begin\\ndone = a + b + c;\\nend\\n\\nendmodule\\n### Combinational Testbench:\\n// Test for Combinational Logic //\\nmodule tb;\\n\\nreg [15:0] a;\\nreg [15:0] b;\\nreg [15:0] c;\\nreg done;\\n\\n// instantiate the add3 module\\nadd3 i_add3 ( a, b, c, b, done );\\n\\n// write a value to input register a\\nassign a = 0x1234;\\n\\n// wait until the done signal is\\n// high, then read the signal value from register b\\nalways @ ( negedge done ) begin\\n$display ( ""Output Sum = 0x%x"", b );\\nend\\n\\nendmodule\\n### Simulation Results:\\n![](./images/16_0/image14.png)\\n### Module:\\nmodule add3 ( input [15:0] a, input [15:0] b, input [15:0] c,\\noutput [15:0] sum, output done );\\n\\nassign c = a + b + 1;\\n\\nalways @ ( a, b, c ) begin\\ndone = a + b + c;\\nend\\n\\nendmodule\\n### Combinational Module:\\n### Base Verilog Code:\\nmodule add3 ( input [15:0] a, input [15:0] b, input [15:0] c,\\noutput [15:0] sum, output done );\\n\\nassign c = a + b +"
"21","0","FAIL","0","module example9(x1, x2, x3, x4, f, g, h);\\ninput x1, x2, x3, x4;\\noutput f, g, h;\\n\\nstructure s1 random;\\nrand bit c;\\nendstructure\\n\\nstructure s2 random;\\nrand bit c2;\\nendstructure\\n\\nassign g2 = (x1 & x3) | (x2 & x4);\\nassign h2 = (x1 | x3) & (x2 | x4);\\nassign g = s1.c? g2 : g;\\nassign h = s2.c2? h2 : h;\\nassign f = g | h;\\nendmodule\\n### Execution:\\n\\n### S1\\nSimulation time: 1000 ns\\nNumber of"
"21","1","FAIL","0","module example5(x21, x22, x3, x4, f, g, h);\\ninput x1, x2, x3, x4;\\noutput f, g, h;\\nwire [1:0] tempVar;\\nassign g = (x1 & x3) | (x2 & x4);\\nassign h = (x1 | x3) & (x2 | x4);\\nassign f = g | h;\\nendmodule\\n### Expected Results:\\n1. No errors or warnings\\n2. No structural aliasing errors\\n3. 1 assignment statement with 1 blocking assignment statement\\n### Test Procedure:\\n1. Verify this test passes all checks\\n2. Compare expected results and actual results\\n3. For any differences, add a comment on why the test is failing\\n4. If the test is failing, change the instructions to fix the bug\\n5. Repeat steps 1 - 4 until all tests are passing\\n\\n## Test 11 - Randomize variable name + input/output names, different from the two input/output names\\n### Base Verilog Code:\\nmodule example5(x1, x2,"
"21","2","FAIL","0","module example4(x1, x2, x3, x4, f, g, h);\\ninput x1, x2, x3, x4;\\noutput f, g, h;\\ntypedef struct rand {\\nlogic f, g, h;\\n} rand_t;\\nrand_t r;\\nassign g = (x1 & x3) | (x2 & x4);\\nassign h = (x1 | x3) & (x2 | x4);\\nassign f = g | h;\\n\\ninitial begin\\nr.f = x1;\\nr.g = x2;\\nr.h = x3;\\nend\\n\\ninitial begin\\nwait;\\nend\\n\\nendmodule\\n\\n### Verifier:\\nmodule example4(x1, x2, x3, x4, f, g, h);\\ninput x1, x2, x3, x4;\\noutput f, g, h;\\nassign g = (x1 & x3) | (x2 & x4);\\nassign h = (x1 | x3) & (x2 | x4);\\nassign f = g | h;\\nendmodule\\n\\nmodule testbench;\\nbit x1;\\nbit x2;\\nbit x3;\\nbit x4;\\nbit f;\\nbit g;\\nbit h;\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 0;\\nx4 = 0;\\nf = 0;\\ng = 0;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 1;\\nx3 = 1;\\nx4 = 1;\\nf = 1;\\ng = 1;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 1;\\nx3 = 0;\\nx4 = 1;\\nf = 0;\\ng = 0;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 1;\\nx3 = 1;\\nx4 = 0;\\nf = 1;\\ng = 1;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 0;\\nx3 = 1;\\nx4 = 0;\\nf = 1;\\ng = 1;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 0;\\nx3 = 0;\\nx4 = 1;\\nf = 1;\\ng = 1;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 0;\\nx3 = 0;\\nx4 = 0;\\nf = 0;\\ng = 0;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 1;\\nx3 = 1;\\nx4 = 0;\\nf = 0;\\ng = 0;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 1;\\nx3 = 0;\\nx4 = 1;\\nf = 0;\\ng = 1;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 1;\\nx4 = 1;\\nf = 0;\\ng = 1;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 1;\\nx4 = 0;\\nf = 0;\\ng = 1;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 0;\\nx4 = 1;\\nf = 0;\\ng = 0;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 0;\\nx4 = 0;\\nf = 1;\\ng = 0;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 1;\\nx3 = 1;\\nx4 = 1;\\nf = 0;\\ng = 0;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 1;\\nx3 = 1;\\nx4 = 0;\\nf = 1;\\ng = 0;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 1;\\nx3 = 0;\\nx4 = 0;\\nf = 1;\\ng = 0;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 1;\\nx4 = 0;\\nf = 1;\\ng = 0;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 1;\\nx4 = 1;\\nf = 1;\\ng = 1;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 0;\\nx4 = 0;\\nf = 1;\\ng = 1;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 1;\\nx3 = 1;\\nx4 = 1;\\nf = 1;\\ng = 1;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 1;\\nx3 = 1;\\nx4 = 1;\\nf = 1;\\ng = 1;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 0;\\nx4 = 0;\\nf = 1;\\ng = 1;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 0;\\nx3 = 1;\\nx4 = 0;\\nf = 1;\\ng = 0;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 0;\\nx3 = 0;\\nx4 = 1;\\nf = 1;\\ng = 0;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 0;\\nx3 = 0;\\nx4 = 0;\\nf = 0;\\ng = 0;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 0;\\nx4 = 1;\\nf = 0;\\ng = 1;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 1;\\nx4 = 0;\\nf = 0;\\ng = 1;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 1;\\nx3 = 0;\\nx4 = 1;\\nf = 0;\\ng = 1;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 1;\\nx3 = 0;\\nx4 = 1;\\nf = 0;\\ng = 0;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 0;\\nx2 = 0;\\nx3 = 0;\\nx4 = 0;\\nf = 1;\\ng = 1;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 0;\\nx3 = 1;\\nx4 = 1;\\nf = 1;\\ng = 0;\\nh = 1;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 0;\\nx3 = 1;\\nx4 = 0;\\nf = 1;\\ng = 0;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 0;\\nx3 = 0;\\nx4 = 0;\\nf = 1;\\ng = 1;\\nh = 0;\\nend\\n\\ninitial begin\\nx1 = 1;\\nx2 = 1;\\nx3 = 0;\\nx4 = 0;\\nf ="
"21","3","FAIL","0","module example9(x1, x2, x3, x4, f, g, h);\\ninput x1, x2, x3, x4;\\noutput f, g, h;\\nreg [1:0] c;\\nstructure{\\nrandom c;\\n} s;\\nassign g = (x1 & x3) | (x2 & x4);\\nassign h = (x1 | x3) & (x2 | x4);\\nassign f = g | h;\\nendmodule\\n### Test Suite:\\n#### Test 1:\\nx1, x3 = 1, x2, x4 = 0\\n#### Test 2:\\nx1, x3 = 0, x2, x4 = 1\\n#### Test 3:\\nx1, x3 = 1, x2, x4 = 1\\n#### Test 4:\\nx1, x3 = 0, x2, x4 = 0\\n### 11. Example 10\\n### Base Verilog Code:\\nmodule example10(x1, x2, x3, x4, f, g"
"21","4","FAIL","0","module example6(x1, x2, x3, x4, x5, x6, f, g, h);\\ninput x1, x2, x3, x4, x5, x6;\\noutput f, g, h;\\nwire [1:0] r_x1;\\nwire [1:0] r_x2;\\nwire [1:0] r_x3;\\nwire [1:0] r_x4;\\nwire [1:0] r_x5;\\nwire [1:0] r_x6;\\nwire [1:0] r_f;\\nwire [1:0] r_g;\\nwire [1:0] r_h;\\nstruct {\\nrand r_x1;\\nrand r_x2;\\nrand r_x3;\\nrand r_x4;\\nrand r_x5;\\nrand r_x6;\\nrand r_f;\\nrand r_g;\\nrand r_h;\\n} random_s;\\nassign g = {r_x1, r_x2, r_x3, r_x4, r_x5, r_x6};\\nbegin\\nrandom_s = random_s'(rand(), rand(), rand(), rand(), rand(), rand(), rand(), rand(), rand());\\nend\\nassign r_x1 = rand();\\nassign r_x2 = rand();\\nassign r_x3 = rand();\\nassign r_x4 = rand();\\nassign r_x5 = rand();\\nassign r_x6 = rand();\\nassign r_f = rand();\\nassign r_g = rand();\\nassign r_h = rand();\\nendmodule\\n### Verification:\\nThe following Verilog code is required to verify correctness of the modified code.\\nmodule example6_verif(x1, x2, x3, x4, x5, x6, f_expect, g_expect, h_expect);\\ninput x1, x2,"
"22","0","FAIL","0","module adder(a, b, cout, sum);\\ninput [3:0] a;\\ninput [3:0] b;\\ninput cout;\\noutput [3:0] sum;\\nwire [1:0] packed_a;\\nwire [1:0] packed_b;\\nassign packed_a[0] = a[0];\\nassign packed_a[1] = a[1];\\nassign packed_b[0] = b[0];\\nassign packed_b[1] = b[1];\\nassign sum = packed_a[0]+packed_b[0]+cout+packed_a[1]+packed_b[1];\\nendmodule\\n\\n### Base Verilog Code:\\nmodule decoder(in, out0, out1, out2, out3);\\ninput [3:0] in"
"22","1","FAIL","0","module mux_41(input [2:0] in, output [3:0] y1, y2, y3, y4);\\ninput [2:0] in;\\noutput [3:0] y1, y2, y3, y4;\\n\\nassign y1 = {y1[0], in[0]};\\nassign y2 = {y1[1], in[1]};\\nassign y3 = {y2[1], in[2]};\\nassign y4 = {y3[1], in[3]};\\n\\nendmodule\\n\\nmodule mux_22(input [2:0] in, output [3:0] y1, y2, y3, y4);\\ninput [2:0] in;\\noutput [3:0] y1, y2, y3, y4;\\n\\nassign y1 = {y1[0], in[0], in[1]};\\nassign y2 = {y1[1], in[1], in[2]};\\nassign y3 = {y2[1], in[2], in[3]};\\nassign y4 = {y3[1], in[3], in[0]};\\n\\nendmodule\\n\\n### Modified Verilog Code:\\n\\nmodule mux_41(input [2:0] in, output [3:0] y1, y2, y3, y4);\\ninput [2:0] in;\\noutput [3:0] y1, y2, y3, y4;\\n\\nassign y1 = {y1[0], in[0]};\\nassign y2 = {y1[1], in[1]};\\nassign y3 = {y2[1], in[2]};\\nassign y4 = {y3[1], in[3]};\\n\\nendmodule\\n\\nmodule mux_22(input [2:0] in, output [3:0] y1, y2, y3, y4);\\ninput [2:0] in;\\noutput [3:0] y1, y2, y3, y4;\\n\\nassign y1 = {y1[0], in[0], in[1]};\\nassign y2 = {y1[1], in[1], in[2]};\\nassign y3 = {y2[1], in[2], in[3]};\\nassign y4 = {y3[1], in[3], in[0]};\\n\\nendmodule\\n\\n## Exercise 4:\\n\\nImplement a 2-input N-ary Adder using the following components, and implement a testbench to verify the output value of the adder (using the truth table) when all inputs are either 0 or 1 at the same time:\\n\\n Two-input N-ary Adder\\n\\nThe inputs to the adder are: s0, s1, c0, and c1.\\n\\nThe output should be: sum, and carry.\\n\\n### Base Verilog Code:\\n\\nmodule adder3(input [1:0"
"22","2","FAIL","0","module par(in, parity, all_ones);\\ninput [7:0] in[4:0];\\noutput parity, all_ones;\\nassign parity = ~in;\\nassign all_ones = in;\\nendmodule\\n### Verification:\\nRun the code in testbench.v. The outputs should match the provided code.\\n#include <stdio.h>\\n\\nvoid main()\\n{\\n	unsigned m = 1;\\n	unsigned n = 1;\\n	unsigned k = 0;\\n	for(;;){\\n		if(m%6==0)\\n			k++;\\n		if(k==n)\\n			break;\\n		m++;\\n	}\\n	printf(""m = %u\\n"", m);\\n}\\n#include <stdio.h>\\n\\nvoid main(){\\n	enum { A, B, C, D, E, F, G } colors;\\n	for (colors = A; colors <= G; colors++)\\n		printf(""color = %d\\n"", colors);\\n}\\n#include <stdio.h>\\n \\nvoid main(){\\n	int n = 10;\\n	int count = 1;\\n	int i;\\n	printf(""n = %d\\n"", n);\\n	for(i = 1; i < n; i++){\\n		int j;\\n		for(j = 1; j < n; j++){\\n			printf(""%d"", count);\\n			if(count == 8){\\n				printf(""\\n"");\\n				count = 1;\\n			}\\n			else\\n				printf("" "");\\n			count++;\\n		}\\n	}\\n}\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <ctype.h>\\n#include <math.h>\\n#include ""header.h""\\n\\n\\nint main(){\\n    char input[MAX_INPUT];\\n    char operation[MAX_INPUT];\\n    int i,j;\\n    printf(""Type 'quit' to exit\\n"");\\n    do{\\n        printf("">"");\\n        gets(input);\\n        if(strcmp(input, ""quit"")!= 0){\\n            printf(""1st number: "");\\n            gets(input);\\n            for(i = 0; input[i]!= '\\0'; i++){ //converting to int\\n                if(input[i] == '-')\\n                    input[i] = ',';\\n            }\\n            for(i = 0; input[i]!= ','; i++){ //converting to int\\n                if(!isdigit(input[i])){\\n                    printf(""Invalid input. Enter int only.\\n"");\\n                    break;\\n                }\\n            }\\n            if(i == 0){\\n                printf(""Invalid input. Enter int only.\\n"");\\n            }\\n            else{\\n                int num1 = atoi(input);\\n                printf(""2nd number: "");\\n                gets(input);\\n                for(i = 0; input[i]!= '\\0'; i++){ //converting to int\\n                    if(input[i] == '-')\\n                        input[i] = ',';\\n                }\\n                for(i = 0; input[i]!= ','; i++){ //converting to int\\n                    if(!isdigit(input[i])){\\n                        printf(""Invalid input. Enter int only.\\n"");\\n                        break;\\n                    }\\n                }\\n                if(i == 0){\\n                    printf(""Invalid input. Enter int only.\\n"");\\n                }\\n                else{\\n                    int num2 = atoi(input);\\n                    printf(""Operator: "");\\n                    gets(operation);\\n                    if(strcmp(operation, ""add"") == 0){\\n                        printf(""%d + %d = %d\\n"", num1, num2, add(num1, num2));\\n                    }\\n                    else if(strcmp(operation, ""sub"") == 0){\\n                        printf(""%d - %d = %d\\n"", num1, num2, sub(num1, num2));\\n                    }\\n                    else if(strcmp(operation, ""mul"") == 0){\\n                        printf(""%d * %d = %d\\n"", num1, num2, mul(num1, num2));\\n                    }\\n                    else if(strcmp(operation, ""div"") == 0){\\n                        printf(""%d / %d = %.2f\\n"", num1, num2, div(num1, num2));\\n                    }\\n                    else{\\n                        printf(""Invalid operator\\n"");\\n                    }\\n                }\\n            }\\n        }\\n    }while(strcmp(input, ""quit"")!= 0);\\n}\\n#include <stdio.h>\\n#define MAX 10\\n\\nvoid main(){\\n	int arr[MAX];\\n	int i,j,m,n,t;\\n	printf(""Enter %d numbers: "", MAX);\\n	for(i = 0; i < MAX; i++)\\n		scanf(""%d"", &arr[i]);\\n	for(i = 0; i < MAX; i++){\\n		for(j = i+1; j < MAX; j++){\\n			if(arr[i] > arr[j]){\\n				t = arr[i];\\n				arr[i] = arr[j];\\n				arr[j] = t;\\n			}\\n		}\\n	}\\n	for(i = 0; i < MAX; i++){\\n		m = arr[i];\\n		for(j = i+1; j < MAX; j++){\\n			if(arr[j] == m){\\n				arr[j] = 0;\\n			}\\n		}\\n	}\\n	printf(""Input Data:\\n"");\\n	for(i = 0; i < MAX; i++)\\n		printf(""%d "", arr[i]);\\n}\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <ctype.h>\\n#include <math.h>\\n\\nvoid main(){\\n    char input[100] = """";\\n    int size = 100;\\n    printf(""Type 'quit' to exit\\n"");\\n    while(1){\\n        printf("">"");\\n        gets(input);\\n        if(strcmp(input, ""quit"") == 0){\\n            break;\\n        }\\n        if(input[0]!= 'q' && input[0]!= 'Q'){\\n            if(strlen(input) > size){\\n                printf(""Overflow\\n"");\\n            }\\n            else{\\n                printf(""%s\\n"", input);\\n            }\\n        }\\n        else{\\n            printf(""Underflow\\n"");\\n        }\\n    }\\n}\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint add(int a, int b)\\n{\\n	int d;\\n	d = a + b;\\n	return d;\\n}\\n\\nint sub(int a, int b)\\n{\\n	int d;\\n	d = a - b;\\n	return d;\\n}\\n\\nint mul(int a, int b)\\n{\\n	int d;\\n	d = a * b;\\n	return d;\\n}\\n\\nint div(int a, int b)\\n{\\n	int d;\\n	d = a / b;\\n	return d;\\n}\\n#include <stdio.h>\\n\\nvoid main(){\\n	int arr[10];\\n	int i,m,n;\\n	printf(""Enter 10 numbers: "");\\n	for(i = 0; i < 10; i++)\\n		scanf(""%d"", &arr[i]);\\n	printf(""Minimum: %d\\n"", arr[0]);\\n	printf(""Maximum: %d\\n"", arr[0]);\\n	for(i = 1; i < 10; i++){\\n		if(arr[i] <= arr[i-1]){\\n			arr[i] = arr[i-1];\\n			if(arr[0] > arr[i])\\n				m = arr[i];\\n		}\\n	}\\n	for(i = 1; i < 10; i++){\\n		if(arr[i] >= arr[i-1]){\\n			arr[i] = arr[i-1];\\n			if(arr[0] < arr[i])\\n				n = arr[i];\\n		}\\n	}\\n	printf(""Maximum: %d\\n"", m);\\n	printf(""Minimum: %d\\n"", n);\\n}\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <ctype.h>\\n#include <math.h>\\n#include ""header.h""\\n\\nint main(){\\n    char *words[MAX_WORDS];\\n    char input[MAX_INPUT] = """";\\n    int i,j,count[MAX_WORDS],k;\\n    for(i = 0; i < MAX_WORDS; i++){\\n        words[i] = malloc(MAX_WORD_LENGTH * sizeof(char));\\n        count[i] = 0;\\n    }\\n    i = 0;\\n    while(1){\\n        printf(""> "");\\n        gets(input);\\n        if(strcmp(input, ""quit"") == 0)\\n            break;\\n        for(j = 0; input[j]!= '\\0'; j++){\\n            if"
"22","3","FAIL","0","module shift_right(in, out, n);\\ninput [7:0] in;\\noutput [7:0] out;\\nwire [7:0] in_n, out_n;\\nassign out_n = in << 1;\\nassign in_n = in >> 1;\\nassign out = in_n;\\nendmodule\\n```\\n\\n#### 2.3.3.4.3 LSB-first - Packed\\n\\n```verilog\\n### Original Base Verilog Code:\\nmodule shift_right(in, out, n);\\ninput [7:0] in;\\noutput [7:0] out;\\ninput n;"
"22","4","FAIL","0","module par(in, parity, all_ones);\\ninput [7:0] in;\\noutput parity, all_ones;\\nlogic[7:0] packed;\\nassign parity = ^in;\\nassign all_ones = &in;\\nassign packed = in;\\nendmodule\\n\\n## P.3.4 Summary\\n\\nThe goal of this activity was to design a 4-bit parallel-to-serial converter. This was accomplished by designing a 3-to-8 decoder and implementing a 4-to-1 mux. The parallel-to-serial converter was then tested by using an 8-to-1 multiplexer to convert between binary and decimal numbers, demonstrating the capabilities of the Verilog HDL.\\n\\n## P.3.5 Lab Report\\n\\n### P.3.5.1 Design\\n\\n#### P.3.5.1.1 Parity Calculator\\n\\nThe design flow for the parity calculator was completed as follows:\\nThe input code was initially created wherein a module was defined to have 7 input bits and 2 output bits. The output bits were assigned the inputs using Verilog assignment operations. The code was then verified using the Verilog testbench. The code was then tested using the Verilog simulator.\\n\\n### P.3.5.2 Test\\n\\n#### P.3.5.2.1 Parity Calculator\\n\\nThe design was tested using the following test cases:\\n\\nTest\\nInput\\nOutput\\nHexadecimal\\n0\\n0\\n0\\n1\\n1\\n0\\n2\\n1\\n1\\n4\\n0\\n1\\n8\\n1\\n1\\n16\\n1\\n0\\n32\\n0\\n1\\n64\\n1\\n0\\n128\\n1\\n0\\n256\\n0\\n1\\n512\\n1\\n0\\n1024\\n1\\n0\\n2048\\n0\\n1\\n4096\\n1\\n0\\n8192\\n1\\n0\\n16384\\n0\\n0\\n32768\\n1\\n0\\n65536\\n1\\n0\\n131072\\n0\\n0\\n262144\\n1\\n0\\n524288\\n1\\n0\\n1048576\\n0\\n1\\n2097152\\n1\\n0\\n4194304\\n1\\n0\\n8388608\\n1\\n0\\n16777216\\n0\\n1\\n33554432\\n1\\n0\\n67108864\\n1\\n0\\n134217728\\n0\\n0\\n268435456\\n1\\n0\\n536870912\\n1\\n0\\n1073741824\\n0\\n1\\n2147483648\\n1\\n0\\n2^32\\n1\\n1\\n\\n## P.3.6 References\\n\\n[1]. _Verilog HDL_. Wiley, 2013.\\n\\n[2]. _Digital Systems Design with Verilog HDL_. New York, NY, USA: Mc Graw Hill Professional, 2014."
"23","0","FAIL","0","module FourFlopsStructL2 #(parameter DClk = 2, DBuf = 1)\\n(output[3:0] Q, input[3:0] D, input Ena, Clk);\\nwire[3:0] QWire;\\nlocalparam DTot = DBuf + DClk;\\nDFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));\\nassign #DTot Q = (Ena==1'b1)? QWire : 'bz;\\nendmodule\\n### Verilog Code Before Modification:\\n`module Test_FourFlopsStructL2 #(parameter DClk = 2, DBuf = 1) (output[3:0] Q, input[3:0] D, input Ena, Clk);`\\n### Verilog Code After Modification:\\n`module Test_FourFlopsStructL2 #(parameter DClk = 2, DBuf = 1) (output[7:0] Q, input[7:0] D, input Ena, Clk);`\\n### Simulation Before Modification:\\n![Simulation Before Modification](https://github.com/Tian-Chen-Wei/TestCode/blob/master/SimExamples/Test_FourFlopsStructL2/Before.png)\\n### Simulation After Modification:\\n![Simulation After Modification](https://github.com/Tian-Chen-Wei/TestCode/blob/master/SimExamples/Test_FourFlopsStructL2/After.png)\\n### Explaination:\\nWe can see from our Simulation that the modified code works as expected. The byte-type vector input works and the modified code is backward compatible.\\ng -m ""Updating README.md""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\n/SimExamples/push.sh\\n#!/bin/bash\\n\\n\\nfile=$1\\ngit add README.md\\ngit commit -m ""Updating README.md""\\ngit push\\ncp ""$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples/Test_$file""\\ngit add ""SimExamples/Test_$file""\\ngit commit -m ""Add test files""\\ngit push\\ncp ""SimExamples/$file"" ""SimExamples"
"23","1","FAIL","0","module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)\\n(output[7:0] Q, input[7:0] D, input[6:0] Ena, Clk);\\nwire[7:0] QWire;\\nlocalparam DTot = DBuf + DClk;\\nDFF DReg[7:0] (.Q(QWire),.D(D),.Clk(Clk));\\nassign #DTot Q = ((Ena==3'b111)||(Ena==3'b110))? QWire : ((Ena==3'b11)||(Ena==3'b10))?"
"23","2","FAIL","0","module FourFlopsStructL #(parameter DClk = 2, parameter DBuf = 2)\\n(output[7:0] Q, input[8:0] D, input Ena, Clk);\\nlocalparam DTot = DBuf + DClk;\\nDFF DReg[7:0] (.Q(D[DTot-1]),.D(D),.Clk(Clk));\\nassign #DTot Q = (Ena==1'b1)? D[DTot-1] : 'bz;\\nendmodule\\n\\n#### Result:\\n\\nAs can be"
"23","3","FAIL","0","module mult_rnd(output [31:0] Q, output [31:0] R, input [31:0] A, input [31:0] B);\\nwire [31:0] AxB = A*B;\\nwire [31:0] AxB_i3;\\nwire [31:0] AxB_i2;\\nwire [3:0] AxB_i2_i3;\\nassign AxB_i2 = AxB_i3 << 3;\\nassign AxB_i2_i3 = AxB_i2"
"23","4","FAIL","0","module FiveFlopsStructL #(parameter DClk = 2, DBuf = 1)\\n(output[3:0] Q, input[7:0] D, input Ena, Clk);\\nwire[3:0] QWire;\\nlocalparam DTot = DBuf + DClk;\\nDFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));\\nassign #DTot Q = (Ena==1'b1)? QWire : 'bz;\\nendmodule\\n\\n# Final Report\\n\\n## FiveFlopStructR.v\\n\\n### Base Verilog Code:\\nmodule FiveFlopsStructR #(parameter DClk = 2, DBuf = 1)\\n(output[3:0] Q, input[3:0] D, input Ena, Clk);\\nwire[3:0] QWire;\\nlocalparam DTot = DBuf + DClk;\\nDFF DReg[3:0] (."
"24","0","FAIL","0","module Anding (input packed_union_t, output y);\\nand (y, packed_union_t.a, packed_union_t.b);\\nendmodule\\n\\n#### SDF Code:\\n```\\nmodule sdf_anding (input signed [4:0] s_in1, input signed [4:0] s_in2, output signed [4:0] s_out);\\nand (s_out, s_in1, s_in2);\\nendmodule\\n```\\n\\n#### Modified SDF Code:\\n```\\nmodule sdf_anding (input packed_union_t, output signed [4:0] s_out);\\nand (s_out, packed_union_t.a, packed_union_t.b);\\nendmodule\\n```\\n\\n#### Base Verilog Code:\\n```\\nmodule Anding (input packed_union_t, output signed [4:0] s_out);\\nand (s_out, packed_union_t.a, packed_union_t.b);\\nendmodule\\n```\\n\\n#### Original Verilog Code:\\n```\\nmodule Anding (input signed [4:0] s_in1, input signed [4:0] s_in2, output signed [4:0] s_out);\\nand (s_out, s_in1, s_in2);\\nendmodule\\n```\\n\\n#### Original Packed Union:\\n`union packed_union_t {signed [4:0] a; signed [4:0] b};`\\n\\n#### Modified Packed Union:\\n`union packed_union_t {signed [4:0] a; signed [4:0] b; signed [4:0] c; signed [4:0] d};`\\n\\n#### SDF Testbench Code:\\n```\\n`include ""sdf_anding.sdf""\\n\\nsdf_anding uut (\\n.packed_union_t(0xAABBCCDD)\\n);\\n```\\n\\n#### Verilog Testbench Code:\\n```\\n`include ""anding.v""\\n\\nAnding uut (\\n.packed_union_t(0xAABBCCDD)\\n);\\n```\\n\\n#### Results (See below for results of original testbench)\\n##### Test 1 (Original Inputs):\\n```\\ns_in1 = 0xAABBCCDD, s_in2 = 0xAABBCCDD\\ns_out = 0x00000000\\n```\\n\\n##### Test 2 (Original Inputs, SDF Case):\\n```\\ns_in1 = 0x00000000, s_in2 = 0xAABBCCDD\\ns_out = 0x00000000\\n```\\n##### Test 3 (Original Inputs, Verilog Case):\\n```\\ns_in1 = 0x00000000, s_in2 = 0xAABBCCDD\\ns_out = 0x00000000\\n```\\n##### Test 4 (Original Inputs, SDF Case) (See original test results for DUT input a):\\n```\\ns_in1 = 0x00000000, s_in2 = 0xAABBCCDD\\ns_out = 0xAABBCCDD\\n```\\n##### Test 5 (Original Inputs, Verilog Case) (See original test results for DUT input a):\\n```\\ns_in1 = 0x00000000, s_in2 = 0xAABBCCDD\\ns_out = 0xAABBCCDD\\n```\\n\\n##### Test 5a (Original Inputs, Verilog Case) (See original test results for DUT input a):\\n```\\ns_in1 = 0xAABBCCDD, s_in2 = 0x00000000\\ns_out = 0x00000000\\n```\\n\\n##### Test 5b (Original Inputs, Verilog Case) (See original test results for DUT input a):\\n```\\ns_in1 = 0xAABBCCDD, s_in2 = 0x00000000\\ns_out = 0xAABBCCDD\\n```\\n\\n##### Test 6 (Original Inputs, Verilog Case) (See original test results for DUT input a):\\n```\\ns_in1 = 0xAABBCCDD, s_in2 = 0xAABBCCDD\\ns_out = 0xAABBCCDD\\n```\\n\\n### Verilog Testbench Results\\n10 tests were generated. 8 were all passing (both SDF and Verilog), while 2 tests were failing, one of which was due to a bug in the Verilog test bench.\\n\\nThis is the Verilog test bench that generated the 10 tests:\\n```\\n`include ""anding.v""\\n`timescale 1ns / 1ps\\n\\ninitial begin\\n$dumpfile(""dump.vcd"");\\n$dumpvars(0, uut);\\ninitial begin\\n$flist($readmemb(""sdf_anding.sdf""));\\nsdf_anding uut (\\n.packed_union_t(0xAABBCCDD)\\n);\\n$flist_end();\\n\\ninitial begin\\n$flist($readmemb(""anding.v""));\\nAnding uut (\\n.packed_union_t(0xAABBCCDD)\\n);\\n$flist_end();\\nend\\nend\\n```\\n\\n### SDF Testbench Results\\nThis is the SDF test bench that generated the 10 test cases:\\n```\\n`include ""sdf_anding.sdf""\\n\\nsdf_anding uut (\\n.packed_union_t(0xAABBCCDD)\\n);\\n```\\n\\n## Part 3 (SDF to Verilog Conversion)\\n\\nThe next part of the assignment is to convert the SDF test bench to Verilog. This step may not be necessary because I am using a Verilog testbench, but it is good practice to do any necessary conversions.\\n\\n### SDF to Verilog Conversion\\n\\n1. Change the ""clock"" and ""reset"" signals in the SDF testbench to ""clk"" and ""rst"" respectively\\n2. Rename the ""sdf_anding"" unit to ""Anding""\\n3. Convert all instances of ""packed_union_t"" to a packed structure.\\n4. Convert all instances of ""signed [4:0]"" to ""signed"".\\n5. Convert all instances of ""s_"" to ""s_in"".\\n6. Convert all instances of ""s_in1"" to ""a"".\\n7. Convert all instances of ""s_in2"" to ""b"".\\n8. Convert all instances of ""s_out"" to ""y"".\\n9. Convert all instances of ""and"" to ""ands"".\\n10. Convert all instances of ""ands"" to ""and"".\\n11. Replace all instances of the ""uut"" signal with ""uut\\_packed\\_union\\_t""\\n\\nThe following is the Verilog conversion script written with the aid of the following website:\\nhttps://www.verilogto.com/verilog-to-vhdl-converter/\\n\\n```\\n\\n/*\\n * The following is the Verilog conversion script written with the aid of the following website:\\n * https://www.verilogto.com/verilog-to-vhdl-converter/\\n*/\\n\\nmodule sdf_anding (input packed_union_t, output signed [4:0] s_out);\\nand (s_out, packed_union_t.a, packed_union_t.b);\\nendmodule\\n\\nmodule Anding (input packed_union_t, output signed [4:0] s_out);\\nand (s_out, packed_union_t.a, packed_union_t.b);\\nendmodule\\n\\n`timescale 1ns / 1ps\\n\\ninitial begin\\n$dumpfile(""dump.vcd"");\\n$dumpvars(0, uut);\\ninitial begin\\n$flist($readmemb(""anding.v""));\\nAnding uut (\\n.packed_union_t(0xAABBCCDD)\\n);\\n$flist_end();\\nend\\nend\\n\\n```\\n\\n## Part 4 (Verilog to SDF Conversion)\\n\\nThe final part of the assignment is to convert the converted Verilog testbench to SDF.\\n\\n### Verilog to SDF Conversion\\n\\n1. Change the ""clock"" and ""reset"" signals in the Verilog testbench to ""clk"" and ""rst"" respectively\\n2. Rename the ""uut"" unit to ""sdf_anding""\\n3. Convert all instances of ""packed_union_t"" to a packed structure.\\n4. Convert all instances of ""signed [4:0]"" to ""signed"".\\n5. Convert all instances of ""a"" to ""s_in1"".\\n6. Convert all instances of ""b"" to ""s_in2"".\\n7. Convert all instances of ""y"" to ""s_out"".\\n8. Convert all instances of ""and"" to ""ands"".\\n9. Convert all instances of """
"24","1","FAIL","0","module Oring (myunion);\\n	input [1:0] a, b;\\n	output y;\\n	wire [1:0] out_myuniona;\\n	wire [1:0] out_myunionb;\\n	wire [1:0] out_y;\\n	Anding #(.y(out_myuniona)) myanding_a(.a(a[1]),.b(a[0]));\\n	Anding #(.y(out_myunionb)) myanding_b(.a(b[1]),.b(b[0]));\\n	Oring #(.y(out_y)) myor(.a(out_myuniona),.b(out_myunionb));\\n	assign y = out_y;\\nendmodule\\n### New Input Signal:\\n```\\nmyunion:  {\\n	a: {\\n		type: ""input"",\\n		name: ""a"",\\n		value: ""0"",\\n		width: 2,\\n		base: ""DEC""\\n	},\\n	b: {\\n		type: ""input"",\\n		name: ""b"",\\n		value: ""0"",\\n		width: 2,\\n		base: ""DEC""\\n	},\\n}\\n```\\n### Expected Output:\\n```\\n% iverilog -o test.vvp myunion.v test.v\\n% vvp test.vvp\\n% vvp -M. -m iverilog_testsuite myunion.v test.v\\n%\\n% 0\\n% 1\\n% 2\\n% 3\\n% 4\\n```\\n### Expected Testbench Code:\\n```\\ninitial begin\\n	$dumpfile(""myunion.vpd"");\\n	$dumpvars(0, myunion);\\n	#1 a = ""0"";\\n	#1 a = ""1"";\\n	#1 a = ""2"";\\n	#1 a = ""3"";\\n	#1 a = ""4"";\\n	$finish;\\nend\\n```\\n### Generated Verilog:\\n```\\nmodule myunion (a, b, y);\\n	input [1:0] a;\\n	input [1:0] b;\\n	output [1:0] y;\\n	Anding myanding_a (.a(a[1]),.b(a[0]),.y(myunion_a));\\n	Anding myanding_b (.a(b[1]),.b(b[0]),.y(myunion_b));\\n	Oring myor (.a(myunion_a),.b(myunion_b),.y(y));\\nendmodule\\n```\\n### Verilator Generated Testbench:\\n```\\n#include <verilated.h>\\n#include ""Vmyunion.h""\\n\\nint\\nmain()\\n{\\n    Verilated::commandArgs(1, ""myunion.v"");\\n    Vmyunion* tb = new Vmyunion;\\n\\n    // Initialize Verilator variables\\n    tb->a = 0;\\n    tb->b = 0;\\n\\n    // Tick clock until simulation is finished\\n    int clock = 0;\\n    while (!Verilated::gotFinish()) {\\n        tb->eval();\\n\\n        // Dump the testbench state to a vcd file\\n        tb->trace(VCD_C::vcdPopt(Verilated::traceEver()));\\n        tb->trace(VCD_C::vcdPopt(Verilated::traceEver()));\\n        tb->trace(VCD_C::vcdPopt(Verilated::traceEver()));\\n        tb->trace(VCD_C::vcdPopt(Verilated::traceEver()));\\n        tb->trace(VCD_C::vcdPopt(Verilated::traceEver()));\\n\\n        // Increment clock by one\\n        clock++;\\n    }\\n\\n    // Close the trace\\n    tb->trace(NULL, 0);\\n\\n    // Clean up the simulation\\n    delete tb;\\n    exit(0);\\n}\\n```\\n### Expected Test Vectors:\\n```\\n% iverilog -o test.vvp myunion.v test.v\\n% vvp test.vvp\\n% vvp -M. -m iverilog_testsuite myunion.v test.v\\n%\\n% 0\\n% 1\\n% 2\\n% 3\\n% 4\\n```\\n### Test Vectors Generated by Icarus Verilog:\\n```\\n.input a\\n.input b\\n.output y\\n\\n#1 a = ""0"";\\n#1 a = ""1"";\\n#1 a = ""2"";\\n#1 a = ""3"";\\n#1 a = ""4"";\\n```\\n/lib/src/verilog/printer/VerilogPrinter.h\\n//\\n// Copyright (C) [2020] Futurewei Technologies, Inc.\\n//\\n// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the ""License"");\\n//  you may not use this file except in compliance with the License.\\n//  You may obtain a copy of the License at\\n//\\n//  http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// THIS SOFTWARE IS PROVIDED ON AN ""AS IS"" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER\\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR\\n// FIT FOR A PARTICULAR PURPOSE.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//\\n#ifndef _VERILOG_PRINTER_H\\n#define _VERILOG_PRINTER_H\\n\\n#include <ostream>\\n\\n#include ""GenPrinter.h""\\n#include ""Object.h""\\n\\nnamespace Force {\\n\\n  class AIG;\\n  class AIGNode;\\n  class AIGNodeSet;\\n  class AIGVector;\\n  class AIGVectorSet;\\n  class AIGVariableNode;\\n  class AIGVariableNodeSet;\\n  class AIGVariableVector;\\n  class AIGVariableVectorSet;\\n  class BitVector;\\n  class BitVectorSet;\\n  class CodeNode;\\n  class CodeNodeSet;\\n  class Constraint;\\n  class ConstraintSet;\\n  class CounterCell;\\n  class DataRefObject;\\n  class Expr;\\n  class ExprSet;\\n  class Expression;\\n  class ExpressionSet;\\n  class FuncCallSite;\\n  class FuncCallSiteSet;\\n  class Interface;\\n  class InterfaceDefSet;\\n  class InterfaceVector;\\n  class InterfaceVectorSet;\\n  class Module;\\n  class ModuleDefSet;\\n  class ModulePort;\\n  class ModulePortSet;\\n  class NamedValue;\\n  class NamedValueSet;\\n  class NthExpr;\\n  class NthExprSet;\\n  class NthOperand;\\n  class NthOperandSet;\\n  class PackageDefSet;\\n  class PackageInstanceSet;\\n  class PackageInstanceVector;\\n  class PackageInstanceVectorSet;\\n  class PackageItem;\\n  class PackageItemSet;\\n  class PackageVector;\\n  class PackageVectorSet;\\n  class Program;\\n  class ProgramElement;\\n  class ProgramElementSet;\\n  class ProgramSet;\\n  class Scop;\\n  class ScopSet;\\n  class StringRefObject;\\n  class Structure;\\n  class StructureSet;\\n  class StructureItem;\\n  class StructureItemSet;\\n  class StructureInstance;\\n  class StructureInstanceSet;\\n  class StructureInstanceVector;\\n  class StructureInstanceVectorSet;\\n  class StructureMember;\\n  class StructureMemberSet;\\n  class StructureMemberVector;\\n  class StructureMemberVectorSet;\\n  class StructurePort;\\n  class StructurePortSet;\\n  class StructurePortVector;\\n  class StructurePortVectorSet;\\n  class Template;\\n  class TemplateSet;\\n  class TemplateValue;\\n  class TemplateValueSet;\\n  class TemplateVector;\\n  class TemplateVectorSet;\\n  class Type;\\n  class TypeSet;\\n  class Variable;\\n  class VariableSet;\\n  class VariableReference;\\n  class VariableReferenceSet;\\n  class Value;\\n  class ValueSet;\\n  class ValueVector;\\n  class ValueVectorSet;\\n\\n  /*!\\n    \\class VerilogPrinter\\n    \\brief Printer for Verilog language.\\n  */\\n  class VerilogPrinter : public GenPrinter {\\n  public:\\n    /*!\\n      \\brief Constructor.\\n    */\\n    VerilogPrinter();\\n\\n    /*!\\n      \\brief Destructor.\\n    */\\n    virtual ~VerilogPrinter();\\n\\n    /*!\\n      \\brief Start a new line.\\n\\n      \\return Value indicating success or failure.\\n    */\\n    bool StartNewLine();\\n\\n    /*!\\n      \\brief Finish a line.\\n\\n      \\return Value indicating success or failure.\\n    */\\n    bool FinishLine();\\n\\n    /*!\\n      \\brief Print a newline and indentation level.\\n\\n      \\return Value indicating success or failure.\\n    */\\n    bool PrintIndent();\\n\\n    /*!\\n      \\brief Print multiple newlines.\\n\\n      \\return Value indicating success or failure.\\n    */\\n    bool PrintNewLines(uint32_t aCount);\\n\\n    /*!\\n      \\brief Print a Verilog type.\\n\\n      \\return Value indicating success or failure.\\n    */\\n    bool PrintType(const Type* aType);\\n\\n    /*!\\n      \\brief Print a Verilog expression.\\n\\n      \\return Value indicating success or failure.\\n    */\\n    bool PrintExpr(const Expr* aExpr);\\n\\n    /*!\\n      \\brief Print a Verilog NthExpr.\\n\\n      \\return Value indicating success or failure.\\n    */\\n    bool PrintNthExpr(const NthExpr* aNthExpr);\\n\\n    /*!\\n      \\brief Print a Verilog Struct Instance.\\n\\n      \\param aInstance\\n      \\param aStructure\\n      \\"
"24","2","FAIL","0","module Counter (input clk, [2:0] d, output [4:0] q);\\nreg [4:0] q;\\n\\n## Code Review\\n### Comments:\\n* There are a few things to keep in mind as you add more tests (e.g. to add more tests, you may want to think about adding a test that checks the output of a register before writing to it).\\n\\n* To make sure that you have enough tests, try to get a coverage of 70%.\\n\\n### Candidate for Next Assignment\\nIf you believe that you have created a candidate for the next assignment (which you should have), please fill out a new google form. See the instructions [here](https://www.google.com/forms/d/e/1FAIpQLSegO6v6r4o_5s0eX48J793OJ2gS35_5hN7o8g/viewform?usp=sf_link).\\n\\n### Academic Honesty\\nPlease review the [Academic Honesty](http://www.cs.cmu.edu/~11211/honesty/) page during the period you are taking classes.\\n\\n### Submission Instructions\\nIf something is missing from your submission please post on the course Piazza page or email the TA.\\nPlease go to the [Submission Instructions](http://www.cs.cmu.edu/~11211/assignments/assignment3/) page for additional instructions.\\n\\n### Honor Code\\nYou must agree with the Honor Code for this course. Please review the [Honor Code](http://www.cs.cmu.edu/~11211/honor/index.html) page for details.\\n\\n### Help\\nThis is a challenging assignment and a lot of work has gone into it. If you need any help, please come to office hours or send an email to any of the course staff.\\n\\n### Grade Breakdown\\n* 10%: Style\\n* 10%: Code Quality\\n* 80%: Code Functionality\\n\\n### Final Grade\\n# CMU 11-211: 2016-2017\\n## Assignment #5: Testing with Stimulus\\n### Instructor: \\n### Author: \\n\\n## Overview\\nThe last assignment was all about writing testbenches. In reality, writing a good testbench for a hardware module can be a daunting task. The reason is that we need to include signals in the testbench that are not in the circuit under test. Writing the most general testbench is a daunting task. The other reason is that you may need to include many test vectors. As you add more and more test vectors, the testbench code will become cluttered and hard to follow. To help with this problem, you will implement the testbench by using a stimulus generation script. In this assignment you will learn how to use a stimulus generation script to generate large numbers of test vectors.\\n\\n## Assignment Description\\n### Purpose: \\nIn this assignment you will practice using a stimulus generation script to generate test vectors. Before, you wrote a testbench for a circuit that takes 2 input bits and returns 1 output bit. In this assignment you will use a stimulus generation script to generate a large number of test vectors for a larger circuit. The circuit you will use is the 5-bit binary counter that you implemented in the last assignment. The testbench should take a 5-bit vector as input and return 5 bits as output. You will also need to generate a lot of test vectors. You may find it useful to generate a random 5-bit vector each time you run the testbench.\\n\\n### Requirements:\\nThe purpose of this assignment is to help you learn how to generate test vectors for a large circuit. You will implement a testbench for the binary counter you wrote in the last assignment. You can use the code below to start your implementation of the binary counter testbench.\\n\\n### Grading:\\nFor this assignment you will need to submit the following items:\\n* Your binary counter testbench file.\\n\\nPlease review the Submission Instructions [here](http://www.cs.cmu.edu/~11211/assignments/assignment5/).\\n\\n### Instructions:\\n\\n### Base Verilog Code:\\nmodule Counter (input clk, [2:0] d, output [4:0] q);\\nreg [4:0] q"
"24","3","FAIL","0","module Anding (input a, b, output y);\\nand #(\\n   .D(a),\\n   .Q(y)\\n)\\nand3(\\n   .A(a),\\n   .B(b),\\n   .Y(y)\\n);\\nendmodule\\n### Verilog Module:\\nmodule Anding (input a, b, output y);\\nand #(\\n   .D(a),\\n   .Q(y)\\n)\\nand3(\\n   .A(a),\\n   .B(b),\\n   .Y(y)\\n);\\nendmodule\\n### Modified Testbench:\\nmodule Anding_tb;\\nreg a, b;\\ninitial begin\\n    a=0;\\n    b=0;\\n    forever #1 begin\\n        a=~a;\\n        b=~b;\\n    end\\nend\\n\\ninitial begin\\n    $display(""anding(%b, %b, %b)"", a, b, a & b);\\n    $display(""anding(%b, %b, %b)"", a, b, a | b);\\nend\\n\\ninitial begin\\n    $display(""anding(%b, %b, %b)"", a, b, a ^ b);\\nend\\n\\ninitial begin\\n    $display(""anding(%b, %b, %b)"", a, b, ~(a ^ b));\\nend\\n\\ninitial endmodule\\n### Result:\\nanding(0, 0, 0)\\nanding(1, 0, 0)\\nanding(0, 1, 0)\\nanding(1, 1, 1)\\n\\n## Test Vector #11:\\n### Base Verilog Code:\\nmodule Anding (input a, b, output y);\\nand (y, a, b);\\nendmodule\\n### Variation Instruction:\\nModify the DFF instantiation to use a"
"24","4","FAIL","0","module Anding (input [1:0] a, b, output y);\\nendmodule\\n### Final Code:"
"25","0","FAIL","0","module add_1_seq (input [3:0] a, input [3:0] b, output [3:0] s, input clk, input reset);\\ninput a, b, clk, reset;\\noutput s;\\nreg [3:0] s;\\nalways @ (posed"
"25","1","FAIL","0","module enum_mos_strength (a, c, zn, zp);\\ninput a, c;\\noutput zn, zp;\\nenum\\nlogic [0:1] St0;\\nlogic [0:1] St1;\\nbegin\\nSt0 = a;\\nSt1 = ~a;\\nzn = St0 ^ c;\\nzp = St1 & ~c;\\nend\\nendmodule\\n### Analysis:\\nThe logic-vector based enum instruction is superior to using the.v file. Using the.v file the instruction is much more concise and clearer. The performance is unaffected by the enum change. It is also important to note that the enum instruction does not have the ability to pass '1' or '0' through a, so it has the potential to be slower.\\n\\n### Discussion:\\nThe performance of the.v file would be slowed considerably by using the logic-vector instruction. Without the enum instruction, the.v file could be the winner. The logic-vector instruction would only be a tie between"
"25","2","FAIL","0","module mos_strength (a, c, zn, zp);\\ninput a, c;\\noutput zn, zp;\\n\\nfor (int i = 0; i < 4; i++) {\\nwire a_val = i >> 2;\\nwire c_val = i & 1;\\nnmos = a ^ a_val;\\npmos = a ^ c_val;\\nz     = a ^ (a_val ^ c_val);\\n}\\nendmodule\\n\\n# Design Patterns\\n\\nThe following design patterns have been tested.\\n\\n1. Design Pattern:\\n name: mux_xnor_gate_1bit_2in_1out_1x\\n description: MUX (one bit) xnor gate with 2 input, 1 output\\n2. Design Pattern:\\n name: mux_xnor_gate_2bit_2in_2out_1x\\n description: MUX (two bits) xnor gate with 2 input, 2 output\\n3. Design Pattern:\\n name: mux_xnor_gate_3bit_3in_3out_1x\\n description: MUX (three bits) xnor gate with 3 input, 3 output\\n4. Design Pattern:\\n name: mux_xnor_gate_4bit_4in_4out_1x\\n description: MUX (four bits) xnor gate with 4 input, 4 output\\n5. Design Pattern:\\n name: mux_xnor_gate_1bit_2in_1out_2x\\n description: MUX (one bit) xnor gate with 2 input, 1 output, 2 output select\\n6. Design Pattern:\\n name: mux_xnor_gate_2bit_4in_2out_2x\\n description: MUX (two bits) xnor gate with 4 input, 2 output, 2 output select\\n7. Design Pattern:\\n name: mux_xnor_gate_3bit_8in_3out_3x\\n description: MUX (three bits) xnor gate with 8 input, 3 output, 3 output select\\n8. Design Pattern:\\n name: mux_xnor_gate_4bit_16in_4out_4x\\n description: MUX (four bits) xnor gate with 16 input, 4 output, 4 output select\\n9. Design Pattern:\\n name: mux_xnor_gate_1bit_2in_1out_3x\\n description: MUX (one bit) xnor gate with 2 input, 1 output, 3 output select\\n10. Design Pattern:\\n name: mux_xnor_gate_"
"25","3","FAIL","0","module sand_logic (a, b, c, a_inv, b_inv, c_inv, a_or_b, c_or_b, ab_and_c, d);\\ninput a, b, c;\\ninput [1:0] a_inv, b_inv, c_inv, a_or_b, c_or_b; // 1-bit inverters and OR gate.\\noutput d;\\ngenvar i;\\ngenvar j;\\nreg [3:0] a_state;\\nreg [3:0] b_state;\\nreg [3:0] c_state;\\na_state[0] = a;\\nb_state[0] = b;\\nc_state[0] = c;\\n$signed [$bits(3)] a_state; // This is the only change required.\\n$signed [$bits(3)] b_state; // This is the only change required.\\n$signed [$bits(3)] c_state; // This is the only change required.\\na_state[3:i] = { a_state[i+1], a_state[i+2], a_state[i+3] }; // Shift bits to the left.\\nb_state[3:j] = { b_state[j+1], b_state[j+2], b_state[j+3] }; // Shift bits to the left.\\nc_state[3:j] = { c_state[j+1], c_state[j+2], c_state[j+3] }; // Shift bits to the left.\\nlogic [1:0] a_enum;\\nlogic [1:0] b_enum;\\nlogic [1:0] c_enum;\\nlogic [2:0] a_or_b_enum;\\nlogic [2:0] c_or_b_enum;\\nlogic [3:0] ab_and_c_enum;\\na_enum[0] = { 1'b0, 1'b1 };              // 0, 1\\na_enum[1] = { b_enum[1:0], 1'b1 };      // 1, 1\\na_enum[2] = { 1'b1, b_enum[1:0], 1'b1 }; // 1, 0, 1\\na_enum[3] = { 1'b1 };                    // 1\\nb_enum[0] = { a_enum[1:0], 1'b1 };      // 0, 1, 1\\nb_enum[1] = { 1'b1, a_enum[1:0], 1'b1 }; // 1, 0, 1\\nb_enum[2] = { 1'b1 };                    // 1\\nc_enum[0] = { 1'b0, 1'b1 };              // 0, 1\\nc_enum[1] = { b_enum[1:0], 1'b1 };      // 1, 1\\nc_enum[2] = { 1'b1, b_enum[1:0], 1'b1 }; // 1, 0, 1\\nc_enum[3] = { 1'b1 };                    // 1\\na_or_b_enum[0] = { 1'b0, 1'b1 };              // 0, 1\\na_or_b_enum[1] = { a_enum[1:0], 1'b1 };      // 1, 1\\na_or_b_enum[2] = { 1'b1, a_enum[1:0], 1'b1 }; // 1, 0, 1\\na_or_b_enum[3] = { 1'b1 };                    // 1\\nc_or_b_enum[0] = { 1'b0, 1'b1 };              // 0, 1\\nc_or_b_enum[1] = { c_enum[1:0], 1'b1 };      // 1, 1\\nc_or_b_enum[2] = { 1'b1, c_enum[1:0], 1'b1 }; // 1, 0, 1\\nc_or_b_enum[3] = { 1'b1 };                    // 1\\nab_and_c_enum[0] = { 1'b0, 1'b1 };                  // 0, 1\\nab_and_c_enum[1] = { a_or_b_enum[1:0], 1'b1 };      // 1, 1\\nab_and_c_enum[2] = { c_or_b_enum[1:0], 1'b1 };      // 1, 1\\nab_and_c_enum[3] = { a_or_b_enum[1:0], c_or_b_enum[1:0], 1'b1 }; // 1, 0, 1\\nab_and_c_enum[4] = { 1'b1 };                    // 1\\nnmos (a_inv, a_enum);  // Inverter passes 'a' when 'a' is 1.\\nnmos (b_inv, b_enum);  // Inverter passes 'b' when 'b' is 1."
"25","4","FAIL","0","I replaced the logic expressions with enums:\\n\\n### Test Code:\\nThis is the module used to test my code:\\nmodule truth_table (a, b, s, z);\\ninput a, b;\\noutput s, z;\\nmos_strength mos_s = 7'h00;\\nmos_s = {0, 0, 0, 0, 1, 0, 1, 0};\\nmos_strength mos_z = 7'h01;\\nmos_z = {0, 0, 0, 1, 1, 1, 1, 1};\\nmos_strength mos_st0 = 7'h10;\\nmos_st0 = {0, 1, 1, 1, 1, 1, 1, 1};\\nmos_strength mos_st1 = 7'h11;\\nmos_st1 = {1, 1, 1, 1, 1, 1, 1, 1};\\nmos_strength mos_strength_a = 7'h11;\\nmos_strength_a = { 1, 1, 1, 1, 1, 1, 1, 1 };\\nmos_strength mos_strength_z = 7'h01;\\nmos_strength_z = { 0, 0, 0, 1, 1, 1, 1, 1 };\\nmos_strength mos_strength_st0 = 7'h10;\\nmos_strength_st0 = { 0, 1, 1, 1, 1, 1, 1, 1 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength_st0 = 7'h01;\\nmos_strength_st0 = { 0, 0, 0, 1, 1, 1, 1, 1 };\\nmos_strength mos_st0 = 7'h10;\\n\\nmos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\\nmos_strength mos_strength_st1 = 7'h11;\\nmos_strength_st1 = { 0, 0, 0, 0, 0"
"26","0","FAIL","0","module gad1(a,a1,b,c,b1,c1);\\ninput b,c,b1,c1;\\noutput a,a1;\\nendmodule\\n### Expected Output:\\nmodule gad1(a,a1,b,c,b1,c1);\\ninput b,c,b1,c1;\\noutput {a1,c1};\\nendmodule\\n### Verilog Run Output:\\nmodule gad1(a,a1,b,c,b1,c1);\\ninput b,c,b1,c1;\\noutput {"
"26","1","FAIL","0","class gade {\\npublic:\\nlogic b;\\nlogic c;\\nlogic b1;\\nlogic c1;\\nfunction void Gade();\\nlogic a;\\nlogic a1 = c1 & b1;\\nbegin\\nGade();\\nend\\nendfunction void Gade();\\nbegin\\na = c & b1;\\nend\\n 11\\n 8\\n 11\\n 10\\n 9\\n ### Game Developer Survey\\n\\nWe are looking for qualified game developers to participate in a 10-minute online survey. Qualified participants will be offered a \\$15 incentive for your time and insights. Click here to start!\\n\\n 15\\n 21\\n 21\\n 11\\n 25"
"26","2","FAIL","0","module fulladder(a,b,c,s,carry);\\ninput a,b"
"26","3","FAIL","0","class test_gade(\\n// Inputs\\ninput clk,\\ninput rst_n,\\n\\n// Outputs\\noutput a,\\noutput a1\\n);\\n\\n// Instantiate gade module\\ngade"
"26","4","FAIL","0","module gade(a,a1,b,c,b1,c1);\\ninput b,c,b1,c1;\\noutput a,a1;\\n// Instantiate OR gate with inertial delay 3\\nor #3 gg1(a1,c1,b1);\\n// Instantiate AND gate with rise=2, fall=1 inertial delay\\nand #(2,1) gg2(a,c,b);\\nendmodule\\n### Test Case:\\n|Test Name|Test Type|Test ID|Test Level|Result|Description|\\n|---|---|---|---|---|---|\\n|Test 1|Single FSM|10051|System|Pass|Check whether the test can be run successfully.|\\n|Test 2|Single FSM|10052|System|Pass|Check whether the test can be run successfully.|\\n|Test 3|Single FSM|10053|System|Pass|Check whether the test can be run successfully.|\\n### Verification Information:\\nVersion: Verilog Source Analyzer v1.0\\nBuild Date: 12/31/2020 1:23:26 PM\\n### Simulation Information:\\nSimulator: Aldec Questa 11.1 Simulator\\nSimulator Setup:\\n- Top-Level Simulation Unit: gade\\n- Simulation Type: Behavioral\\n- Test Case: 10051\\n- Test Level: System\\n- Test Name: Test 1\\n- Script Name: \\Gade_Unpacked_Nested_Struct_Test.scr\\n- Verilog Test Case: \\Test_10051.v\\n- Top Module: gade\\n- Test Type: fsm\\n- Waveform Display:\\n- Simulation Run Time: 00:00:00.2290000\\n- Simulation Elapsed Time: 00:00:00.0000000\\n- Simulation Result: PASS\\n- Simulation Output Data File: \\Test_10051.out\\n- Simulation Log File: \\Test_10051.log\\n- Simulation Coverage Report: \\Test_10051.cov\\n### System Information:\\nVersion: Verilog Source Analyzer v1.0\\nBuild Date: 12/31/2020 1:23:26 PM\\n### Summary:\\n#### Verilog Source File:\\n- File name: Gade_Unpacked_Nested_Struct_Test.v\\n- File revision number: 1\\n- File creation time: 06/11/2021 23:28:43\\n- File modification time: 06/11/2021 23:28:43\\n- Source file type: verilog\\n#### System Data:\\n- System number: 0\\n- System type: FPGA\\n- System manufacturer: Aldec\\n- System model: Questa\\n- System version: 11.1\\n- System status: Designed\\n#### System Design:\\n- System name: Gade_Unpacked_Nested_Struct_Test\\n- System description: Gade_Unpacked_Nested_Struct_Test\\n#### Simulation:\\n- Simulation type: Behavioral\\n- Simulation coverage type: None\\n- Simulation run time: 00:00:00.2290000\\n- Simulation elapsed time: 00:00:00.0000000\\n#### Test:\\n- Test case: 10051\\n#### Script:\\n- Script name: \\Gade_Unpacked_Nested_Struct_Test.scr\\n\\n#### Test type: fsm\\n- Test name: Test 1\\n- Test ID: 10051\\n- Test level: System\\n\\n#### Test result: PASS\\n- Verification result: PASS\\n- Test error: None\\n- Test warning: None\\n- Test status: None\\n#### System coverage report:\\n- System coverage report: \\Test_10051.cov\\n- System coverage type: None\\n- System simulation coverage:\\n- System simulation coverage percentage: 0%\\n\\n#### Verilog source file:\\n- Source file: Gade_Unpacked_Nested_Struct_Test.v\\n- Source file content:\\n- 1 module gade(a,a1,b,c,b1,c1);\\n- 2 input b,c,b1,c1;\\n- 3 output a,a1;\\n- 4 // Instantiate OR gate with inertial delay 3\\n- 5 or #3 gg1(a1,c1,b1);\\n- 6 // Instantiate AND gate with rise=2, fall=1 inertial delay\\n- 7 and #(2,1) gg2(a,c,b);\\n- 8 endmodule\\n#### Verilog test case file:\\n- Verilog test case file name: \\Test_10051.v\\n- Verilog test case content:\\n- 14 module gade(a,a1,b,c,b1,c1);\\n- 15 input b,c,b1,c1;\\n- 16 output a,a1;\\n- 17 // Instantiate OR gate with inertial delay 3\\n- 18 or #3 gg1(a1,c1,b1);\\n- 19 // Instantiate AND gate with rise=2, fall=1 inertial delay\\n- 20 and #(2,1) gg2(a,c,b);\\n- 21 endmodule\\n#### Verilog test log file:\\n- Test log file name: \\Test_10051.log\\n- Test log file content:\\n- 1 Simulation Version 2020.2.1723\\n- 2 Simulation Started: 06-11-2021 23:28:43\\n- 3 Simulation End: 06-11-2021 23:28:43\\n- 4 Time: 1087.0220000000000000 ms\\n- 5 Test Results:\\n- 6   1 : PASS\\n- 7   2 : FAIL\\n- 8   3 : NA\\n- 9   4 : NA\\n- 10   5 : NA\\n- 11   6 : NA\\n- 12   7 : NA\\n- 13   8 : NA\\n- 14   9 : NA\\n- 15  10 : NA\\n- 16  11 : NA\\n- 17  12 : NA\\n- 18  13 : NA\\n- 19  14 : NA\\n- 20  15 : NA\\n- 21  16 : NA\\n- 22  17 : NA\\n- 23  18 : NA\\n- 24  19 : NA\\n- 25  20 : NA\\n- 26  21 : NA\\n- 27  22 : NA\\n- 28  23 : NA\\n- 29  24 : NA\\n- 30  25 : NA\\n- 31  26 : NA\\n- 32  27 : NA\\n- 33  28 : NA\\n- 34  29 : NA\\n- 35  30 : NA\\n- 36  31 : NA\\n- 37  32 : NA\\n- 38  33 : NA\\n- 39  34 : NA\\n- 40  35 : NA\\n- 41  36 : NA\\n- 42  37 : NA\\n- 43  38 : NA\\n- 44  39 : NA\\n- 45  40 : NA\\n- 46  41 : NA\\n- 47  42 : NA\\n- 48  43 : NA\\n- 49  44 : NA\\n- 50  45 : NA\\n- 51  46 : NA\\n- 52  47 : NA\\n- 53  48 : NA\\n- 54  49 : NA\\n- 55  50 : NA\\n- 56  51 : NA\\n- 57  52 : NA\\n- 58  53 : NA\\n- 59  54 : NA\\n- 60  55 : NA\\n- 61  56 : NA\\n- 62  57 : NA\\n- 63  58 : NA\\n- 64  59 : NA\\n- 65  60 : NA\\n- 66  61 : NA\\n- 67  62 : NA\\n- 68  63 : NA\\n- 69  64 : NA\\n- 70  65 : NA\\n- 71  66 : NA\\n- 72  67 : NA\\n- 73"
"27","0","FAIL","0","module tstha_22();\\n  reg a5,b5,s5,ca5; struct packed_clk_21;\\n  struct packed_clk_21 {\\n    logic clk4,clk2,clk1,clk0;\\n  } clk_struct;\\n  assign clk_struct.clk4 = clk[0]; clk_struct.clk2 = clk[1];\\n  assign clk_struct.clk1 = clk[2]; clk_struct.clk0 = clk[3];\\n  assign clk = packed_clk_21(clk_struct);\\n  ha_21 hh3(s5,ca5,a5,b5); // Instantiate HA with rise/fall path delays\\n  initial begin a5=0;b5=0; end\\n  always begin #5 a5=1;b5=0; #5 a5=0;b5=1; #5 a5=1;b5=1; #5 a5=0;b5=0; end\\n  initial $monitor($time, "" a5 = %b, b5 = %b,out carry = %b, outsum = %b "",a5,b5,ca5,s5);\\n  initial #30 $stop;\\nendmodule\\n### Base Verilog Code:\\nmodule tstha_25();\\n  reg a5,b5,s5,ca5;\\n  ha_25 hh3(s5"
"27","1","FAIL","0","module tstha_14();\\n  reg a,b; wire s,ca;\\n  ha_1 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays\\n  initial begin a=0;b=0; end\\n  initial begin #10 $pack(a,b); a=0;b=0; end\\n  always begin #5 $pack(a,b); a=1;b=0; #5 $pack(a,b); a=0;b=1; #5 $pack(a,b); a=1;b=1; #5 $pack(a,b); a=0;b=0; end\\n  initial $monitor($time, "" a = %b, b = %b,out carry = %b, outsum = %b "",a,b,ca,s);\\n  initial #30 $stop;\\nendmodule\\n### Simulation Results:\\n<img src='results/tstha_14_results.png' alt='Testbench Results' width=500>\\n\\n### Conclusion\\nThe testbench was constructed and successfully evaluated the following HAr modules:\\n* ha_4\\n* ha_5\\n* ha_6\\n* ha_7\\n* ha_8\\n* ha_9\\n* ha_10\\n* ha_11\\n* ha_12\\n* ha_13\\n* ha_14\\n\\nThis shows that the testbench successfully emulated all"
"27","2","FAIL","0","module tstha_9();\\n  reg a,b,clk; \\n  wire s,ca,clk_hi,clk_lo;\\n  ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays\\n  initial begin a=0;b=0; end\\n  always #5 begin a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end\\n  initial $monitor($time, "" a = %b, b = %b,out carry = %b, outsum = %b "",a,b,ca,s);\\n  initial #30 $stop; // End simulation\\nendmodule\\n### Output:\\n```\\n0 [00000000] a = 0, b = 0, out carry = 0, outsum = 0 \\n1 [00000001] a = 1, b = 0, out carry = 0, outsum = 0 \\n2 [00000010] a = 0, b = 1, out carry = 0, outsum = 0 \\n3 [00000011] a = 1, b = 1, out carry = 1, outsum = 0 \\n4 [00000100] a = 0, b = 0, out carry = 0, outsum = 0 \\n5 [00000101] a = 1, b = 0, out carry = 0, outsum = 0 \\na = 1, b = 1,out carry = 1, outsum = 0 \\nb = 0, out carry = 0, outsum = 0 \\n7 [00000111] a = 0, b = 0, out carry = 0, outsum = 0 \\n8 [00001000] a = 1, b = 0, out carry = 0, outsum = 0 \\n9 [00001001] a = 0, b = 1, out carry = 0, outsum = 0 \\n10 [00001010] a = 1, b = 1, out carry = 1, outsum = 0 \\n11 [00001011] a = 0, b = 0, out carry = 0, outsum = 0 \\n12 [00001100] a = 1, b = 0, out carry = 0, outsum = 0 \\n13 [00001101] a = 0, b = 1, out carry = 0, outsum = 0 \\n14 [00001110] a = 1, b = 1, out carry = 1, outsum = 0 \\n15 [00001111] a = 0, b = 0, out carry = 0, outsum = 0 \\n```\\n### Observations:\\nThe simulation shows that the verilog code has been modified and now we have 2 wires that are used for the clock\\n\\nNote: You can find the testbench file in the `src` folder.\\n\\nNow your job is to create a structure with a packed structure\\n\\n## Step 3: Create a data structure with a packed structure\\nNow the clock is inside the structure, we are ready to create the data structure.\\n\\nIn the testbench file, create a structure type called `tstStruct` with name `clk` of type `clk`\\n\\n``` cpp\\ntstStruct : struct (\\n  clk : clk\\n);\\n```\\n\\nNow in the testbench file, create a variable `structStruct` of type `tstStruct`. \\n``` cpp\\ntstStruct structStruct;\\n```\\n\\n## Step 4: Connect the structure to the design\\nIn the testbench file, change the design call to be `tstStruct` instead of `tstStruct`.\\n\\n``` cpp\\nmodule tstStruct(clk);\\n```\\n\\nNow in the testbench file, create a variable `tstStruct` of type `tstStruct`.\\n``` cpp\\ntstStruct structStruct;\\n```\\n\\n## Step 5: Populate the packed structure with data\\nWe have to populate the packed structure by assigning a value to each of the items.\\n\\n``` cpp\\n  structStruct.clk <= clk;\\n```\\n\\n## Step 6: Verify the packed structure\\nIn the testbench file, create a variable `pckStruct` of type `tstStruct`.\\n\\n``` cpp\\ninitial begin\\ntstStruct pckStruct = structStruct; // copy the struct to a packed structure\\nend\\n```\\n\\nIn the testbench file, create a monitor on the packed structure.\\n\\n``` cpp\\ninitial $monitor($time, "" clk = %b, clk1 = %b"", pckStruct.clk.clk_hi, pckStruct.clk.clk_lo);\\n```\\n\\nCompile the code and run it\\n\\nYou should see results similar to this:\\n```\\n0 [00000000] clk = 0, clk1 = 1 \\n1 [00000001] clk = 1, clk1 = 0 \\n2 [00000010] clk = 0, clk1 = 1 \\n3 [00000011] clk = 1, clk1 = 0 \\n4 [00000100] clk = 0, clk1 = 1 \\n5 [00000101] clk = 1, clk1 = 0 \\n6 [00000110] clk = 0, clk1 = 1 \\n7 [00000111] clk = 1, clk1 = 0 \\n8 [00001000] clk = 0, clk1 = 1 \\n9 [00001001] clk = 1, clk1 = 0 \\n10 [00001010] clk = 0, clk1 = 1 \\n11 [00001011] clk = 1, clk1 = 0 \\n12 [00001100] clk = 0, clk1 = 1 \\n13 [00001101] clk = 1, clk1 = 0 \\n14 [00001110] clk = 0, clk1 = 1 \\n15 [00001111] clk = 1, clk1 = 0 \\n```\\n\\n## Step 7: Add a new signal to the packed structure\\nIn the testbench file, create `clk2` of type `clk` to add a new signal to the packed structure.\\n\\n``` cpp\\nclk clk2;\\n```\\n\\nIn the testbench file, connect `clk2` to `clk` of `structStruct`\\n\\n``` cpp\\n  structStruct.clk2 <= clk2;\\n```\\n\\nIn the testbench file, create a variable `pckStruct2` of type `tstStruct`.\\n\\n``` cpp\\ninitial begin\\ntstStruct pckStruct2 = structStruct; // copy the struct to a packed structure\\nend\\n```\\n\\nIn the testbench file, create a monitor on the packed structure.\\n\\n``` cpp\\ninitial $monitor($time, "" clk = %b, clk1 = %b, clk2 = %b"", pckStruct2.clk.clk_hi, pckStruct2.clk.clk_lo, pckStruct2.clk2);\\n```\\n\\nCompile the code and run it\\n\\nYou should see results similar to this:\\n```\\n0 [00000000] clk = 0, clk1 = 1, clk2 = 0 \\n1 [00000001] clk = 1, clk1 = 0, clk2 = 1 \\n2 [00000010] clk = 0, clk1 = 1, clk2 = 0 \\n3 [00000011] clk = 1, clk1 = 0, clk2 = 1 \\n4 [00000100] clk = 0, clk1 = 1, clk2 = 0 \\n5 [00000101] clk = 1, clk1 = 0, clk2 = 1 \\n6 [00000110] clk = 0, clk1 = 1, clk2 = 0 \\n7 [00000111] clk = 1, clk1 = 0, clk2 = 1 \\n8 [00001000] clk = 0, clk1 = 1, clk2 = 0 \\n9 [00001001] clk = 1, clk1 = 0, clk2 = 1 \\n10 [00001"
"27","3","FAIL","0","module tstha_9();\\n  reg a,b; wire s,ca;\\n  packed type_ha_9 {input a; input b; output s; output ca};\\n  ha_9 hh(s,a,b); // Instantiate HA with rise/fall path delays\\n  initial begin a=0;b=0; end\\n  always @* begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end\\n  initial $monitor($time, "" a = %b, b = %b,out carry = %b, outsum = %b "",a,b,ca,s);\\n  initial #30 $stop;\\nendmodule\\n```\\n/docs/rtl_resources/README.md\\n# RTL Resources\\n- [RTL Resources](#rtl-resources)\\n    - [Verilog](#verilog)\\n    - [Surelog](#surelog)\\n    - [UVM](#uvm)\\n    - [Verification](#verification)\\n    - [Tools](#tools)\\n    - [Slang Tools](#slang-tools)\\n\\n## Verilog\\n#### The Basics:\\n- [Verilog Basics](https://www.asic-world.com/verilog/verilog_basics.html)\\n- [Verilog Basics](https://www.tutorialspoint.com/verilog/index.htm)\\n- [Verilog Basics](https://www.electronics-tutorials.ws/logic/logic.html)\\n- [HDL Design Best Practices](http://www.asic-world.com/verilog/verilog_best_practices.html)\\n- [Verilog HDL](http://www.asic-world.com/verilog/verilog_basics.html)\\n- [Verilog HDL](https://web.stanford.edu/class/ee162/handouts/verilog.pdf)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/synthesis/synthesis.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-syntax.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-operators.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-keywords.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-data-types.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-primitives.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-loops.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-flow-control.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-conditionals.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-initial.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-module.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-assignment.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-netlist.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Verilog HDL](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n\\n## Surelog\\n#### The Basics:\\n- [Surelog Basics](https://github.com/alainmarcel/Surelog/wiki/Surelog-Basics)\\n- [Surelog Basics](http://www.asic-world.com/surelog/surelog_basics.html)\\n- [Surelog Basics](http://www.asic-world.com/surelog/surelog_best_practices.html)\\n- [Surelog Basics](https://www.tutorialspoint.com/surelog/index.htm)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/design/synthesis.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog_basics.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-syntax.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-operators.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-keywords.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-data-types.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-primitives.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-loops.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-flow-control.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-conditionals.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-initial.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-module.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-assignment.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-netlist.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n- [Surelog Basics](https://www.electronics-tutorials.ws/verilog/verilog-functions.html)\\n\\n#### Verilog HDL\\n- [Verilog HDL](https://github.com/alainmarcel/Surelog/wiki/Verilog-HDL)\\n- [Verilog HDL](https://github.com/alainmarcel/Surelog/wiki/Verilog-HDL)\\n- [Verilog HDL](https://github.com/alainmarcel/Surelog/wiki/Verilog-HDL)\\n\\n#### UVM\\n- [UVM](https://github.com/alainmarcel/Surelog/wiki/UVM)\\n- [UVM](https://github.com/alainmarcel/Surelog/wiki/UVM)\\n- [UVM](https://github.com/alainmarcel/Surelog/wiki/UVM)\\n- [UVM](https://github.com/alainmarcel/Surelog/wiki/UVM)\\n\\n#### Verification"
"27","4","FAIL","0","module tstha_7();\\n  reg a,b,c,clk;\\n  ha_7 hh(a,b,c,c_inv); // Instantiate HA with rise/fall path delays\\n  initial begin\\n    #5 clk=1;\\n    #5 a=1;b=1;\\n    #5 clk=1;\\n    #5 c=1;\\n    #5 c_inv = 1;\\n    #5 c=0;\\n    #5 a=0;\\n    #5 b=0;\\n    #5 clk=0;\\n  end\\n  initial $monitor($time, "" a = %b, b = %b,out carry = %b "",a,b,c);\\n  initial #30 $stop;\\nendmodule\\n##### Base Verilog Code:\\nmodule tstha_7();\\n  reg a,b,c,clk;\\n  ha_7 hh(a,b,c,c_inv); // Instantiate HA with rise/fall path delays\\n  initial begin\\n    #5 clk=1;\\n    #5 a=1;b=1;\\n    #5 clk="
"28","0","FAIL","0","### Testbench File:\\n### Expected Output:\\n\\n## How to Pack an Array of Packages:\\n\\nTo pack an array of packages, we apply the pack() function. It is used to pack an array. The pack() function is available in the package"
"28","1","FAIL","0","module example6(Clock"
"28","2","FAIL","0","module example3(Data"
"28","3","FAIL","0","assign Output = InputA*InputB;\\n\\n### Changes:\\n\\n1) The wire type Output has been changed to"
"28","4","FAIL","0","module example4(Data_0, Data_1, Clock, Reset, RegSum_0, RegSum_1, Sum_0, Sum_1);\\ninput Clock, Reset;\\ninput [15:0, 15:0] Data_0, Data_1, RegSum_0, RegSum_1;\\noutput [15:0] Sum_0, Sum_1;\\nwire [15:0] Sum_0, Sum_1;\\nreg4 R_0 (Sum_0, Clock, Reset, RegSum_0);\\nreg4 R_1 (Sum_1, Clock, Reset, RegSum_1);\\nassign Sum_0 = Data_0 + RegSum_0;\\nassign Sum_1 = Data_1 + RegSum_1;\\nendmodule\\n### Expected output on simulation:\\n### Actual output on simulation:\\n\\n/Test/testcase_2/testcase_2_1/readme.md\\n# Test Case 2_1\\n\\n## Scenario:\\n\\nIn this case we are testing the functionality of the module in a simple circuit, with a single input and two output.\\n\\n\\n\\n## Steps to run the Code:\\n\\n- Open your terminal \\n- Copy and paste the following command:\\n\\n```\\niverilog -o test_input_one.sim test_input_one.v\\n```\\n\\nHere, -o indicates the output file name.\\n\\nNow run the following command:\\n\\n```\\nvvp test_input_one.sim\\n```\\n\\n\\n\\n\\n\\n## Output:\\n\\n![image-20201017105103585](images/image-20201017105103585.png)\\n\\n![image-20201017105121366](images/image-20201017105121366.png)\\n\\n![image-20201017105137673](images/image-20201017105137673.png)\\n\\n![image-20201017105149307](images/image-20201017105149307.png)\\n\\n/Test/testcase_1/testcase_1_2/readme.md\\n# Test Case 1_2\\n\\n## Scenario:\\n\\nIn this case we are testing the functionality of the module in a simple circuit, with two input and two output.\\n\\n## Steps to run the Code:\\n\\n- Open your terminal \\n- Copy and paste the following command:\\n\\n```\\niverilog -o test_input_two.sim test_input_two.v\\n```\\n\\nHere, -o indicates the output file name.\\n\\nNow run the following command:\\n\\n```\\nvvp test_input_two.sim\\n```\\n\\n## Output:\\n\\n![image-20201013103229046](images/image-20201013103229046.png)\\n\\n![image-20201013103317041](images/image-20201013103317041.png)\\n\\n![image-20201013103324150](images/image-20201013103324150.png)\\n\\n![image-20201013103331216](images/image-20201013103331216.png)\\n\\n\\n\\n/README.md\\n# Verilog-Testbench\\n\\n## Goal:\\n\\nThis project intends to develop a testbench for the DUT using Icarus Verilog.\\n\\n## About Icarus Verilog:\\n\\n* Icarus Verilog is an open source software written by. It's used to test Verilog modules.\\n\\n* Icarus Verilog is a small, portable, powerful software.\\n\\n## Tools/Technologies:\\n\\n* Icarus Verilog\\n* Git\\n* Vastag\\n* Verilator\\n* Verilator Tools\\n\\n## Structure:\\n\\n### Test/\\n\\nThe ""Test"" folder contains all the test cases.\\n\\n#### Test1:\\n\\nIn this test case we are testing the functionality of the module in a simple circuit, with a single input and two output.\\n\\n#### Test2:\\n\\nIn this test case we are testing the functionality of the module in a simple circuit, with two input and two output.\\n\\n#### Test3:\\n\\nIn this test case we are testing the functionality of the module in an example with a register, with three inputs and one output.\\n\\n#### Test4:\\n\\nIn this test case we are testing the functionality of the module in an example with a register, with three inputs and two outputs.\\n\\n#### Test5:\\n\\nIn this test case we are testing the functionality of the module in an example with a mux, with two inputs and one output.\\n\\n#### Test6:\\n\\nIn this test case we are testing the functionality of the module in an example with a mux, with two inputs and two outputs.\\n\\n#### Test7:\\n\\nIn this test case we are testing the functionality of the module in an example with a mux, with three inputs and one output.\\n\\n#### Test8:\\n\\nIn this test case we are testing the functionality of the module in an example with a mux, with three inputs and two outputs.\\n\\n#### Test9:\\n\\nIn this test case we are testing the functionality of the module in an example with two registers, with four inputs and one output.\\n\\n#### Test10:\\n\\nIn this test case we are testing the functionality of the module in an example with two registers, with four inputs and two outputs.\\n\\n## Authors:\\n\\nGroup:\\n\\n| Name            | SRN          |\\n| --------------- | ------------ |\\n|  | 015316       |\\n|    | 015538       |\\n|  | 015560       |\\n|   | 015564       |\\n|    | 015570       |\\n\\n\\n\\n/Test/testcase_9/testcase_9_2/readme.md\\n# Test Case 9_2\\n\\n## Scenario:\\n\\nIn this case we are testing the functionality of the module in an example with two registers, with four inputs and two outputs.\\n\\n\\n\\n## Steps to run the Code:\\n\\n- Open your terminal \\n- Copy and paste the following command:\\n\\n```\\niverilog -o test_input_two.sim test_input_two.v\\n```\\n\\nHere, -o indicates the output file name.\\n\\nNow run the following command:\\n\\n```\\nvvp test_input_two.sim\\n```\\n\\n\\n\\n\\n\\n## Output:\\n\\n![image-20201017111353715](images/image-20201017111353715.png)\\n\\n![image-20201017111400706](images/image-20201017111400706.png)\\n\\n![image-20201017111415578]("
"29","0","FAIL","0","module SchedDelayA (schedDelayA_inst);\\nwire clk;\\nwire rst;\\n\\nreg [7:0] a, b;\\n\\nschedDelayA_inst = @(posedge clk) begin\\nif (rst) a <= 1'b0;\\na <= a + 1;\\nb <= a;\\nend\\nendmodule\\n\\nHow do you think it will change the generated verilog code? What is the impact on the circuit?\\n\\nI am looking for answers that describe how this will change the generated verilog code in this particular case.\\n\\nI have no idea how your compiler will treat it. It's not very likely to matter because it wouldn't add or change any functionality, but it's still wrong.\\n\\n The code I provided was generated by Lime.  Apr 23 '20 at 22:16\\n I am not sure what you are describing, but your schematic is correct. The first register input is just a wire. The second register input does not have a class handle, so it needs to be added and removed the same as a register. The second wire must also be created to be connected to the first register.  Apr 23 '20 at 22:24\\n Also, in your code, the third input is the reset. The class handle is used to define the third input in the verilog module.  Apr 23 '20 at 22:27\\n I am trying to understand what is the difference between the 1st and 3rd registers. What about the 2nd register? Are they the same?  Apr 23 '20 at 22:31\\n I used to think that the 1st and 3rd were the same, but I think they are separate registers.  Apr 23 '20 at 22:36\\n\\nThe problem is that the code you have posted adds a third register, which has no class handle, to the module SchedDelayA. While the code will compile, and the resulting circuit will behave correctly, the code is incorrect. If you run the code through lint, the compiler will complain.\\n\\nThe code you have posted in the question is synthesized as follows, where:\\n\\n the first wire is a wire,\\n the second wire is a reg[7:0]\\n the third wire is a wire,\\n\\nThis is not a problem if the compiler creates the additional 3rd wire, but the code in the question is not synthesizable.\\n\\nMy understanding is that this is a bug in Lime, but I have no idea how it would handle this.\\n\\n The generated code for the schematic shows that the second wire is not a reg[7:0] but a wire.  Apr 23 '20 at 22:19"
"29","1","FAIL","0","module SchedDelayA;\\nclass SchedDelayA; endclass\\nclass SchedDelayA;\\nreg a, b;\\ninitial\\nbegin\\nend\\nalways @(b) a = b;\\nalways @(a) b <= a;\\nendclass\\n### Design and Analysis:\\nBoth the above designs are compiled without any errors.\\n/Lab-05/readme.md\\n## Lab-05\\n### Question 1\\nModify the module for the second state of the FSM. \\n### Answer:\\nThe new module for the second state of the FSM is provided in `Sched_DelayA.v`.\\n### Question 2\\nModify the code to allow the inputs to go through the FSM.\\n### Answer:\\nThe new code is provided in `Sched_DelayA_Mod.v`.\\n### Question 3\\nTest the code with the following inputs:\\n### Answer\\n1. `Sched_DelayA_Mod.v`\\n    - 50ns\\n        - In: `0`\\n        - Out: `0`\\n    - 100ns\\n        - In: `0`\\n        - Out: `1`\\n    - 150ns\\n        - In: `1`\\n        - Out: `1`\\n    - 200ns\\n        - In: `1`\\n        - Out: `0`\\n    - 250ns\\n        - In: `0`\\n        - Out: `1`\\n    - 300ns\\n        - In: `1`\\n        - Out: `0`\\n    - 350ns\\n        - In: `1`\\n        - Out: `0`\\n2. `Sched_DelayA.v`\\n    - 50ns\\n        - In: `0`\\n        - Out: `0`\\n    - 100ns\\n        - In: `0`\\n        - Out: `1`\\n    - 150ns\\n        - In: `1`\\n        - Out: `1`\\n    - 200ns\\n        - In: `1`\\n        - Out: `0`\\n    - 250ns\\n        - In: `0`\\n        - Out: `0`\\n    - 300ns\\n        - In: `0`\\n        - Out: `0`\\n    - 350ns\\n        - In: `0`\\n        - Out: `0`\\n### Question 4\\nModify the code to allow the inputs to go through the FSM.\\n### Answer:\\nThe new code is provided in `Sched_Delay_B.v`.\\n### Question 5\\nTest the code with the following inputs:\\n### Answer\\n1. `Sched_Delay_B.v`\\n    - 50ns\\n        - In: `0`\\n        - Out: `0`\\n    - 100ns\\n        - In: `0`\\n        - Out: `1`\\n    - 150ns\\n        - In: `1`\\n        - Out: `1`\\n    - 200ns\\n        - In: `1`\\n        - Out: `0`\\n    - 250ns\\n        - In: `0`\\n        - Out: `1`\\n    - 300ns\\n        - In: `1`\\n        - Out: `0`\\n    - 350ns\\n        - In: `1`\\n        - Out: `0`\\n2. `Sched_DelayA_Mod.v`\\n    - 50ns\\n        - In: `0`\\n        - Out: `0`\\n    - 100ns\\n        - In: `0`\\n        - Out: `1`\\n    - 150ns\\n        - In: `1`\\n        - Out: `1`\\n    - 200ns\\n        - In: `1`\\n        - Out: `0`\\n    - 250ns\\n        - In: `0`\\n        - Out: `1`\\n    - 300ns\\n        - In: `1`\\n        - Out: `0`\\n    - 350ns\\n        - In: `1`\\n        - Out: `0`\\n3. `Sched_DelayA.v`\\n    - 50ns\\n        - In: `0`\\n        - Out: `0`\\n    - 100ns\\n        - In: `0`\\n        - Out: `1`\\n    - 150ns\\n        - In: `1`\\n        - Out: `1`\\n    - 200ns\\n        - In: `1`\\n        - Out: `0`\\n    - 250ns\\n        - In: `0`\\n        - Out: `1`\\n    - 300ns\\n        - In: `1`\\n        - Out: `0`\\n    - 350ns\\n        - In: `1`\\n        - Out: `0`\\n### Question 6\\nDo the code in question 4 have the same behavior as the code in question 3?\\n### Answer\\nSince, `Sched_DelayA_Mod` behaves differently while passing 1 as an input, we can conclude that the code in question 4 do not have the same behavior as the code in question 3.\\n/Lab-07/readme.md\\n### Lab 07\\n### Question 1\\nMake sure you understand the code for `Sched_DelayA.v`. \\n### Answer\\nYes, the code for the module `Sched_DelayA.v` is correct as a result of compilation.\\n### Question 2\\nMake sure you understand the code for `Sched_DelayB.v`. \\n### Answer\\nYes, the code for the module `Sched_DelayB.v` is correct as a result of compilation.\\n### Question 3\\nMake sure you understand the code for the module `Sched_Delay_State_Machine.v`.\\n### Answer\\nYes, the code for the module `Sched_Delay_State_Machine.v` is correct as a result of compilation.\\n### Question 4\\nMake sure you understand how the state machine works.\\n### Answer\\n1. The state machine has a `start` state, a `ready` state, an `input` state and an `output` state.\\n2. On the `start` state, the module waits for a valid input to pass to the `input` state.\\n3. On the `input` state, the module outputs a valid input, and the module goes back to the `ready` state.\\n4. On the `ready` state, the module waits for a valid input to pass to the `input` state.\\n5. On the `output` state, the module outputs the valid input and the module goes back to the `ready` state.\\n### Question 5\\nWrite down the behavior of the Sche_Delay_State_Machine in the `input` state.\\n### Answer\\n1. The state machine goes to the `input` state.\\n2. It waits for a valid input.\\n3. On the first valid input, it outputs the input and goes back to the `ready` state.\\n4. On the second valid input, it outputs the input and goes back to the `ready` state.\\n5. On the third valid input, it outputs the input and goes back to the `ready` state.\\n6. On the fourth valid input, it outputs the input and goes back to the `ready` state.\\n7. On the fifth valid input, it outputs the input and goes back to the `ready` state.\\n8. The state machine goes back to `ready` state on the sixth valid input.\\n9. On the seventh valid input, the state machine outputs the input and goes back to the `ready` state.\\n10. On the eighth valid input, the state machine outputs the input and goes back to the `ready` state.\\n11. On the ninth valid input, the state machine outputs the input and goes back to the `ready` state.\\n12. On the tenth valid input, the state machine outputs the input and goes back to the `ready` state.\\n13. On the eleventh valid input, the state machine outputs the input and goes back to the `ready` state.\\n14. On the twelfth valid input, the state machine outputs the input and goes back to the `ready` state.\\n15. On the thirteenth valid input, the state machine outputs the input and goes back to the `ready` state.\\n16. On the fourteenth valid input, the state machine outputs the input and goes back to the `ready` state.\\n17. On the fifteenth valid input, the state machine outputs the input and goes back to the `ready` state.\\n18. On the sixteenth valid input, the state machine outputs the input and goes back to the `ready` state.\\n19. On the seventeenth valid input, the state machine outputs the input and goes back to the `ready` state.\\n20. On the eighteenth valid input, the state machine outputs the input and goes back to the `ready` state.\\n21. On the nineteenth valid input, the state machine outputs the input and goes back to the `ready` state.\\n22. On the twentieth valid input, the state machine outputs the input and goes back to the `ready` state.\\n23."
"29","2","FAIL","0","module SchedDelayA;\\nreg a, b;\\ninitial\\nbegin\\nend\\nalways @(b) a = b;\\nalways @(a) b <= a;\\nendmodule\\n### Expected Results:\\nNo change.\\n### Fixed Results:\\nNo change.\\n### Changes:\\n- Add tests for class-based associative accesses\\n- Fix bug in the module that caused the issue\\n- Add test cases\\n- Update documentation\\n\\n## Issue 1951:\\n### Base Verilog Code:\\nmodule SchedDelayA;\\nreg a, b;\\ninitial\\nbegin\\nend\\nalways @(b) a = b;\\nalways @(a) b <= a;\\nendmodule\\n### Variation Instruction:\\nReplace one of the inputs with a class handle and use inside"
"29","3","FAIL","0","module Sched"
"29","4","FAIL","0","module SchedDelayB;\\nreg a, b;\\ninitial\\nbegin\\nend\\nalways @(b) a = b;\\nalways @(a) b <= a;\\nendmodule\\n### New Verilog Code:\\nmodule SchedDelayC;\\nreg a, b;\\nreg [3:0] a_addr = 2'b00;\\nreg [3:0] b_addr = 2'b00;\\ninitial\\nbegin\\na_addr <= {a_addr[0:3], 4'b0000};\\nb_addr <= {b_addr[0:3], 4'b0000};\\nend\\nalways @(b) a = b;\\nalways @(a) b <= a;\\nendmodule\\n/2008/s0105.c\\n/*\\n * Copyright 2008 The Khronos Group Inc.\\n */\\n\\n/*\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n/**\\n * \\file\\n * \\brief XEON Phi: Test of the C++ language.\\n *\\n * We have to compile this program using the compiler that we use for\\n * the other tests. This is done by defining the XEON_PHI_COMPILEPREPROCESSOR\\n * macro.\\n */\\n#ifndef XEON_PHI_COMPILEPREPROCESSOR\\n#define XEON_PHI_COMPILEPREPROCESSOR\\n#endif\\n#include ""s0000.c""\\n\\n#include ""xstypes.h""\\n#include ""xstypesprivate.hpp""\\n\\n#include <vector>\\n\\nvoid testCPlusPlusStandardVector()\\n{\\n	std::vector<int> vs;\\n	for (int i = 0; i < 10; i++) {\\n		vs.push_back(i);\\n	}\\n	std::for_each(vs.begin(), vs.end(), [](int i) { std::cout << i << std::endl; });\\n}\\n\\nvoid testCPlusPlusString()\\n{\\n	std::string s(""foo"");\\n	std::cout << s << std::endl;\\n}\\n\\nvoid testCPlusPlusIterator()\\n{\\n	std::vector<int> vs;\\n	for (int i = 0; i < 10; i++) {\\n		vs.push_back(i);\\n	}\\n	std::for_each(vs.begin(), vs.end(), [](int i) { std::cout << i << std::endl; });\\n}\\n\\nvoid testCPlusPlusArray()\\n{\\n	int a[] = {1, 2, 3, 4, 5};\\n	std::cout << ""Array:"" << std::endl;\\n	for (int i = 0; i < 5; i++) {\\n		std::cout << a[i] << std::endl;\\n	}\\n}\\n\\nvoid testCPlusPlusInitializerList()\\n{\\n	std::vector<int> v = {1, 2, 3, 4, 5};\\n	std::for_each(v.begin(), v.end(), [](int i) { std::cout << i << std::endl; });\\n}\\n\\nstruct A {\\n	int data;\\n	A(int i) : data(i) {};\\n	static int counter;\\n	void printData() {\\n		std::cout << data << std::endl;\\n	}\\n};\\n\\nint A::counter = 0;\\n\\nvoid testCPlusPlusStatic()\\n{\\n	std::cout << A::counter << std::endl;\\n	A a(1);\\n	a.printData();\\n	A::counter = 5;\\n	std::cout << A::counter << std::endl;\\n	a.printData();\\n	std::cout << a.data << std::endl;\\n	std::cout << a.data << std::endl;\\n}\\n\\nvoid testCPlusPlusException()\\n{\\n	try {\\n		throw std::string(""foo"");\\n		std::cout << __LINE__ << std::endl;\\n		throw 1;\\n		std::cout << __LINE__ << std::endl;\\n	}\\n	catch(std::string s) {\\n		std::cout << ""std::string"" << std::endl;\\n	}\\n	catch(int i) {\\n		std::cout << ""int"" << std::endl;\\n	}\\n	catch(...) {\\n		std::cout << ""other"" << std::endl;\\n	}\\n}\\n\\nstruct B {\\n	virtual void print() = 0;\\n};\\n\\nstruct C : A, B {\\n	void print() override {\\n		std::cout << ""C"" << std::endl;\\n	}\\n};\\n\\nvoid testCPlusPlusPolymorphism()\\n{\\n	A a(0);\\n	a.printData();\\n	B *b = new A;\\n	b->print();\\n	b->printData();\\n	C *c = new C;\\n	c->print();\\n	c->printData();\\n}\\n\\nclass D {\\n	int data;\\npublic:\\n	D() : data(0) {}\\n	int getData() { return data; }\\n	void setData(int i) { data = i; }\\n};\\n\\nclass E : public D {\\n	static D d;\\n	static int c;\\npublic:\\n	E() : D() { d.setData(c++); }\\n	int getData() override { return D::getData(); }\\n};\\n\\nD E::d;\\nint E::c = 0;\\n\\nvoid testCPlusPlusVirtual()\\n{\\n	std::vector<E> v;\\n	for (int i = 0; i < 10; i++) {\\n		E e;\\n		v.push_back(e);\\n	}\\n	for (int i = 0; i < 10; i++) {\\n		std::cout << v[i].getData() << std::endl;\\n	}\\n}\\n\\nvoid testCPlusPlusNamespace()\\n{\\n	using namespace std;\\n	vector<int> vs;\\n	for (int i = 0; i < 10; i++) {\\n		vs.push_back(i);\\n	}\\n	for_each(vs.begin(), vs.end(), [](int i) { std::cout << i << std::endl; });\\n}\\n\\nvoid testCPlusPlusOperator()\\n{\\n	D& d = E::d;\\n	d.getData();\\n}\\n\\n#pragma pack(1)\\ntypedef struct\\n{\\n	int i;\\n	float f;\\n	char c;\\n} sDataType;\\n#pragma pack()\\n\\nvoid testCPlusPlusStructure()\\n{\\n	std::vector<sDataType> v;\\n	for (int i = 0; i < 10; i++) {\\n		sDataType s;\\n		s.i = i;\\n		s.f = i / 2;\\n		s.c = 'f';\\n		s.c = 'f';\\n		v.push_back(s);\\n	}\\n	for (int i = 0; i < 10; i++) {\\n		std::cout << v[i].i << "" "" << v[i].f << "" "" << v[i].c << std::endl;\\n	}\\n}\\n\\nvoid testCPlusPlusNewDelete()\\n{\\n	std::vector<D *> v;\\n	for (int i = 0; i < 10; i++) {\\n		v.push_back(new D);\\n	}\\n	for (int i = 0; i < 10; i++) {\\n		std::cout << v[i]->getData() << std::endl;\\n		delete v[i];\\n	}\\n}\\n\\nvoid testCPlusPlusAuto()\\n{\\n	for (int i = 0; i < 10; i++) {\\n		auto int_ptr = new int(i);\\n		std::cout << *int_ptr << std::endl;\\n		delete int_ptr;\\n	}\\n}\\n\\nvoid testCPlusPlusConst()\\n{\\n	const int c = 0;\\n	std::cout << ""c: "" << c << std::endl;\\n	for (int i = 0; i < 10; i++) {\\n		auto int_ptr = new int(i);\\n		std::cout << *int_ptr << std::endl;\\n		delete int_ptr;\\n	}\\n}\\n\\nvoid testCPlusPlusEnum()\\n{\\n	enum class COLOR { red, green, blue };\\n	std::cout << ""red: "" << (int) COLOR::red << std::endl;\\n	std::cout << ""green: "" << (int) COLOR::green << std::endl;\\n	std::cout << ""blue: "" << (int) COLOR::blue << std::endl;\\n}\\n\\nvoid testCPlusPlusClass()\\n{"
"30","0","FAIL","0","module netdelay1(x,y);\\ninput x;\\noutput [31:0] y; // output y as a unit width packed structure\\nwire #(2,1) [31:0] nn; // Declare wire 'nn' with rise=2, fall=1 delay\\nnot (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)\\nassign y=nn; // Assign 'nn' to 'y' (direct assignment)\\nendmodule\\n`\\n\\n## Test Results\\n\\n### Test Pass Result\\n\\nAll 6 Test Cases are Passed\\n\\n### Test Case Result on Target Device\\n\\n![](./images/test-result.png)\\n\\n## Performance\\n\\n### Target Device\\n\\n#### Device Information\\n\\nVerilog Model:\\n\\n- Intel(R) FPGA Emulator for Windows with 128KB Cache and 256KB SRAM\\n\\n#### Device Fmax Timing Constraints\\n\\n![](./images/timing-const.png)\\n\\n#### Device Fmax Timing Graph\\n\\n![](./images/timing-graph.png)\\n\\n#### Device Fmax Design Constraints\\n\\nFmax: 25.862001510946146\\n\\n![](./images/design-const.png)\\n\\n#### Device Fmax Design Graph\\n\\n![](./images/design-graph.png)\\n\\n### Compared with Other Solutions\\n\\nAll solutions can meet the constraints and design goals. However, we can observe some design details of the proposed design.\\n\\n-  The proposed solution only needs 12 LUTs to realize the design of the network delay pipeline.\\n-  The proposed solution with 32 bit output bit width can achieve good timing while consuming only 16 LUTs.\\n-  The proposed solution with 32 bit output bit width can achieve good timing and design with 16 LUTs.\\n\\n## Conclusion\\n\\nThrough this project, we have successfully constructed a network delay pipeline with Verilog and run the simulation on Intel FPGA Emulator. We have also analyzed the design details and compared with the existing design solutions. In this way, we can have more insights and knowledge on the design of the network delay pipeline on FPGA. We can also have more design inspiration.\\n\\n## Reference\\n\\n[Verilog HDL - Not Gate - W3SCHOOLS](https://www.w3schools.com/verilog/verilog_not.asp)\\n\\n[How many LUTs does a NOT gate require?](https://electronics.stackexchange.com/questions/85795/how-many-luts-does-a-not-gate-require)\\n\\n[HDL Design: A practical guide for beginner](https://ieeexplore.ieee.org/document/4012834)\\n\\n[Verilog Tutorial](https://www.edaplayground.com/tutorials/verilog/verilog-tutorial-series-verilog-basics)\\n\\n[Verilog Timing Constraints](https://www.allaboutcircuits.com/technical-articles/timing-constraints-in-verilog/)/Vivado/project/project.runs/impl_1/.vivado.mk\\n# Generated by Vivado on Thu Aug 19 14:37:14 CST 2021\\n# User: admin\\n# Date: 2021-08-19_14:37:27\\n# Flow: Sink\\n# Package: Vivado 2019.2\\n# IP Paint Size: 1080\\n# Command: C:/Program Files (x86)/Xilinx/Vivado/2019.2/bin/vivado -nojournal -nolog -mode batch -source..\\..\\netdelay1.tcl -tclargs\\n\\n# Exit"
"30","1","FAIL","0","module netdelay4(x,y,z);\\ninput x;\\noutput y,z;\\nwire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay\\nwire #(4) op; // Declare wire 'op' with rise=4 delay\\nwire #(4,2,4,1) op2;\\nnot (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)\\nnot #(7) (op,nn); // Assign NOT(nn) to 'op' (takes effect after rise/fall delay)\\nnot #(5) (op2,op); // Assign NOT(op) to 'op2' (takes effect after rise/fall delay)\\nassign y=op[1:0]; // Assign 'op' to 'y' (direct assignment)\\nassign z=op2; // Assign 'op2' to 'z' (direct assignment)\\nendmodule\\n\\n## Test Programs\\n\\n### netdelay1\\n\\nmodule netdelay1(x,y);\\ninput x;\\noutput y;\\nwire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay\\nnot (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)\\nassign y=nn; // Assign 'nn' to 'y' (direct assignment)\\nendmodule\\n\\n### netdelay2\\n\\nmodule netdelay2(x,y,z);\\ninput x;\\noutput y,z;\\nwire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay\\nwire #(4) op; // Declare wire 'op' with rise=4 delay\\nwire #(4,2,4,1) op2;\\nnot (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)\\nnot #(7) (op,nn); // Assign NOT(nn) to 'op' (takes effect after rise/fall delay)\\nnot #(5) (op2,op); // Assign NOT(op) to 'op2' (takes effect after rise/fall delay)\\nassign y=op; // Assign 'op' to 'y' (direct assignment)\\nassign z=op2; // Assign 'op2' to 'z' (direct assignment)\\nendmodule\\n\\n### netdelay3\\n\\nmodule netdelay3(x,y,z);\\ninput x;\\noutput y,z;\\nwire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay\\nwire #(4) op; // Declare wire 'op' with rise=4 delay\\nwire #(4,2,4,1) op2;\\nnot (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)\\nnot #(7) (op,nn); // Assign NOT(nn) to 'op' (takes effect after rise/fall delay)\\nnot #(5) (op2,op); // Assign NOT(op) to 'op2' (takes effect after rise/fall delay)\\nassign y=op[1]; // Assign 'op' to 'y' (direct assignment)\\nassign z=op2; // Assign 'op2' to 'z' (direct assignment)\\nendmodule\\n\\n### netdelay4\\n\\nmodule netdelay4(x,y,z);\\ninput x;\\noutput y,z;\\nwire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay\\nwire #(4) op; // Declare wire 'op' with rise=4 delay\\nwire #(4,2,4,1) op2;\\nnot (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)\\nnot #(7) (op,nn); // Assign NOT(nn) to 'op' (takes effect after rise/fall delay)\\nnot #(5) (op2,op); // Assign NOT(op) to 'op2' (takes effect after rise/fall delay)\\nassign y=op[1:0]; // Assign 'op' to 'y' (direct assignment)\\nassign z=op2; // Assign 'op2' to 'z' (direct assignment)\\nendmodule\\n\\n## Test Result\\n\\n![netdelay1.png](./netdelay1.png?raw=true)\\n\\n![netdelay2.png](./netdelay2.png?raw=true)\\n\\n![netdelay3.png](./netdelay3.png?raw=true)\\n\\n![netdelay4.png](./netdelay4.png?raw=true)\\n/test_bench/netdelay/netdelay.h\\n#include <verilated.h>\\n#define ILP 0\\n#define LP 1\\n#define HP 2\\n/test_bench/delays/netdelay_1.cpp\\n#include <iostream>\\n#include <verilated.h>\\n#include ""netdelay.h""\\nusing namespace std;\\n\\nint main(int argc, char **argv)\\n{\\n	Verilated::commandArgs(argc, argv); // Add cmdline args to sim\\n\\n	// instantiate module\\n	netdelay m;\\n\\n	// initialize input and output ports\\n	m->x = 0b1;\\n	m->clk = 0;\\n	m->rst = 0;\\n	m->op = 0;\\n	m->en = 0;\\n	cout << ""x\\t""\\n		 << ""op\\t""\\n		 << ""en\\t"" << endl;\\n\\n	// time loop\\n	for (int i = 0; i < 1; ++i)\\n	{\\n\\n		m->clk = 0;\\n		m->eval();\\n		m->clk = 1;\\n		m->eval();\\n		cout << m->x << ""\\t""\\n			 << m->op << ""\\t""\\n			 << m->en << endl;\\n\\n		m->rst = 1;\\n		m->eval();\\n		m->rst = 0;\\n		m->eval();\\n	}\\n\\n	return 0;\\n}\\n/test_bench/logic/logic_2.cpp\\n#include <iostream>\\n#include <verilated.h>\\n#include ""logic.h""\\nusing namespace std;\\n\\nint main(int argc, char **argv)\\n{\\n	Verilated::commandArgs(argc, argv); // Add cmdline args to sim\\n\\n	// instantiate module\\n	logic m;\\n\\n	// initialize input and output ports\\n	m->x = 0b1;\\n	m->op = 0;\\n	m->en = 0;\\n	m->clk = 0;\\n	m->rst = 0;\\n\\n	cout << ""x\\t""\\n		 << ""op\\t"""
"30","2","FAIL","0","module array(x,y);\\ninput x;\\ninput y;\\noutput bit_out;\\n\\nassign bit_out={""x"", ""y""};\\nendmodule\\n### Testbench Code:\\nmodule tb_array;\\n\\nreg 	x; 	// input\\nreg 	y; 	// input\\nwire 	bit_out; 	// output\\n\\narray u1(x,y);\\n\\ninitial begin\\nx = 0;\\ny = 0;\\n#10 $display(""x: %d, y: %d, bit_out: %d"", x, y, bit_out);\\nx = 1;\\ny = 0;\\n#10 $display(""x: %d, y: %d, bit_out: %d"", x, y, bit_out);\\nx = 0;\\ny = 1;\\n#10 $display(""x: %d, y: %d, bit_out: %d"", x, y, bit_out);\\nx = 1;\\ny = 1;\\n#10 $display(""x: %d, y: %d, bit_out: %d"", x, y, bit_out);\\nend\\nendmodule\\n\\n### Expected Results:\\nx: 0, y: 0, bit_out: 00\\nx: 1, y: 0, bit_out: 01\\nx: 0, y: 1, bit_out: 10\\nx: 1, y: 1, bit_out: 11\\n### Actual Results:\\nx: 0, y: 0, bit_out: 11\\nx: 1, y: 0, bit_out: 10\\nx: 0, y: 1, bit_out: 11\\nx: 1, y: 1, bit_out: 10#include <stdio.h>\\n#include <unistd.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <errno.h>\\n#include <fcntl.h>\\n#include <sys/types.h>\\n#include <sys/select.h>\\n#include <sys/ioctl.h>\\n#include <linux/input.h>\\n#include <linux/hidraw.h>\\n\\nint main(int argc, char **argv)\\n{\\n  int fd, rd_num, i, j;\\n  struct hidraw_report_descriptor rpt_desc;\\n  struct hidraw_devinfo info;\\n  struct hidraw_report_ext_output expo;\\n  unsigned char w_data[500];\\n  unsigned char r_data[500];\\n  unsigned char *ptr;\\n  unsigned char *ptr2;\\n  unsigned char *ptr3;\\n  unsigned char *ptr4;\\n  unsigned char *ptr5;\\n  unsigned char *ptr6;\\n  unsigned char *ptr7;\\n  unsigned char *ptr8;\\n  unsigned char *ptr9;\\n  unsigned char *ptr10;\\n  unsigned char *ptr11;\\n  unsigned char *ptr12;\\n  unsigned char *ptr13;\\n  unsigned char *ptr14;\\n  unsigned char *ptr15;\\n  unsigned char *ptr16;\\n  unsigned char *ptr17;\\n  unsigned char *ptr18;\\n  unsigned char *ptr19;\\n  unsigned char *ptr20;\\n  unsigned char *ptr21;\\n\\n  if(argc < 2)\\n  {\\n    printf(""Usage:./hid_test input\\n"");\\n    exit(0);\\n  }\\n\\n  if (argc == 3)\\n  {\\n    if (atoi(argv[2]) < 1)\\n    {\\n      printf(""Usage:./hid_test input [speed]\\n"");\\n      printf(""Use 300 for 300bps, 1200 for 1200 bps, 2400 for 2400 bps...\\n"");\\n      exit(0);\\n    }\\n  }\\n\\n  if((fd = open(argv[1], O_RDWR)) < 0)\\n  {\\n    printf(""Can't open USB device!\\n"");\\n    return -1;\\n  }\\n\\n  if((ioctl(fd, HIDIOCGRDESCSIZE, &rpt_desc.size)) < 0)\\n  {\\n    printf(""Can't get HID report descriptor length!\\n"");\\n    return -1;\\n  }\\n\\n  if((ioctl(fd, HIDIOCGRDESC, &rpt_desc)) < 0)\\n  {\\n    printf(""Can't get HID report descriptor!\\n"");\\n    return -1;\\n  }\\n\\n  printf(""HID report descriptor length: %d\\n"", rpt_desc.size);\\n\\n  if((ioctl(fd, HIDIOCGRAWINFO, &info)) < 0)\\n  {\\n    printf(""Can't get HID report descriptor!\\n"");\\n    return -1;\\n  }\\n\\n  printf(""HID device name: %s\\n"", info.product"
"30","3","FAIL","0","module netdelay1(x,y);\\ninput x;\\noutput y;\\nwire #(2,1) nn[31:0]; // Declare wire 'nn' as a 32 bit wide packed structure.\\nnot (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)\\nassign y=nn[31:0]; // Assign 'nn' to 'y' (direct assignment)\\nendmodule\\n#include <stdio.h>\\n\\n#include ""rtl_test.h""\\n\\nint main(int argc, char *argv[])\\n{\\n	int rv = 0;\\n\\n	rv = test_netdelay1();\\n	printf(""Netdelay1 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay2();\\n	printf(""Netdelay2 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay3();\\n	printf(""Netdelay3 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay4();\\n	printf(""Netdelay4 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay5();\\n	printf(""Netdelay5 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay6();\\n	printf(""Netdelay6 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay7();\\n	printf(""Netdelay7 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay8();\\n	printf(""Netdelay8 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay9();\\n	printf(""Netdelay9 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay10();\\n	printf(""Netdelay10 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay11();\\n	printf(""Netdelay11 test result = %d\\n"", rv);\\n\\n	rv = test_netdelay12();\\n	printf(""Netdelay12 test result = %d\\n"", rv);\\n\\n	return rv;\\n}\\n#include <stdint.h>\\n\\n#include ""rtl_test.h""\\n\\nstatic void *alloc_mem(size_t size)\\n{\\n	void *ret = malloc(size);\\n	if (ret == NULL) {\\n		fprintf(stderr, ""Memory allocation failed!\\n"");\\n		exit(1);\\n	}\\n	return ret;\\n}\\n\\nstatic void free_mem(void *ptr, size_t size)\\n{\\n	free(ptr);\\n}\\n\\nstatic void delay_unit_test(netdelay_t *rtl)\\n{\\n	int rv;\\n	int result;\\n	int expected_result;\\n	int i;\\n	uint8_t input[32];\\n	uint8_t output[32];\\n\\n	rv = netdelay_init(rtl, 32);\\n	if (rv!= 0) {\\n		fprintf(stderr, ""netdelay_init: %d\\n"", rv);\\n		exit(1);\\n	}\\n\\n	for (i = 0; i < 32; i++) {\\n		input[i] = 1;\\n	}\\n\\n	rv = netdelay_set_value(rtl, (uint8_t *)input);\\n	if (rv!= 0) {\\n		fprintf(stderr, ""netdelay_set_value: %d\\n"", rv);\\n		exit(1);\\n	}\\n\\n	for (i = 0; i < 32; i++) {\\n		expected_result = (i < 31)? 0 : 1;\\n		rv = netdelay_step(rtl);\\n		if (rv!= 0) {\\n			fprintf(stderr, ""netdelay_step: %d\\n"", rv);\\n			exit(1);\\n		}\\n		rv = netdelay_get_value(rtl, (uint8_t *)output);\\n		if (rv!= 0) {\\n			fprintf(stderr, ""netdelay_get_value: %d\\n"", rv);\\n			exit(1);\\n		}\\n		result = output[31];\\n		if (result!= expected_result) {\\n			fprintf(stderr, ""Data: 0x%x (expected 0x%x)\\n"",\\n				result, expected_result);\\n			exit(1);\\n		}\\n	}\\n}\\n\\nstatic void delay_unit_test_2(netdelay_t *rtl)\\n{\\n	int rv;\\n	int result;\\n	int expected_result;\\n	int i;\\n	uint8_t input[32];\\n	uint8_t output[32];\\n\\n	rv = netdelay_init(rtl, 32);\\n	if (rv!= 0) {\\n		fprintf(stderr, ""netdelay_init: %d\\n"", rv);\\n		exit(1);\\n	}\\n\\n	for (i = 0; i < 32; i++) {\\n		input[i] = 1;\\n	}\\n\\n	rv = netdelay_set_value(rtl, (uint8_t *)input);\\n	if (rv!= 0) {\\n		fprintf(stderr, ""netdelay_set_value: %d\\n"", rv);\\n		exit(1);\\n	}\\n\\n	for (i = 0; i < 32; i++) {\\n		expected_result = (i < 30)? 0 : 1;\\n		rv = netdelay_step(rtl);\\n		if (rv!= 0) {\\n			fprintf(stderr, ""netdelay_step: %d\\n"", rv);\\n			exit(1);\\n		}\\n		rv = netdelay_get_value(rtl, (uint8_t *)output);\\n		if (rv!= 0) {\\n			fprintf(stderr, ""netdelay_get_value: %d\\n"", rv);\\n			exit(1);\\n		}\\n		result = output[31];\\n		if (result!= expected_result) {\\n			fprintf(stderr, ""Data: 0x%x (expected 0x%x)\\n"",\\n				result, expected_result);\\n			exit(1);\\n		}\\n	}\\n}\\n\\nstatic void delay_unit_test_3(netdelay_t *rtl)\\n{\\n	int rv;\\n	int result;\\n	int expected_result;\\n	int i;\\n	uint8_t input[32];\\n	uint8_t output[32];\\n\\n	rv = netdelay_init(rtl, 32);\\n	if (rv!= 0) {\\n		fprintf(stderr, ""netdelay_init: %d\\n"", rv);\\n		exit(1);\\n	}\\n\\n	for (i = 0; i < 32; i++) {\\n		input[i] = 1;\\n	}\\n\\n	rv = netdelay_set_value(rtl, (uint8_t *)input);\\n	if (rv!= 0) {\\n		fprintf(stderr, ""netdelay_set_value: %d\\n"", rv);\\n		exit(1);\\n	}\\n\\n	for (i = 0; i < 32; i++) {\\n		expected_result = (i < 29)? 0 : 1;\\n		rv = netdelay_step(rtl);\\n		if (rv!= 0) {\\n			fprintf(stderr, ""netdelay_step: %d\\n"", rv);\\n			exit(1);\\n		}\\n		rv = netdelay_get_value(rtl, (uint8_t *)output);\\n		if (rv!= 0) {\\n			fprintf(stderr, ""netdelay_get_value: %d\\n"", rv);\\n			exit(1);\\n		}\\n		result = output[31];\\n		if (result!= expected_result) {\\n			fprintf(stderr, ""Data: 0x%x (expected 0x%x)\\n"",\\n				result, expected_result);\\n			exit(1);\\n		}\\n	}\\n}\\n\\nstatic void delay_unit_test_4(netdelay_t *rtl)\\n{\\n	int rv;\\n	int result;\\n	int expected_result;\\n	int i;\\n	uint8_t input[32];\\n	uint8_t output[32];\\n\\n	rv = netdelay_init(rtl, 32);\\n	if (rv!= 0) {\\n		fprintf(stderr, ""netdelay_init: %d\\n"", rv);\\n		exit(1);\\n	}\\n\\n	for (i = 0; i < 32; i++) {\\n		input[i] = 1;\\n	}\\n\\n	rv = netdelay_set_value(rtl, (uint8_t *)input);\\n	if (rv!= 0) {\\n		fprintf(stderr,"
"30","4","FAIL","0","module netdelay(x, y);\\ninput  bit [1:0] x;\\noutput reg signed [1:0] y;\\nreg    a, b;\\nalways @ (posedge clk) begin\\nx <= ~x;\\nend\\nendmodule\\n### Result:\\n![Result_2](https://github.com/D0D4L0G/Verilog_Examples/blob/main/Images/Result_2.PNG)"
"31","0","FAIL","0","module func1(x1, x2, x3, f);\\ninput x1, x2, x3"
"31","1","FAIL","0","module func10(x1, x2, x3, f);\\ninput  x1, x2, x3;\\noutput bit [31:0] f;\\nassign f = (x1 | x2 | ~x3) | (~x1 | x2 | x3);\\nendmodule\\n/labs/lab3-verilog-flow-control/README.md\\n# Description:\\nThis lab implements a simple 4-bit adder using the adder instruction and a 4-input NOT gate.\\nThe input from the adder is set to 0 unless an error has occured due to an invalid input \\nor an overflow during addition.\\n# Components Needed:\\n1. 4-input NOT gate\\n2. 4-bit adder\\n# Required Verilog Code:\\n### Base Verilog Code:\\n## Adder Module ##\\nmodule adder (a, b, c, s, t, o);\\ninput [3:0] a, b;\\noutput [3:0] s, t, o;\\n\\nassign s = a + b;\\nassign t = a ^ b;\\nassign o = (s >= 8) | (t >= 8);\\nendmodule\\n## NOT Gate Module ##\\nmodule not_gate (a, b);\\ninput [3:0] a;\\noutput [3:0] b;\\n\\nassign b = ~a;\\nendmodule\\n## Testbench Module ##\\nmodule tb (clk, reset, a, b, s, t, o);\\nreg clk;\\nreg reset;\\nreg [3:0] a;\\nreg [3:0] b;\\nreg [3:0] s;\\nreg [3:0] t;\\nreg [3:0] o;\\n\\nalways#5 clk =!clk;\\n\\ninitial reset = 1'b1;\\n\\nalways @(negedge clk)\\nif (reset) begin\\na <= 3'b0000;\\nb <= 3'b0000;\\ns <= 3'b0000;\\nt <= 3'b0000;\\no <= 1'b0;\\nend\\nelse begin\\na <="
"31","2","FAIL","0","module func1(x1, x2, x3, f);\\ninput x1, x2, x3;\\noutput logic signed f;\\nassign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);\\nendmodule\\n### Execution Result:\\nInput:\\nx1 = 1'b1, x2 = 1'b1, x3 = 1'b1\\nOutput:\\nf = -1\\nInput:\\nx1 = 1'b1, x2 = 1'b1, x3 = 1'b0\\nOutput:\\nf = 3\\nInput:\\nx1 = 1'b0, x2 = 1'b0, x3 = 1'b1\\nOutput:\\nf = 3\\nInput:\\nx1 = 1'b0, x2 = 1'b0, x3 = 1'b0\\nOutput:\\nf = 3\\nLab 09:\\n\\nA.	Why does this test fail? Describe how you verified that this test fails.\\n	Input:\\n		A = {1, 0, 0}\\n		B = {0, 1, 0}\\n		C = {0, 0, 1}\\n		D = {1, 1, 1}\\n	Output:\\n		S = {0, 1, 1}\\n		S = {1, 0, 1}\\n		S = {1, 1, 0}\\n		S = {1, 1, 0}\\n	Expected Output:\\n		S = {1, 0, 1}\\n	Why does this test fail?\\n	Because A and D have the same output.\\n	To verify this test fails:\\n		Check the output for each input for the correct output.\\n		Check the output for each input for the correct output.\\n\\nB.	How is this test implemented in Verilog? Which output is being tested?\\n	This test is implemented in Verilog by checking each output for each input and checking if the output is the correct output.\\n	Output:\\n		S = {1, 1, 1}\\n		S = {1, 0, 1}\\n		S = {1, 1, 0}\\n		S = {1, 1, 0}\\n\\nC.	Using a truth table, write down the boolean expression for this circuit.\\n	S[0] = A[0] XOR A[1] XOR A[2] XOR B[0] XOR B[1] XOR B[2] XOR C[0] XOR C[1] XOR C[2]\\n	S[1] = A[0] XOR A[1] XOR A[2] XOR B[0] XOR B[1] XOR B[2] XOR C[0] XOR C[1] XOR C[2]\\n	S[2] = A[0] XOR A[1] XOR A[2] XOR B[0] XOR B[1] XOR B[2] XOR C[0] XOR C[1] XOR C[2]\\n\\nD.	Given a 2-bit adder and a 3-bit adder, construct a circuit that addes 2-bit vectors and 3-bit vectors.\\n	Circuit 1:\\n		module adder2(a, b, sum, cout);\\n		input a, b, sum;\\n		output cout;\\n		reg cin;\\n		assign sum = (a[0] == b[0])? cin : a[0] + b[0];\\n		assign cout = (a[0] == b[0])? cin : 1'b0;\\n		always @(a, b, sum, cin) begin\\n			cin <= cout;\\n		end\\n	endmodule\\n	Circuit 2:\\n		module adder3(a, b, sum, cout);\\n		input a, b, sum;\\n		output cout;\\n		wire [1:0] sum_2bit;\\n		reg cin;\\n		adder2 adder2_0(a[1:0], b[1:0], sum_2bit, cin);\\n		assign sum[1:0] = sum_2bit;\\n		assign sum[2] = a[2] + b[2];\\n		assign cout = cin;\\n		endmodule\\n	Test File:\\n		module adder3_testbench;\\n		reg [1:0] a;\\n		reg [1:0] b;\\n		wire [2:0] sum;\\n		wire cin;\\n		adder3 adder3(a, b, sum, cin);\\n		initial begin\\n			$display(""Input: a = %d, b = %d"", a, b);\\n			$display(""Output: sum = %d, cin = %d"", sum, cin);\\n			$display(""Expected Output:"");\\n			$display(""		sum = %d"", sum);\\n			$display(""		cin = %d"", cin);\\n		end\\n		initial begin\\n			a = 2'b10;\\n			b = 2'b10;\\n		end\\n		initial begin\\n			a = 2'b01;\\n			b = 2'b10;\\n		end\\n		initial begin\\n			a = 2'b10;\\n			b = 2'b01;\\n		end\\n		initial begin\\n			a = 2'b10;\\n			b = 2'b10;\\n		end\\n		initial begin\\n			a = 2'b11;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b01;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b11;\\n			b = 2'b01;\\n		end\\n		initial begin\\n			a = 2'b01;\\n			b = 2'b01;\\n		end\\n		initial begin\\n			a = 2'b11;\\n			b = 2'b00;\\n		end\\n		initial begin\\n			a = 2'b01;\\n			b = 2'b00;\\n		end\\n		initial begin\\n			a = 2'b11;\\n			b = 2'b10;\\n		end\\n		initial begin\\n			a = 2'b01;\\n			b = 2'b10;\\n		end\\n		initial begin\\n			a = 2'b11;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b00;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b10;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b00;\\n			b = 2'b01;\\n		end\\n		initial begin\\n			a = 2'b00;\\n			b = 2'b10;\\n		end\\n		initial begin\\n			a = 2'b11;\\n			b = 2'b00;\\n		end\\n		initial begin\\n			a = 2'b01;\\n			b = 2'b00;\\n		end\\n		initial begin\\n			a = 2'b10;\\n			b = 2'b00;\\n		end\\n		initial begin\\n			a = 2'b00;\\n			b = 2'b00;\\n		end\\n		initial begin\\n			a = 2'b00;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b10;\\n			b = 2'b00;\\n		end\\n		initial begin\\n			a = 2'b00;\\n			b = 2'b01;\\n		end\\n		initial begin\\n			a = 2'b01;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b11;\\n			b = 2'b10;\\n		end\\n		initial begin\\n			a = 2'b10;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b01;\\n			b = 2'b01;\\n		end\\n		initial begin\\n			a = 2'b11;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b01;\\n			b = 2'b11;\\n		end\\n		initial begin\\n			a = 2'b11;\\n			b"
"31","3","FAIL","0","module func8(x1, x2, x3, f"
"31","4","FAIL","0","module func1(x1, x2, x3, f);\\ninput x1, x2, x3;\\noutput logic signed [2:0] f;\\nassign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);\\nendmodule\\n### Instruction Explaination:\\nSigned Logic Vectors\\nWhen I first saw this question, I thought that there was a difference between a signed\\nand a logic vector. The question does not specify the data type that the output will be,\\nand the design is not specified. In this way, a signed vector is a vector of signed data.\\nTherefore, the question must be a signed vector of size 2.\\n\\n# 1"
"32","0","FAIL","0","module t_Clock_Prog ();\\nwire clock;\\nwire [1:0] Resetn_Type = 1b0;\\nwire Resetn;\\n\\ninitial #100 $finish;\\nClock_Prog M1 (clk, Resetn, Resetn_Type);\\nendmodule\\n\\n### Expected Results:\\n1. Input wire enum assignment to default type is legal.\\n\\n### What to expect?\\n1. Input wire enum assignment to default type is legal.\\n\\n### What did you see?\\n1. Input wire enum assignment to default type passes verification test.\\n\\n##### Summary:\\nEnum assignment to defaulted type\\n##### Analysis:\\nEnum types are defined in the way enum Type_1 : {type_1, type_2}; where type_1 and type_2 are defined as enums themselves. In this case, it is a legal enum assignment of enum to default type.\\n##### Reason:\\nenum assignment is of enum to default type is legal.\\n##### Remedy:\\nNone.\\n### Reference:\\nNone.\\n\\n## T25: enum of non-default type can be assigned to default type\\n### Base Ver"
"32","1","FAIL","0","module t_Clock_Prog ();\\nwire clock;\\n\\ninitial #100 $finish;\\nClock_Prog M1 (clk);\\nendmodule\\n### Expected Behavior:\\nPass\\n### Actual Behavior:\\nFail\\n\\n<sub>Submitted by   via Issue #536</sub>\\n/tests/positive_tests/t_clk_to_out_test/t_clk_to_out.c\\n//*****************************************************************************************************************\\n// Project: SURELOG\\n//\\n// File: t_clk_to_out.c\\n//\\n// Description:\\n// A test case for clock to output\\n//\\n//*****************************************************************************************************************\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#include <vpi_user.h>\\n\\n#include ""common.h""\\n#include ""vlog_utils.h""\\n\\nint main()\\n{\\n  s_vpi_vlog_info info;\\n  info.user_data = NULL;\\n  info.vlog_info_cb = NULL;\\n\\n  s_vpi_vlog_info_level_e level;\\n  level.cb_prefix = ""t_clk_to_out"";\\n  level.max_level = VLOG_MAX_LEVEL;\\n\\n  set_vlog_info(&info, &level);\\n\\n  s_vpi_time time_stamp;\\n  s_vpi_value value;\\n  int32 value_int;\\n\\n  p_vpi_time p_time_stamp;\\n  p_vpi_value p_value;\\n\\n  const char *tb_str = ""t_clk_to_out"";\\n  vpiHandle top_module, tb_handle, clk_handle, out_handle, clk_to_out_handle, clk_to_out_0_handle, clk_to_out_1_handle;\\n\\n  if (argc < 2) {\\n    printf(""Usage: t_clk_to_out <design_file>\\n"");\\n    return -1;\\n  }\\n  if (load_design(argv[1], tb_str, &top_module)!= 0) {\\n    return -1;\\n  }\\n  if (vpi_handle_resolve(&tb_handle, tb_str, vpiSysTfSimHandle)!= -1) {\\n    vpi_get_time(get_vlog_time(&time_stamp, VPI_SIMEVT), p_time_stamp);\\n    printf(""%s:tb: %s (%d)\\n"", get_vlog_time_str(p_time_stamp), vpi_get_value_str(p_time_stamp, vpiStringVal), vpi_get(p_time_stamp, vpiTime, vpiSimTimeVal));\\n  }\\n\\n  if (vpi_handle_resolve(&clk_handle, ""clock"", NULL)!= -1)\\n    vpiHandleToHObj(clk_handle, (p_vpiHandle) &clk_handle);\\n\\n  if (vpi_handle_resolve(&out_handle, ""out"", NULL)!= -1)\\n    vpiHandleToHObj(out_handle, (p_vpiHandle) &out_handle);\\n\\n  if (vpi_handle_resolve(&clk_to_out_handle, ""clk_to_out"", NULL)!= -1)\\n    vpiHandleToHObj(clk_to_out_handle, (p_vpiHandle) &clk_to_out_handle);\\n\\n  if (vpi_handle_resolve(&clk_to_out_0_handle, ""clk_to_out"", 0)!= -1)\\n    vpiHandleToHObj(clk_to_out_0_handle, (p_vpiHandle) &clk_to_out_0_handle);\\n\\n  if (vpi_handle_resolve(&clk_to_out_1_handle, ""clk_to_out"", 1)!= -1)\\n    vpiHandleToHObj(clk_to_out_1_handle, (p_vpiHandle) &clk_to_out_1_handle);\\n\\n  if (vpi_handle_resolve(&clk_to_out_handle, ""clk_to_out"", NULL)!= -1)\\n    vpiHandleToHObj(clk_to_out_handle, (p_vpiHandle) &clk_to_out_handle);\\n\\n  if (vpi_handle_resolve(&clk_to_out_0_handle, ""clk_to_out"", 0)!= -1)\\n    vpiHandleToHObj(clk_to_out_0_handle, (p_vpiHandle) &clk_to_out_0_handle);\\n\\n  if (vpi_handle_resolve(&clk_to_out_1_handle, ""clk_to_out"", 1)!= -1)\\n    vpiHandleToHObj(clk_to_out_1_handle, (p_vpiHandle) &clk_to_out_1_handle);\\n\\n  if (clk_handle) {\\n    if (vpi_get_value(clk_handle, &value)!= 0) {\\n      printf(""Error in getting value of clk\\n"");\\n      return -1;\\n    } else {\\n      value_int = value.value.integer;\\n      printf(""clk = (time %d, value %d)\\n"", vpi_get(clk_handle, vpiSimTimeVal), value_int);\\n    }\\n  }\\n\\n  if (out_handle) {\\n    if (vpi_get_value(out_handle, &value)!= 0) {\\n      printf(""Error in getting value of out\\n"");\\n      return -1;\\n    } else {\\n      value_int = value.value.integer;\\n      printf(""out = (time %d, value %d)\\n"", vpi_get(out_handle, vpiSimTimeVal), value_int);\\n    }\\n  }\\n\\n  if (clk_to_out_handle) {\\n    if (vpi_get_value(clk_to_out_handle, &value)!= 0) {\\n      printf(""Error in getting value of clk_to_out\\n"");\\n      return -1;\\n    } else {\\n      value_int = value.value.integer;\\n      printf(""clk_to_out = (time %d, value %d)\\n"", vpi_get(clk_to_out_handle, vpiSimTimeVal), value_int);\\n    }\\n  }\\n\\n  if (clk_to_out_0_handle) {\\n    if (vpi_get_value(clk_to_out_0_handle, &value)!= 0) {\\n      printf(""Error in getting value of clk_to_out_0\\n"");\\n      return -1(out_handle, &value)!= 0) {\\n      printf(""Error in getting value of out\\n"");\\n      return -1;\\n    } else {\\n      value_int = value.value.integer;\\n      printf(""out = (time %d, value %d)\\n"", vpi_get(out_handle, vpiSimTimeVal), value_int);\\n    }\\n  }\\n\\n  if (clk_to_out_handle) {\\n    if (vpi_get_value(clk_to_out_handle, &value)!= 0) {\\n      printf(""Error in getting value of clk_to_out\\n"");\\n      return -1;\\n    } else {\\n      value_int = value.value.integer;\\n      printf(""clk_to_out = (time %d, value %d)\\n"", vpi_get(clk_to_out_handle, vpiSimTimeVal), value_int);\\n    }\\n  }\\n\\n  if (clk_to_out_0_handle) {\\n    if (vpi_get_value(clk_to_out_0_handle, &value)!= 0) {\\n      printf(""Error in getting value of clk_to_out_0\\n"");\\n      return -1;\\n    } else {\\n      value_int = value.value.integer;\\n      printf(""clk_to_out_0 = (time %d, value %d)\\n"", vpi_get(clk_to_out_0_handle, vpiSimTimeVal), value_int);\\n    }\\n  }\\n\\n  if (clk_to_out_1_handle) {\\n    if (vpi_get_value(clk_to_out_1_handle, &value)!= 0) {\\n      printf(""Error in getting value of clk_to_out_1\\n"");\\n      return -1;\\n    } else {\\n      value_int = value.value.integer;\\n      printf(""clk_to_out_1 = (time %d, value %d)\\n"", vpi_get(clk_to_out_1_handle, vpiSimTimeVal), value_int);\\n    }\\n  }\\n\\n  return 0;\\n}\\n;\\n    } else {\\n      value_int = value.value.integer;\\n      printf(""clk_to_out_0 = (time %d, value %d)\\n"", vpi_get(clk_to_out_0_handle, vpiSimTimeVal), value_int);\\n    }\\n  }\\n\\n  if (clk_to_out_1_handle) {\\n    if (v"
"32","2","FAIL","0","module t_Clock_Prog ();\\nwire clock;\\nwire Resetn;\\n\\ninitial #100 $finish;\\nClock_Prog M1 (clk, Resetn);\\nendmodule\\n1.2.6.2.5.2.5.2.4.2.5.2.5.2.4.3.5.2.5.2.5.2.4.4.2.5.2.5.2.4.3.5.2.5.2.4.3.4.5.2.5.2.4.3.5.2.5.2.4.4.3.5.2.5.2.4.3.5.2.5.2.4.4.4.5.2.5.2.4.3.5.2.5.2.4.4.4.4.5.2.5.2.4.3.5.2.5.2.4.4.4.4.4.5.2.5.2.4.3.5.2.5.2.4.4.4.4.4.4.5.2.5.2.4.3.5.2.5.2.4.4.4.4.4.4.4.5.2.5.2.4.3.5.2.5.2.4.4.4.4.4.4.4.4.5.2.5."
"32","3","FAIL","0","module t_Clock_Prog ();\\nwire clock;\\n\\ninitial #100 $finish;\\nClock_Prog M1 (clk, {non_default, default});\\nendmodule\\n/test/P2/2021/2021_05/t_Clock_Prog.cpp\\n//Testbench file\\n\\n#include ""testbench.h""\\n\\nusing namespace std;\\n\\nvoid main() {\\n    cout << ""Hello World!"" << endl;\\n    cout << ""$finish"" << endl;\\n    cout << ""CLK-PROG"" << endl;\\n}/src/include/Clock_Prog.h\\n#include <iostream>\\n#include <stdlib.h>\\n\\nusing namespace std;\\n\\nclass Clock_Prog{\\n    private:\\n        bool clock;\\n        bool resetn;\\n    public:\\n        Clock_Prog(bool clock);\\n        ~Clock_Prog();\\n        void setClk(bool clock);\\n        void setResetn(bool resetn);\\n        bool getClk();\\n        bool getResetn();\\n        void Clock_Prog_tb(bool clock, bool resetn);\\n};/src/Clock_Prog.cpp\\n#include <iostream>\\n#include <stdlib.h>\\n\\n#include ""include/Clock_Prog.h""\\n\\nusing namespace std;\\n\\n//Constructor for Clock_Prog class\\nClock_Prog::Clock_Prog(bool clock){\\n    this->clock = clock;\\n    this->resetn = false;\\n}\\n\\n//Destructor for Clock_Prog Class\\nClock_Prog::~Clock_Prog(){\\n\\n}\\n\\nvoid Clock_Prog::setClock(){\\n\\n}\\n\\nvoid Clock_Prog::setResetn(){\\n\\n}\\n\\nbool Clock_Prog::getClock(){\\n    return this->clock;\\n}\\n\\nbool Clock_Prog::getResetn(){\\n    return this->resetn;\\n}\\n\\nvoid Clock_Prog::Clock_Prog_tb(bool clock, bool resetn){\\n    this->clock = clock;\\n    this->resetn = resetn;\\n\\n    if(!this->resetn){\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n        cout << ""CLK-PROG: RESETn"" << endl;\\n    }\\n    else{\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n        cout << ""CLK-PROG: "" << this->clock << endl;\\n    }\\n}"
"32","4","FAIL","0","I have added a non-default type with an array:\\ntypedef string array_type[5] non_default_array_type;\\nThe type is used as an argument in the Clock_Prog module:\\nClock_Prog M1 (clk, non_default_array_type);\\n### Expected output:\\nThe run log shows this:\\n[INFO] [07:27:15] Running VCS on file:./test/test_files/enum_coverage/clock_prog_enum_coverage.sv\\n[INFO] [07:27:16] Finished running VCS on file:./test/test_files/enum_coverage/clock_prog_enum_coverage"
"33","0","FAIL","0","```c++\\nvoid unpackStruct(struct PackedStruct& p) {\\n  p.s = p.a ^ p.b;  // 1/2 = 1\\n  p.ca = (p.a & p.b) ^ 1; // 1/2 = 1\\n}\\n```\\n## Results:\\nThe following table lists the number of variations that were found per Verilog file.\\n\\n|File Name|Variations|\\n|:--|--:|\\n|ha_1.v|32|\\n|ha_2.v|32|\\n|ha_3.v|32|\\n|ha_4.v|32|\\n|ha_5.v|32|\\n|ha_6.v|32|\\n|ha_7.v|32|\\n|ha_8.v|32|\\n|ha_9.v|32|\\n|ha_10.v|32|\\n|ha_11.v|32|\\n|ha_12.v|32|\\n|ha_13.v|32|\\n|ha_14.v|32|\\n|ha_15.v|32|\\n|ha_16.v|32|\\n|ha_17.v|32|\\n|ha_18.v|32|\\n|ha_19.v|32|\\n|ha_20.v|32|\\n|ha_21.v|32|\\n|ha_22.v|32|\\n|ha_23.v|32|\\n|ha_24.v|32|\\n|ha_25.v|32|\\n|ha_26.v|32|\\n|ha_27.v|32|\\n|ha_28.v|32|\\n|ha_29.v|32|\\n|ha_30.v|32|\\n|ha_31.v|32|\\n|ha_32.v|32|"
"33","1","FAIL","0","```diff\\n+   packed struct {\\n+       signed [5:0] dly_a = 1'bs0, dly_b = 1'bs0;\\n+       signed [5:0] dly_s = 1'bs0, dly_c = 1'bs0;\\n+   } delays;\\n+   \\n+   inout s; inout ca;\\n+  \\n+   parameter dly_a1 = 3; parameter dly_b1 = 2;\\n+   parameter dly_s1 = 1; parameter dly_c1 = 4;\\n+  \\n+   delays = unpack(32'd1, 32'd2);\\n+   \\n+   ha_1(s,ca,a,b);\\n+   \\n+   delay #(delays.dly_a1) s <= a;\\n+   delay #(delays.dly_b1) ca <= b;\\n+   delay #(delays.dly_s1) s <= a ^ b;\\n+   delay #(delays.dly_c1) ca <= a & b;\\n```\\n\\n### Output:\\n```\\n## Top-level Simulation (Active-HDL Verilog)\\n\\n### Command:\\n./hdl_exe ha_1_sim.v\\n\\n### Command Line Options:\\n-\\n\\n### Output Log (Simulation Details):\\n\\n### Simulation Time:\\nElapsed Time: 0.000000000 seconds.\\n\\n### Simulation Information:\\nVerilog $timescale command has been ignored.\\nVerilog $elaborate command has been ignored.\\nVerilog $stop command has been ignored.\\nVerilog $finish command has been ignored.\\nVerilog $stop command has been ignored.\\nVerilog $stop command has been ignored.\\nVerilog $stop command has been ignored.\\n\\n### Simulation Summary:\\n\\n### Simulation Results:\\n\\n|      Module  |   Instance  |   Expected  |   Actual  |  Expected  |   Actual  |\\n|--------------|-------------|-------------|-----------|------------|-----------|\\n| ha_1_sim_tb |             |             |           |            |           |\\n|              |             |             |           |            |           |\\n|              |             |             |           |            |           |\\n\\n### Simulation Passes:\\nSimulation Passed\\n\\n### Simulation Warnings:\\n\\n### Simulation Error:\\n\\n### Simulation Error Message:\\n\\n### Simulation End Time:\\nCurrent Simulation Time: 0.000000000 seconds.\\n\\n### Simulation Exit Status:\\n0\\n\\n## Top-level Simulation (ModelSim)\\n\\n### Command:\\n./modelsim.sh\\n\\n### Command Line Options:\\n-\\n\\n### Output Log (Simulation Details):\\n\\n### Simulation Time:\\nElapsed Time: 0.000 seconds.\\n\\n### Simulation Information:\\nVerilog $timescale command has been ignored.\\nVerilog"
"33","2","FAIL","0","module ha_1(s,ca,a,b); // Half Adder with gate delays\\n  input a,b; output s,ca;\\n  xor #(1,2) (s,a,b);\\n  and #(3,4) (ca,a,b);\\nendmodule\\n### Notes:\\n1. The unpacked structure has to be declared at the top of the code file.\\n2."
"33","3","FAIL","0","module fa_1(sum,c,a,b,ci); // Full Adder with gate delays\\n  input a,b,ci; output sum,c;\\n  parameter T = $cast<int>(100);\\n  ha_1 #(T,T,T,T)(sum,c,a,b);\\n  ha_1 #(T,T,T,T)(c,ci,sum,ci);\\nendmodule\\n### Schematic:\\n![Schematic for 3rd variation](schematics/fa_1.png)\\n# 5. Detailed Description of the Method\\n### 5.1 How the Code is Tested\\nThe code is tested using three test-bench files, testbench_ha_1.v, testbench_ha_2.v, testbench_fa_1.v, each with a different variation instruction. All three files are in the 'testbenches' folder.\\n### 5.2 How the Code is Tested\\nThe code is tested using three test-bench files, testbench_ha_1.v, testbench_ha_2.v, testbench_fa_1.v, each with a different variation instruction. All three files are in the 'testbenches' folder.\\n### 5.3 How the Code is Tested\\nThe code is tested using three test-bench files, testbench_ha_1.v, testbench_ha_2.v, testbench_fa_1.v, each with a different variation instruction. All three files are in the 'testbenches' folder.\\n# 6. Source Code\\n### 6.1 Source Code\\nThe source code is in the folder'sources'.\\n### 6.2 Source Code\\nThe source code is in the folder'sources'.\\n### 6.3 Source Code\\nThe source code is in the folder'sources'.\\n# 7. References\\n[1], ""System Architecture"", p. 488, 2009, O'Reilly.  \\n[2], ""Verilog HDL: from Hardware to Software"", p. 32, 2010, Wiley-IEEE.  \\n[3]  and, ""The Verilog Hardware Description Language"", O'Reilly, 2011.  \\n[4],,, and, ""Verilog HDL: From Hardware to Software"", Addison-Wesley, 2012.  \\n[5],,, ""Verilog HDL - Digital Systems for the Internet of Things Using SystemVerilog"", Wiley-IEEE, 2013.  \\n[6], ""Verilog HDL: The Hardware Description Language"", John Wiley & Sons, 2017.  \\n[7], ""Introduction to Verilog"", p. 203, 2005, Wiley.  \\n[8], ""Verilog HDL: From Hardware to Software"", Addison-Wesley, 1990.  \\n[9], ""Verilog HDL: From Hardware to Software"", Addison-Wesley, 2010.  \\n[10], ""Verilog HDL: From Hardware to Software"", p. 264, 2010, Wiley-IEEE.  \\n/project_4/sources/ha_1.h\\n#ifndef HA_1_H\\n#define HA_1_H\\n\\n#include <systemc.h>\\n\\nSC_MODULE(ha_1){\\n  public:\\n    // inputs\\n    sc_in<bool> ca; sc_in<bool> s; sc_in<bool> b; sc_in<bool> a;\\n\\n    // output\\n    sc_out<bool> sum; sc_out<bool> c;\\n    \\n    void calculate_ha_1(){\\n      sum = ca ^ b;\\n      c = s ^ a;\\n    }\\n\\n    SC_CTOR(ha_1){\\n       SC_METHOD(calculate_ha_1);\\n       sensitive << ca << s << b << a;\\n    }\\n};\\n\\n#endif"
"33","4","FAIL","0","module ha_1(s,ca,a,b); // Half Adder with gate delays\\n  input a,b; output s,ca;\\n  wire [1:0] op1;\\n  wire [1:0] op2;\\n  assign op1 = a;\\n  assign op2 = b;\\n  xor #(1,2) (s,op1,op2);\\n  and #(3,4) (ca,op1,op2);\\nendmodule\\n### Variation Test Cases:\\n1.\\nfunction bit[] ha_1(bit[] _s, bit[] _ca, bit[] _a, bit[] _b) {\\n  bit[] op1;\\n  bit[] op2;\\n  wire [1:0] op1;\\n  wire [1:0] op2;\\n  assign op1 = _a;\\n  assign op2 = _b;\\n  xor #(1,2) (_s,op1,op2);\\n  and #(3,4) (_ca,op1,op2);\\n  return ();\\n}\\n2.\\nfunction bit[] ha_1(bit[] _s, bit[] _ca, bit[] _a, bit[] _b) {\\n  bit[] op1;\\n  bit[] op2;\\n  wire [1:0] op1;\\n  wire [1:0] op2;\\n  assign op1 = _a;\\n  assign op2 = _b;\\n  xor #(1,2) (_s,op1,op2);\\n  and #(3,4) (_ca,op1,op2);\\n  return ();\\n}/tests/basic/assign/assign_function_tuple_struct_packed_in_unpacked_tuple.cpp\\n// Copyright 2020 \\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the ""Software""), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\n// Original test case source\\n// Copyright (c) 2020 The Regents of the University of California\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the ""Software""),\\n// to deal in the Software without restriction, including without limitation\\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\\n// and/or sell copies of the Software, and to permit persons to whom the\\n// Software is furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\\n// DEALINGS IN THE SOFTWARE.\\n\\n// Original test case source\\n// Copyright 2020 \\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the ""Software""), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\n// Original test case source\\n// Copyright (c) 2006 by,  and \\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the ""Software""),\\n// to deal in the Software without restriction, including without limitation\\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\\n// and/or sell copies of the Software, and to permit persons to whom the\\n// Software is furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\\n// DEALINGS IN THE SOFTWARE.\\n\\n// Original test case source\\n// Copyright 2020 \\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the ""Software""), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\n// Original test case source\\n// Copyright (c) 2007 by \\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the ""Software""),\\n// to deal in the Software without restriction, including without limitation\\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\\n// and/or sell copies of the Software, and to permit persons to whom the\\n// Software is furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\\n// DEALINGS IN THE SOFTWARE.\\n\\n#include <systemc.h>\\n\\nSC_MODULE(assign_function_tuple_struct_packed_in_unpacked_tuple) {\\n  // Module Interface\\n  sc_out<sc_uint<1> > o;\\n\\n  // Module Variables\\n  sc_uint<1> r;\\n  sc_uint<1> b;\\n\\n  // Module Constructor\\n  SC_CTOR(assign_function_tuple_struct_packed_in_unpacked_tuple) {}\\n\\n  // Module Initializer\\n  void do_init() {\\n    r = 0;\\n    b = 0;\\n  }\\n\\n  // Module Process\\n  void do_work() {\\n    o = b;\\n  }\\n};\\n\\nint sc_main(int argc, char **argv) {\\n  // Instantiate Module\\n  assign_function_tuple_struct_packed_in_unpacked_tuple _a_f_"
"34","0","FAIL","0","module top(input clk, input reset, input [3:0] data_i, output [3:0] data_o, input [3:0] data_i_p);\\nassign data_o = data_i_p;\\n\\nendmodule\\n### Expected Results\\nThe system should correctly compile the modified code./Assignment5/5.4/README.md\\n### Base code:\\nmodule top(input clk, input reset, input [3:0] data_i, output [3:0] data_o);"
"34","1","FAIL","0","```\\nmodule wire_assign( input in, output out );\\n    // assign out to in\\n    wire[1:0] clock;\\n    wire in_val;\\n    wire out_val;\\n    assign in_val = in;\\n    assign out_val = clock[0];\\n    always@(posedge in)\\n        clock[0] = in_val;\\n    always@(posedge in)\\n        clock[1] = in_val;\\nendmodule\\n```\\n### Verilog Example:\\n```\\nmodule wire_assign( input in, output out );\\n    // assign out to in\\n    wire[1:0] clock;\\n    wire in_val;\\n    wire out_val;\\n    assign in_val = in;\\n    assign out_val = clock[0];\\n    always@(posedge in)\\n        clock[0] = in_val;\\n    always@(posedge in)\\n        clock[1] = in_val;\\nendmodule\\n    //\\n    // test to see if signal is 1\\n    // assign out to in\\n    wire[1:0] clock;\\n    wire in_val;\\n    wire out_val;\\n    assign in_val = in;\\n    assign out_val = clock[0];\\n    always@(posedge in)\\n        assign out_val = clock[0];\\n    always@(posedge clock[0])\\n        assign out_val = clock[1];\\n    always@(posedge clock[1])\\n        assign out_val = clock[0];\\n    always@(posedge clock[1])\\n        assign out_val = clock[0];\\nendmodule\\n```/hw/verilog_to_fpga/verilog_to_fpga/verilog_to_fpga.py\\n# \\n# 2018-04-03\\n# CSCI 4810 / 5810 - Fall 2018\\n# Verilog to FPGA\\n#\\n# The verilog_to_fpga.py tool has two modes:\\n#   - parse:    parse the given input file, and produce a data structure\\n#   - compile:  compile the data structure to produce a new file, and optional\\n#               verilog file\\n#\\n# parse:\\n#   input:  one file with verilog statements and comments of the form\\n#   /*\\n#   <verilog statement>\\n#   */\\n#\\n#   and output:\\n#   {\\n#     ""<verilog statement>"": {\\n#       ""<verilog line>"": {\\n#         ""comment"": ""<verilog line comment>"",\\n#         ""loc"": <line number>,\\n#         ""contents"": <contents of line>\\n#       }\\n#     }\\n#   }\\n#\\n# compile:\\n#   input:  one file with the parsed verilog data structure\\n#   and output:\\n#   {\\n#     ""<verilog statement>"": {\\n#       ""<verilog line>"": {\\n#         ""comment"": ""<verilog line comment>"",\\n#         ""loc"": <line number>,\\n#         ""contents"": <contents of line>\\n#       }\\n#     }\\n#   }\\n#\\n# The output verilog file is generated on the fly, and is equivalent to the\\n# input verilog file except of the following:\\n#   1) module inputs are replaced with wires for each module, and wires are\\n#      replaced with registers if the wire width is non-trivial\\n#   2) module outputs are replaced with wires for each module, and assign\\n#      statements are removed from the module\\n#   3) wire assignments are added to the top level module, with the wire\\n#      assignments coming before the module\\n#   4) other modules are moved to the top level, with the module name as the\\n#      wire name\\n#\\n# An example of the data structure to use with compile is:\\n# {\\n#     ""module wire_assign"": {\\n#         ""assign out = in"": {\\n#             ""comment"": ""// assign out to in"",\\n#             ""loc"": 6,\\n#             ""contents"": ""assign out = in""\\n#         },\\n#         ""module wire_assign( input in, output out )"": {\\n#             ""comment"": ""// Create a module with one input and one output that behaves like a wire"",\\n#             ""loc"": 5,\\n#             ""contents"": ""module wire_assign( input in, output out )""\\n#         },\\n#     }\\n# }\\n#\\n# The module inputs are replaced with the wire inputs, and the module outputs\\n# are replaced with wire outputs.  The assign statements are added as wire\\n# assignments to the top level module.  The top level module is renamed to the\\n# module name, and the module inputs are assigned to the wire inputs and the\\n# module outputs are assigned to the wire outputs.\\n\\nimport sys\\nimport re\\nimport pprint\\nimport argparse\\nimport random\\n\\n#\\n# Verilog parser\\n#\\n\\ndef parse_input(input_file, debug=False):\\n    '''Parse a verilog file, and return a data structure.\\n\\n    The input file is assumed to be a single file containing the verilog\\n    statements and comments '''\\n    #\\n    # Data structure\\n    # {\\n    #     ""<verilog statement>"": {\\n    #         ""<verilog line>"": {\\n    #             ""comment"": ""<verilog line comment>"",\\n    #             ""loc"": <line number>,\\n    #             ""contents"": <contents of line>\\n    #         }\\n    #     }\\n    # }\\n    #\\n    data = {}\\n    with open(input_file, 'r') as inf:\\n        for line_number, line in enumerate(inf, start=1):\\n            #\\n            # Skip empty lines and comments\\n            #\\n            line = line.lstrip()\\n            if len(line) == 0 or line.startswith('//'):\\n                continue\\n            #\\n            # Parse verilog statement\\n            #\\n            m = re.match('^([a-zA-Z_][a-zA-Z0-9_]*)( *\\([^)]*\\))? *([a-zA-Z_][a-zA-Z0-9_]*)(=|\\+=|\\-=)( *\\([^]]*\\))?')\\n            if not m:\\n                raise Exception('Could not parse verilog statement on line %d' % line_number)\\n            statement = m.group(1).strip()\\n            if statement not in data:\\n                data[statement] = {}\\n            #\\n            # Parse verilog line\\n            #\\n            # TODO:  match line and comments\\n            #\\n            m = re.match('^ *([a-zA-Z0-9_.]+)( *;)?', line)\\n            if not m:\\n                raise Exception('Could not parse verilog line on line %d' % line_number)\\n            contents = m.group(1).strip()\\n            comment = ''\\n            if m.group(2):\\n                comment = m.group(2).strip()\\n            data[statement][contents] = {\\n                'comment': comment,\\n                'loc': line_number,\\n                'contents': contents\\n            }\\n    return data\\n\\n#\\n# Verilog compiler\\n#\\n\\ndef compile_input(input_file, output_file, debug=False):\\n    '''Compile a verilog file, and return a data structure.\\n\\n    The input file is assumed to be the output from parse_input, and is\\n    modified in-place.  The output file is written to the top level module. '''\\n    #\\n    # Data structure\\n    # {\\n    #     ""<verilog statement>"": {\\n    #         ""<verilog line>"": {\\n    #             ""comment"": ""<verilog line comment>"",\\n    #             ""loc"": <line number>,\\n    #             ""contents"": <contents of line>\\n    #         }\\n    #     }\\n    # }\\n    #\\n    data = {}\\n    with open(input_file, 'r') as inf, open(output_file, 'w') as outf:\\n        for line_number, line in enumerate(inf, start=1):\\n            #\\n            # Skip empty lines and comments\\n            #\\n            line = line.lstrip()\\n            if len(line) == 0 or line.startswith('//'):\\n                continue\\n            #\\n            # Parse verilog statement\\n            #\\n            m = re.match('^([a-zA-Z_][a-zA-Z0-9_]*)( *\\([^)]*\\))? *([a-zA-Z_][a-zA-Z0-9_]*)(=|\\+=|\\-=)( *\\([^]]*\\))?')\\n            if not m:\\n                raise Exception('Could not parse verilog statement on line %d' % line_number)\\n            statement = m.group(1).strip()\\n            if statement not in data:\\n                data[statement] = {}\\n            #\\n            # Parse verilog line\\n            #\\n            # TODO:  match line and comments\\n            #\\n            m = re.match('^ *([a-zA-Z0-9_.]+)( *;)?', line)\\n            if not m:\\n                raise Exception('Could not parse verilog line on line %d' % line_number)\\n            contents = m.group(1).strip()\\n            comment = ''\\n            if m.group(2):\\n                comment = m.group(2).strip()\\n            data[statement][contents] = {\\n                'comment': comment,\\n                'loc': line_number,\\n                'contents': contents"
"34","2","FAIL","0","module wire_assign_wildcard( input in, output out );\\n    // Create a Clock associative array\\n    associative Clock(1'b1, 1'b0);\\n    assign out = Clock[1'b0];\\n    // assign in to out\\n    assign out = in;\\n    // assign the value of the one-bit Clock array\\n    assign out = Clock[1];\\n    // assign in to out\\n    assign out = in;\\n    // assign the value of the one-bit Clock array\\n    assign out = Clock[1];\\n    // assign in to out\\n    assign out = in;\\n    // assign the value of the one-bit Clock array\\n    assign out = Clock[1];\\nendmodule\\n### End of Module\\n```\\n\\n```\\n### Base Verilog Code:\\n// Create a module with one input and one output that behaves like a wire\\nmodule wire_assign( input in, output out );\\n    // assign a literal constant to out\\n    assign out = 1'b1;\\n    // assign in to out\\n    assign out = in;\\n    // assign in to out\\n    assign out = in;\\n    // assign in to out\\n    assign out = in;\\n    // assign in to out\\n    assign out = in;\\n    // assign in to out\\n    assign out = in;\\n    // assign in to out\\n    assign out = in;\\nendmodule\\n### Variation Instruction:\\nChange the input Clock to a wildcard-indexed associative array and access it via the inside"
"34","3","FAIL","0","// Create a module with one input and one output that behaves like a wire\\nmodule wire_assign( input in, output out );\\n    // assign out to in\\n    assign out = in;\\nendmodule#ifndef INCLUDE_H\\n#define INCLUDE_H\\n#include <iostream>\\n#include <string>\\n#include <stdio.h>\\n#include ""C:/Users//Desktop/Verilog Code/Header_Files/bit_operations.h""\\n\\n//\\n// File:   c:\\Users\\\\Desktop\\Verilog Code\\Source Files\\inc.h\\n// Author: \\n// Created on March 4, 2018, 1:35 AM\\n//\\n\\nusing namespace std;\\n\\n// This function gets the number of bits in an integer number\\nint numOfBits(int integer);\\n\\n// This function gets the number of ones in an integer number\\nint numOfOnes(int integer);\\n\\n// This function gets the number of zeros in an integer number\\nint numOfZeros(int integer);\\n\\n// This function adds two arrays of bits and returns the answer\\nint *BitAdd(int *num1, int *num2);\\n\\n// This function substracts two arrays of bits and returns the answer\\nint *BitSub(int *num1, int *num2);\\n\\n// This function multiplies two arrays of bits and returns the answer\\nint *BitMul(int *num1, int *num2);\\n\\n// This function divides two arrays of bits and returns the answer\\nint *BitDiv(int *num1, int *num2);\\n\\n// This function multiplies two arrays of bits and returns the answer\\nint *BitMod(int *num1, int *num2);\\n\\n// This function divides two arrays of bits and returns the answer\\nint *BitDiv(int *num1, int *num2);\\n\\n// This function computes bitwise NOT of an array of bits\\nint *BitNot(int *num1);\\n\\n// This function computes bitwise AND of two arrays of bits\\nint *BitAnd(int *num1, int *num2);\\n\\n// This function computes bitwise OR of two arrays of bits\\nint *BitOr(int *num1, int *num2);\\n\\n// This function computes bitwise XOR of two arrays of bits\\nint *BitXor(int *num1, int *num2);\\n\\n// This function computes bitwise XNOR of two arrays of bits\\nint *BitXNor(int *num1, int *num2);\\n\\n// This function computes bitwise NAND of two arrays of bits\\nint *BitNand(int *num1, int *num2);\\n\\n// This function computes bitwise NOR of two arrays of bits\\nint *BitNor(int *num1, int *num2);\\n\\n// This function computes bitwise EQU of two arrays of bits\\nint *BitEqu(int *num1, int *num2);\\n\\n// This function computes bitwise NEQ of two arrays of bits\\nint *BitNeq(int *num1, int *num2);\\n\\n// This function prints out an array of bits\\nvoid PrintArray(int *num1);\\n\\n// This function gets the result of an operation and prints it\\nvoid PrintFunction(int *num1, int *num2, char operatorSymbol, char functionName);\\n\\n\\n#endif /* INCLUDE_H */\\n\\n/*\\n * To change this license header, choose License Headers in Project Properties.\\n * To change this template file, choose Tools | Templates\\n * and open the template in the editor.\\n */\\n\\n/* \\n * File:   main.c\\n * Author: \\n *\\n * Created on April 11, 2018, 11:36 PM\\n */\\n\\n#include ""C:/Users//Desktop/Verilog Code/Header_Files/include.h""\\n#include ""C:/Users//Desktop/Verilog Code/Header_Files/functions.h""\\n\\n/*\\n * \\n */\\nint main(void) {\\n    int option;\\n    char op;\\n    int *num1;\\n    int *num2;\\n    bool firstNum = false;\\n    bool secondNum = false;\\n    bool isOperator = false;\\n    bool isFunction = false;\\n    \\n    printf(""Enter your numbers: "");\\n    printf(""\\n\\t0 - Ending the program\\n"");\\n    \\n    option = getchar();\\n    \\n    // This loop is used to continue to get numbers and check their validity\\n    // It also prints out the answer of different operations\\n    while (option!= 48) {\\n        // This condition checks if the user entered a number or not\\n        if (isdigit(option)) {\\n            // When the user did enter a number, it gets the number into a dynamic array\\n            num1 = getNumber(num1, 0, option, &firstNum);\\n        }\\n        else if(option == 42) { // User entered an operator\\n            if (firstNum == true) { // The user entered at least one number\\n                while (isOperator == false) {\\n                    printf(""\\nEnter your operator: "");\\n                    op = getchar();\\n                    // This checks if the user entered an operator or not\\n                    if (op == 45) {\\n                        printf(""You entered a minus (-) symbol."");\\n                        printf(""\\n\\t0 - Ending the program\\n"");\\n                        printf(""\\n\\t1 - Enter your next number\\n"");\\n                        printf(""\\n\\t2 - Enter your next operator\\n"");\\n                        printf(""\\n\\t3 - Print the answer\\n"");\\n                        scanf(""%d"", &option);\\n                        if (option == 1) {\\n                            isOperator = true;\\n                        }\\n                        else if (option == 2) {\\n                            isOperator = true;\\n                        }\\n                        else if (option == 3) {\\n                            PrintFunction(num1, num2, op, ""Subtraction"");\\n                            isOperator = true;\\n                        }\\n                        else if (option == 0) {\\n                            PrintFunction(num1, num2, op, ""Subtraction"");\\n                            exit(EXIT_SUCCESS);\\n                        }\\n                        else {\\n                            printf(""You entered invalid option."");\\n                            option = getchar();\\n                        }\\n                    }\\n                    else if (op == 43) {\\n                        printf(""You entered a plus (+) symbol."");\\n                        printf(""\\n\\t0 - Ending the program\\n"");\\n                        printf(""\\n\\t1 - Enter your next number\\n"");\\n                        printf(""\\n\\t2 - Enter your next operator\\n"");\\n                        printf(""\\n\\t3 - Print the answer\\n"");\\n                        scanf(""%d"", &option);\\n                        if (option == 1) {\\n                            isOperator = true;\\n                        }\\n                        else if (option == 2) {\\n                            isOperator = true;\\n                        }\\n                        else if (option == 3) {\\n                            PrintFunction(num1, num2, op, ""Addition"");\\n                            isOperator = true;\\n                        }\\n                        else if (option == 0) {\\n                            PrintFunction(num1, num2, op, ""Addition"");\\n                            exit(EXIT_SUCCESS);\\n                        }\\n                        else {\\n                            printf(""You entered invalid option."");\\n                            option = getchar();\\n                        }\\n                    }\\n                    else if (op == 47) {\\n                        printf(""You entered a division (/) symbol."");\\n                        printf(""\\n\\t0 - Ending the program\\n"");\\n                        printf(""\\n\\t1 - Enter your next number\\n"");\\n                        printf(""\\n\\t2 - Enter your next operator\\n"");\\n                        printf(""\\n\\t3 - Print the answer\\n"");\\n                        scanf(""%d"", &option);\\n                        if (option == 1) {\\n                            isOperator = true;\\n                        }\\n                        else if (option == 2) {\\n                            isOperator = true;\\n                        }\\n                        else if (option == 3) {\\n                            PrintFunction(num1, num2, op, ""Division"");\\n                            isOperator = true;\\n                        }\\n                        else if (option == 0) {\\n                            PrintFunction(num1, num2, op, ""Division"");\\n                            exit(EXIT_SUCCESS);\\n                        }\\n                        else {\\n                            printf(""You entered invalid option."");\\n                            option = getchar();\\n                        }\\n                    }\\n                    else if (op == 42) {\\n                        printf(""You entered a multiplication (*) symbol."");\\n                        printf(""\\n\\t0 - Ending the program\\n"");\\n                        printf(""\\n\\t1 - Enter your next number\\n"");\\n                        printf(""\\n\\t2 - Enter your next operator\\n"");\\n                        printf(""\\n\\t3 - Print the answer\\n"");\\n                        scanf(""%d"", &option);\\n                        if (option == 1) {\\n                            isOperator = true;\\n                        }\\n                        else if (option == 2) {\\n                            isOperator = true;\\n                        }\\n                        else if (option =="
"34","4","FAIL","0","[source, c]\\n----\\ninclude::src/main/c/assign_array.c[lines=34..40]\\n----\\n### Expected Outcome:\\n----\\n$./run.sh\\nTesting assign_array.c...\\nTesting assign_array_c.c...\\n----\\n### Actual Outcome:\\n----\\n$./run.sh\\nTesting assign_array.c...\\nTesting assign_array_c.c...\\n    @@@@ Test case failed with message: mismatch\\n----\\n\\n/src/main/c/func_attr.c\\n\\n#include ""vhls_c_test.h""\\n\\n#define SIZE 5\\n#define ROWS 6\\n#define COLS 4\\n\\n#define OUT_SIZE 5\\n\\n#include ""func_attr.h""\\n\\n#include ""vhls_c_test.h""\\n\\n// Function Attr: HLS_S_AXI_MEM\\n\\nvoid func_attr_c( ap_uint<16> matrix_in[SIZE][ROWS][COLS], int rows, int cols, ap_uint<16> out[OUT_SIZE][ROWS]) {\\n    for(int i = 0; i < cols; i++) {\\n        for(int j = 0; j < ROWS; j++) {\\n            for(int k = 0; k < SIZE; k++) {\\n                out[k][j] = matrix_in[k][j][i];\\n            }\\n        }\\n    }\\n}\\n/src/main/c/assign_array.c\\n\\n#include ""vhls_c_test.h""\\n\\n#define SIZE 5\\n#define ROWS 6\\n#define COLS 4\\n\\n#define OUT_SIZE 5\\n\\n\\n#include ""assign_array.h""\\n\\n// Array indexing: HLS_S_AXI_MEM, HLS_S_AXI_BRAM, and HLS_S_AXI_AESL_WORLD\\n\\nvoid assign_array_c( ap_uint<16> matrix_in[SIZE][ROWS][COLS], int rows, int cols, ap_uint<16> out[OUT_SIZE][ROWS]) {\\n    for(int i = 0; i < cols; i++) {\\n        for(int j = 0; j < ROWS; j++) {\\n            for(int k = 0; k < SIZE; k++) {\\n                //out(k,j) = matrix_in[k][j][i];\\n                // Alternate approach: use inside indexing operator\\n                out[k][j] = matrix_in[k][j][i];\\n            }\\n        }\\n    }\\n}\\n/src/main/c/assign_wildcard.c\\n\\n#include ""vhls_c_test.h""\\n\\n#define SIZE 5\\n#define ROWS 6\\n#define COLS 4\\n\\n#define OUT_SIZE 5\\n\\n#include ""assign_wildcard.h""\\n\\n// Wildcard indexing: HLS_S_AXI_MEM, HLS_S_AXI_BRAM, and HLS_S_AXI_AESL_WORLD\\n\\nvoid assign_wildcard_c( ap_uint<16> matrix_in[SIZE][ROWS][COLS], int rows, int cols, ap_uint<16> out[OUT_SIZE][ROWS]) {\\n    for(int i = 0; i < cols; i++) {\\n        for(int j = 0; j < ROWS; j++) {\\n            for(int k = 0; k < SIZE; k++) {\\n                //out(k,j) = matrix_in[k][j][i];\\n                // Alternate approach: use inside indexing operator\\n                out[k][j] = matrix_in[k][j][i];\\n            }\\n        }\\n    }\\n}\\n/src/main/vhls/assign_wildcard/Makefile\\n\\n.PHONY: all clean\\n\\nall: func_attr.cpp.xo\\n\\nclean:\\n	rm -rf *.xo *.xclbin *.xclbin.info *.rpt *.debug.log *.csv\\n\\n.INTERMEDIATES: *.cpp.xo\\n/scripts/test_all.sh\\n\\n./run.sh\\n\\n# Make sure there are no more errors\\necho """"\\nif [ -z ""$(grep -r --include=*.log ""Error:)"".)"" ]; then\\n    echo ""Success: All tests passed""\\nelse\\n    echo ""Error: At least one test failed""\\nfi\\n\\necho """"\\necho ""Finished testing all cases""\\n/src/main/c/read_write.h\\n// Read-Write: HLS_S_AXI_MEM\\n\\n#ifndef READ_WRITE_H_\\n#define READ_WRITE_H_\\n\\nextern ""C"" {\\n    void read_write_c( ap_uint<16> matrix_in[SIZE][ROWS][COLS], int rows, int cols, ap_uint<16> out[OUT_SIZE][ROWS]);\\n}\\n\\n#endif /* READ_WRITE_H_ */\\n/src/main/vhls/read_write/read_write.cpp\\n\\n#include ""opencv/cv.h""\\n#include ""opencv/highgui.h""\\n#include ""opencv2/imgproc/imgproc.hpp""\\n#include ""hls_video.h""\\n\\n#define SIZE 5\\n#define ROWS 6\\n#define COLS 4\\n\\n#define OUT_SIZE 5\\n\\n#include ""read_write.h""\\n\\n#include ""vhls_c_test.h""\\n\\n// Read-Write: HLS_S_AXI_MEM\\n\\nvoid read_write_cpp( ap_uint<16> matrix_in[SIZE][ROWS][COLS], int rows, int cols, ap_uint<16> out[OUT_SIZE][ROWS]) {\\n    for(int i = 0; i < cols; i++) {\\n        for(int j = 0; j < ROWS; j++) {\\n            for(int k = 0; k < SIZE; k++) {\\n                out[k][j] = matrix_in[k][j][i];\\n            }\\n        }\\n    }\\n}\\n/src/main/vhls/func_attr/func_attr.cpp\\n\\n#include ""opencv/cv.h""\\n#include ""opencv/highgui.h""\\n#include ""opencv2/imgproc/imgproc."
